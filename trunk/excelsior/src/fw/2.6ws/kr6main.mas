:UPDATE_CASH_S
        [ ALU=A+1 bus_A=RW_PC RD_MEM_A FLAG=ZERO ]
        [ WR_CASH RD_MEM_D RETURN ]

:HALTED % R4 - Halt number
        [ ALU=A_AND_B bus_A=M CONST D=4 FLAG=Z ]
        [ ALU=A bus_A=R4 bus_B=WR_R6 GO_TRUE ADR=HALT1 ]
        [ CONST->R1 D=2 ]
        [ GOTO ADR=INTERUPT ]
:HALT1  [ CALL ADR=SAVE_REGS ]
        [ ALU=A bus_A=R6 bus_B=WR_R1 GOTO ADR=CONSOL ]

:CHECK_H % ПРОВЕРКА НАЛИЧИЯ МЕСТА НА ПРОЦЕДУРНОМ СТЕКЕ
         % R2-Size, Destroed R2, FLAG.
        [ ALU=A+B bus_A=RW_R2 bus_B=S ]
        [ ALU=A-B bus_A=R2 bus_B=H FLAG=CARRY ]
        [ RETURN_FALSE ALU=A+B bus_A=M bus_B=M FLAG=CARRY ]
        [ RETURN_FALSE ]
:TRAP40 [ CALL ADR=DEC_PC ]
:TRAP40S[ CONST->R1 D=40 ]
        [ GOTO ADR=TRAPED ]
:TRAP4A [ CONST->R1 D=4A ]
        [ GOTO ADR=TRAPED ]
:TRAP41 [ CONST->R1 D=41 ]

:TRAPED         % R1-Trap no.
        [ ALU=A+B  bus_A=P CONST D=6 WR_MEM_A ]
        [ bus_B=R1 WR_MEM_D ]
:INTERUPT       % R1-Trap no.
        [ ALU=A-B bus_A=R1 CONST D=3F FLAG=CARRY ]
        [ ALU=A bus_A=R1 bus_B=WR_R4 GO_FALSE ADR=INT1 ]
        [ CONST->R1 D=3F ]
:INT1   % R1 - vector, R4 - trap no
        [ ALU=A-B bus_A=R4 CONST D=0C FLAG=CARRY ]
        [ GO_TRUE ADR=INT2 ALU=A bus_A=R1 bus_B=WR_R3 FLAG=Z ]
        % Trap no < 0Ch
        [ GO_TRUE ADR=INT5 ] % Go if trap no = 0
        [ CONST->R2 D=1 ]
:INT4   [ ALU=A-1 bus_A=RW_R3 FLAG=Z ]
        [ ALU=ROL(A) bus_A=RW_R2 GO_FALSE ADR=INT4 ]
:INT3   [ ALU=A_AND_B bus_A=M  bus_B=R2 FLAG=Z ]
        [ GO_FALSE ADR=TRAP_S ]
        [ ALU=A_AND_B bus_A=R2 CONST D=0FC FLAG=Z ]
        [ GO_FALSE ADR=HALTED ]
:INT5   [ FLAG=ZERO FINISH ]
:INT2   % Trap no >= 0Ch
        [ ALU=A-B bus_A=R4 CONST D=3F FLAG=CARRY ]
        [ GO_FALSE ADR=TRAP_S ]% Go if trap no >= 0Ch & < 3F
        [ ALU=A+B bus_A=M bus_B=M FLAG=CARRY ]
        [ GO_TRUE ADR=TRAP_S ]
        [ ALU=A-B bus_A=R4 CONST D=45 FLAG=CARRY ]
        [ GO_FALSE ADR=INT5 ]
        [ ALU=A-B bus_A=R4 CONST D=4D FLAG=CARRY ]
        [ GO_TRUE ADR=INT5 ]
        [ GOTO ADR=HALTED ]

:SAVE_STK       % T=5+2*n   Destroed R3, R4, FLAG.
        [ ALU=A bus_A=S bus_B=WR_R3 WR_MEM_A
          FLAG=STK_EMPTY GO_IF_REQUEST ADR=SAVE_1 ]
        [ bus_A=STACK->R4 bus_B=Etop WR_MEM_D ]
:SAVE_2 [ ALU=A+1 bus_A=RW_S WR_MEM_A
          FLAG=STK_EMPTY GO_IF_REQUEST ADR=SAVE_1 ]
        [ bus_A=STACK->Etop bus_B=R4 WR_MEM_D ]
        [ ALU=A+1 bus_A=RW_S WR_MEM_A
          FLAG=STK_EMPTY GO_IF_REQUEST ADR=SAVE_1 ]
        [ bus_A=STACK->R4 bus_B=Etop WR_MEM_D GOTO ADR=SAVE_2 ]
:SAVE_1 [ ALU=A-B bus_A=S bus_B=RW_R3 ]
        [ bus_B=R3 WR_MEM_D ]
        [ ALU=A+1 bus_A=RW_S RETURN FLAG=ZERO ]

:RESTORE_STK    % T=4+3*n Destroed R3, FLAG.
        [ ALU=A-1 bus_A=RW_S RD_MEM_A ]
        [ bus_B=WR_R3 RD_MEM_D ]
        [ ALU=A_AND_B bus_A=RW_R3 CONST D=0F FLAG=Z ]
:RES_1  [ ALU=A-1 bus_A=RW_R3 FLAG=Z RETURN_TRUE ]
        [ ALU=A-1 bus_A=RW_S RD_MEM_A ]
        [ bus_A=Etop->STACK bus_B=WR_Etop RD_MEM_D GOTO ADR=RES_1 ]

:SAVE_REGS      % T=25  Destroed R3, R4.
        [ ALU=ASL(A-B) bus_A=RW_PC bus_B=F CALL ADR=SAVE_STK ]
        [ ALU=ASL(A) bus_A=RW_PC ]
        [ ALU=A+B bus_A=RW_PC RW_CASH_PC ]
        [ ALU=A+B bus_A=P CONST D=0 WR_MEM_A ]
        [ bus_B=G WR_MEM_D ]
        [ ALU=A+B bus_A=P CONST D=1 WR_MEM_A ]
        [ bus_B=L WR_MEM_D ]
        [ ALU=A+B bus_A=P CONST D=2 WR_MEM_A ]
        [ bus_B=PC WR_MEM_D ]
        [ ALU=A+B bus_A=P CONST D=3 WR_MEM_A ]
        [ bus_B=M WR_MEM_D ]
        [ ALU=A+B bus_A=P CONST D=4 WR_MEM_A ]
        [ bus_B=S WR_MEM_D ]
        [ CONST D=1 WR_MEM_A ]
        [ bus_B=P WR_MEM_D RETURN ]

:RESTORE_REGS   % T=28  Destroed R3, FLAG.
        [ CONST D=0 WR_MEM_A ]
        [ bus_B=P WR_MEM_D ]
        [ ALU=A+B bus_A=P CONST D=0 RD_MEM_A ]
        [ bus_B=WR_G RD_MEM_D ]
        [ ALU=A+B bus_A=P CONST D=1 RD_MEM_A ]
        [ bus_B=WR_L RD_MEM_D ]
        [ ALU=A+B bus_A=P CONST D=2 RD_MEM_A ]
        [ bus_B=WR_PC RD_MEM_D ]
        [ ALU=A+B bus_A=P CONST D=3 RD_MEM_A ]
        [ bus_B=WR_M RD_MEM_D ]
        [ ALU=A+B bus_A=P CONST D=4 RD_MEM_A ]
        [ bus_B=WR_S RD_MEM_D ]
        [ ALU=A+B bus_A=P CONST D=5 RD_MEM_A ]
        [ bus_B=WR_H RD_MEM_D CALL ADR=RESTORE_STK ]
        [ bus_B=G RD_MEM_A ]
        [ bus_B=WR_F RD_MEM_D ]
        [ ALU=A bus_A=PC RW_CASH_PC ]
        [ ALU=ASR(A) bus_A=RW_PC ]
        [ ALU=ASR(A) bus_A=RW_PC ]
        [ ALU=A+B bus_A=RW_PC bus_B=F ]
        [ bus_B=PC  RD_MEM_A ]
        [ WR_CASH   RD_MEM_D ]
        [ bus_B=M RESET_DEBUG ]
        [ ALU=A-B bus_A=RW_H CONST D=10 RETURN ]

:TRANSFER % R1-Pto, R2-Pfrom    T=59,   Exit by FINISH !!!
        [ bus_B=R1 RD_MEM_A ]
        [ bus_B=WR_R5 RD_MEM_D ]
        [ bus_B=R2 WR_MEM_A ]
        [ bus_B=P  WR_MEM_D CALL ADR=SAVE_REGS ]
        [ ALU=A bus_A=R5 bus_B=WR_P CALL ADR=RESTORE_REGS ]
        [ FLAG=ZERO FINISH ]

:TRAP_S % R1 - vector                   Exit by FINISH !!!
        [ ALU=A+B bus_A=RW_R1 bus_B=R1 ]
        [ ALU=A+B bus_A=R1 CONST D=1 RD_MEM_A ]
        [ bus_B=WR_R2 RD_MEM_D GOTO ADR=TRANSFER ]


:Call_External    % R4-Module no, R5-Procedure no.
        [ bus_B=R4    RD_MEM_A ] % this dereference must be executed
        [ bus_B=WR_R4 RD_MEM_D ] % before first writting in memory (see CM)
        [ ALU=A   bus_A=S bus_B=WR_R2 WR_MEM_A ]
        [         bus_B=G             WR_MEM_D CALL ADR=GET_PC ]
        [ ALU=A+1 bus_A=RW_S WR_MEM_A ]
        [ bus_B=L            WR_MEM_D ]
        [ ALU=ROR(B) CONST->R3   D=1  ]
        [ ALU=A_OR_B bus_A=RW_PC bus_B=R3 ]
        [ ALU=A+1    bus_A=RW_S  WR_MEM_A ]
        [            bus_B=PC    WR_MEM_D ]
        [ ALU=A+B    bus_A=RW_S  CONST D=2  ]
        [ bus_B=R4   RD_MEM_A    bus_A=WR_G ALU=B ]
        [ bus_B=WR_F RD_MEM_D    GOTO ADR=MARK2 ]

:Call_Global      % R5-Procedure no.

        [ ALU=A bus_A=S bus_B=WR_R2 WR_MEM_A ]
:Call_Global1
        [ bus_B=L WR_MEM_D CALL ADR=GET_PC ]
        [ ALU=A+1 bus_A=RW_S WR_MEM_A GOTO ADR=MARK1 ]

:Call_Local       % R5-Procedure no.

        [ ALU=A bus_A=Etop bus_B=WR_R1 ]
        [ bus_A=STACK->Etop ]

:MARK   % R1-X, Destroed R2,R3,PC
        [ ALU=A bus_A=S bus_B=WR_R2 WR_MEM_A ]
        [ bus_B=R1 WR_MEM_D CALL ADR=GET_PC ]
        [ ALU=A+1 bus_A=RW_S WR_MEM_A ]
:MARK1  [ bus_B=L WR_MEM_D ]
        [ ALU=A+1 bus_A=RW_S WR_MEM_A ]
        [ bus_B=PC WR_MEM_D ]
        [ ALU=A+B bus_A=RW_S CONST D=2 ]
:MARK2  [ ALU=A+B bus_A=R5 bus_B=F RD_MEM_A ]
        [ bus_B=WR_PC RD_MEM_D CALL ADR=PUT_PC ]
        [ ALU=A-B bus_A=S bus_B=H FLAG=CARRY ]
        [ ALU=A bus_A=R2 bus_B=WR_L GO_TRUE ADR=TRAP40S ]
        [ FLAG=ZERO  FINISH ]

:IMUL   % R1*Etop->Etop, FLAG=Overflow

        [ ALU=A bus_A=Etop FLAG=N ]
        [ ALU=A bus_A=R1   FLAG=N GO_FALSE ADR=IMUL_?-]
        [                         GO_FALSE ADR=IMUL_-+]

:IMUL_++[ CALL ADR=IMUL_SUB ]
        [ ALU=A   bus_A=R2 bus_B=WR_Etop RETURN_TRUE ]
        [ ALU=A+B bus_A=R2 bus_B=R2      RETURN FLAG=CARRY ]

:IMUL_?-[ ALU=NEG(A) bus_A=RW_Etop  GO_TRUE ADR=IMUL_+-]
:IMUL_--[ ALU=NEG(A) bus_A=RW_R1    CALL    ADR=IMUL_SUB ]
        [ ALU=A   bus_A=R2 bus_B=WR_Etop    RETURN_TRUE ]
        [ ALU=A+B bus_A=R2 bus_B=R2         RETURN FLAG=CARRY ]

:IMUL_-+[ ALU=NEG(A) bus_A=RW_R1 ]
:IMUL_+-[ CALL ADR=IMUL_SUB ]
        [ ALU=NEG(A) bus_A=R2  bus_B=WR_Etop RETURN_TRUE ]
        [ ALU=ROR(B) CONST->R3 D=1 ]
        [ ALU=A-B-1  bus_A=R2  bus_B=R3      RETURN FLAG=CARRY ]


:IMUL_SUB % R1*Etop -> R2 (FLAG=OVERFLOW)
        [ CONST->R3 D=1 ]
        [ ALU=A_BIC_B  bus_A=RW_R2 bus_B=R2 FLAG=ZERO GOTO ADR=IMUL_7 ]

:IMUL_2 [ ALU=A+B     bus_A=RW_R1 bus_B=R1 FLAG=CARRY GO_TRUE  ADR=IMUL_OK  ]
:IMUL_7 [ ALU=A_AND_B bus_A=Etop  bus_B=R3 FLAG=Z     GO_TRUE  ADR=IMUL_6o  ]
:IMUL_6 [ ALU=ROR(A_BIC_B) bus_A=RW_Etop bus_B=R3 FLAG=Z GO_TRUE ADR=IMUL_2 ]
        [ ALU=A+B     bus_A=RW_R2 bus_B=R1 FLAG=CARRY RETURN_TRUE           ]
        [ ALU=A+B     bus_A=RW_R1 bus_B=R1 FLAG=CARRY GO_FALSE ADR=IMUL_7   ]
        [ GOTO ADR=IMUL_7o ]

:IMUL_OK[ FLAG=ZERO RETURN ]
        % Calculation correct result after OVERFLOW occur
:IMUL_2o[ ALU=A+B     bus_A=RW_R1 bus_B=R1        RETURN_TRUE ]
:IMUL_7o[ ALU=A_AND_B bus_A=Etop  bus_B=R3 FLAG=Z             ]
:IMUL_6o[ ALU=ROR(A_BIC_B) bus_A=RW_Etop bus_B=R3 FLAG=Z GO_TRUE ADR=IMUL_2o ]
        [ ALU=A+B     bus_A=RW_R2 bus_B=R1 RETURN_TRUE        ]
        [ ALU=A+B     bus_A=RW_R1 bus_B=R1 GOTO ADR=IMUL_7o   ]

:IQUOT  % R1/Etop->Etop
        % return: R1 - остаток, FLAG - overflow
        [ ALU=A+B bus_A=R1 bus_B=R1 FLAG=CARRY ]
        [ ALU=A+B bus_A=Etop bus_B=Etop FLAG=CARRY GO_TRUE ADR=IQUOT1 ]
        [ GO_FALSE ADR=IQUOT_SUB ]
:IQUOT2   % делимое > 0, делитель < 0
        [ ALU=NEG(A) bus_A=RW_Etop ]
        [ CALL ADR=IQUOT_SUB ]
        [ ALU=NEG(A) bus_A=RW_Etop RETURN ]
:IQUOT1 [ GO_TRUE ADR=IQUOT3 ]
        % делимое < 0, делитель > 0
        [ ALU=NEG(A) bus_A=RW_R1 ]
        [ CALL ADR=IQUOT_SUB ]
        [ ALU=NEG(A) bus_A=RW_R1 ]
        [ ALU=NEG(A) bus_A=RW_Etop RETURN ]
:IQUOT3   % делимое < 0, делитель < 0
        [ ALU=NEG(A) bus_A=RW_R1 ]
        [ ALU=NEG(A) bus_A=RW_Etop ]
        [ CALL ADR=IQUOT_SUB ]
        [ ALU=NEG(A) bus_A=RW_R1 RETURN ]

:IQUOT_SUB % R1/Etop->Etop,R1 for cardinal.
        [ CONST->R2 D=0 ]
        [ ALU=A bus_A=Etop FLAG=Z ]
        [ ALU=B bus_A=WR_R4 CONST->R3 D=1 RETURN_TRUE ] % return if div by zero
        [ ALU=A-B bus_A=Etop bus_B=R1 FLAG=CARRY ] % flag = (Etop>=R1)
        [ GO_TRUE ADR=IQUOT_LP ]
:IQUOT11[ ALU=A+B    bus_A=RW_Etop bus_B=Etop ]
        [ ALU=A-B    bus_A=Etop    bus_B=R1 FLAG=CARRY ]
        [ ALU=A+B    bus_A=RW_R3   bus_B=R3 GO_FALSE ADR=IQUOT11 ]
:IQUOT_LP
        [ ALU=A-B    bus_A=R1      bus_B=Etop FLAG=CARRY ]% flag = (R1>=Etop)
        [ GO_FALSE ADR=IQUOT12 FLAG=ZERO ]
        [ ALU=A_OR_B bus_A=RW_R2   bus_B=R3 ]
:IQUOT14[ ALU=A-B    bus_A=RW_R1   bus_B=Etop ]
:IQUOT12[ ALU=ROR(A) bus_A=RW_Etop GO_TRUE ADR=IQUOT13 ]% flag = (R3=0)
        [ ALU=A-B    bus_A=R1      bus_B=Etop    FLAG=CARRY ]
        [ ALU=ROR(A_BIC_B) bus_A=RW_R3 bus_B=R4  FLAG=Z GO_FALSE ADR=IQUOT12 ]
        [ ALU=A_OR_B bus_A=RW_R2   bus_B=R3             GO_FALSE ADR=IQUOT14 ]
:IQUOT13[ ALU=A      bus_A=R2      bus_B=WR_Etop FLAG=ZERO RETURN ]

:IDIV   % R1/Etop->Etop
        % return: R1 - модуль, FLAG - overflow
        [ ALU=A+B bus_A=R1 bus_B=R1 FLAG=CARRY ]
        [ ALU=A+B bus_A=Etop bus_B=Etop FLAG=CARRY GO_TRUE ADR=IDIV1 ]
        [ GO_FALSE ADR=IQUOT_SUB ]
:IDIV2  % делимое > 0, делитель < 0  +
        [ ALU=NEG(A) bus_A=RW_Etop ]
        [ ALU=A bus_A=Etop bus_B=WR_R5 CALL ADR=IQUOT_SUB ]
        [ ALU=A bus_A=R1 FLAG=Z ]
        [ ALU=NEG(A) bus_A=RW_Etop RETURN_TRUE FLAG=ZERO ]
        [ ALU=A-B bus_A=RW_R1 bus_B=R5 ]
        [ ALU=A-1 bus_A=RW_Etop RETURN ]
:IDIV1  [ GO_TRUE ADR=IDIV3 ]
        % делимое < 0, делитель > 0  +
        [ ALU=NEG(A) bus_A=RW_R1 ]
        [ ALU=A bus_A=Etop bus_B=WR_R5 CALL ADR=IQUOT_SUB ]
        [ RETURN_TRUE ]
        [ ALU=A bus_A=R1 FLAG=Z ]
        [ ALU=NEG(A) bus_A=RW_Etop RETURN_TRUE FLAG=ZERO ]
        [ ALU=A-B bus_A=R5 bus_B=RW_R1 ]
        [ ALU=A-1 bus_A=RW_Etop RETURN ]
:IDIV3  % делимое < 0, делитель < 0
        [ ALU=NEG(A) bus_A=RW_R1 ]
        [ ALU=NEG(A) bus_A=RW_Etop ]
        [ CALL ADR=IQUOT_SUB ]
        [ ALU=NEG(A) bus_A=RW_R1 RETURN ]


:GET_PC [ ALU=ASL(A-B) bus_A=RW_PC bus_B=F ]
        [ ALU=ASL(A)   bus_A=RW_PC ]
        [ ALU=A+B      bus_A=RW_PC RW_CASH_PC RETURN ]

:PUT_PC [ ALU=A bus_A=PC RW_CASH_PC ]
:PUT_PC1[ ALU=ASR(A) bus_A=RW_PC ]
        [ ALU=ASR(A) bus_A=RW_PC ]
        [ ALU=A+B bus_A=RW_PC bus_B=F RD_MEM_A ]
        [ WR_CASH RD_MEM_D RETURN ]

:NEXT2  % R1,R2 - Next2
        [ UPDATE_CASH ]
        [ bus_B=WR_R1 INC_PC ]
        [ UPDATE_CASH ]
        [ bus_B=WR_R2 INC_PC SHIFT_EN ]
        [ ALU=A_OR_B bus_A=RW_R1 bus_B=RW_R2 RETURN ]

:NEXT4  % R2 - Next4. Destroed  R3
        [ UPDATE_CASH ]
        [ bus_B=WR_R2 INC_PC ]
        [ UPDATE_CASH ]
        [ bus_B=WR_R3 INC_PC SHIFT_EN ]
        [ ALU=A_OR_B bus_A=RW_R2 bus_B=R3 UPDATE_CASH ]
        [ bus_B=WR_R3 INC_PC SHIFT_EN ]
        [ bus_B=RW_R3 SHIFT_EN ]
        [ ALU=A_OR_B bus_A=RW_R2 bus_B=R3 UPDATE_CASH ]
        [ bus_B=WR_R3 INC_PC SHIFT_EN ]
        [ bus_B=RW_R3 SHIFT_EN ]
        [ bus_B=RW_R3 SHIFT_EN ]
        [ ALU=A_OR_B bus_A=RW_R2 bus_B=R3 RETURN ]

:SWAP_1 [ bus_A=R1->STACK FINISH ]

:CHKZ_1 [ GO_FALSE ADR=TRAP4A
          ALU=A-B bus_A=Etop bus_B=R1 FLAG=N_XOR_OVR+Z LONG ]
        [ GO_FALSE ADR=TRAP4A FLAG=ZERO ]
        [ FINISH ]

:CHK_1  % r1 - high, r2 - low
        [ bus_A=STACK->Etop ] % Etop - checked value
        [ ALU=A-B bus_A=Etop bus_B=R1 FLAG=N_XOR_OVR+Z LONG ]
        [ GO_FALSE ADR=TRAP4A
          ALU=A-B bus_A=Etop bus_B=R2 FLAG=N_XOR_OVR LONG ]
        [ GO_FALSE ADR=TRAP4A ]
        [ FLAG=ZERO FINISH ]

:RCHKZ_1[ GO_FALSE ADR=RCHKZ_2
          ALU=A-B bus_A=Etop bus_B=R1 FLAG=N_XOR_OVR+Z LONG ]
        [ ALU=B+FLAG CONST->Etop D=0 FLAG=ZERO FINISH ]
:RCHKZ_2[ CONST->Etop D=0 FLAG=ZERO FINISH ]

:RCHK_1  % r1 - high, r2 - low
        [ bus_A=STACK->Etop ] % Etop - checked value
        [ ALU=A-B bus_A=Etop bus_B=R1 FLAG=N_XOR_OVR+Z LONG ]
        [ GO_FALSE ADR=RCHKZ_2
          ALU=A-B bus_A=Etop bus_B=R2 FLAG=N_XOR_OVR LONG ]
        [ ALU=B+FLAG CONST->Etop D=0 FLAG=ZERO FINISH ]

%%%%%%%%%%%%%% Floating point operations
:F_RESTORE    %  Time = 5
        [ bus_A=STACK->M  ]                           % restore M
        [ bus_A=STACK->PC ]                           % restore PC
        [ bus_A=STACK->L  ]                           % restore L
        [ bus_A=STACK->G  ]                           % restore G
        [ bus_A=STACK->Time FLAG=ZERO RETURN ]        % restore Time

%%%%%%       UNPACK    Time = 28
%
%      UNPACK Note! R1:=ROL(R1,1)   Etop:=ROL(Etop,1)
%%%%%%
:UNPACK % constFF=FF000000h
        % const02=02000000h
        [ bus_A=STACK->R1 ]             %  R1 - left operand
        [ bus_A=Time->STACK ]           %  save Time(==s2)
        [ bus_A=G->STACK ]              %  save G   (==constFF)
        [ bus_A=L->STACK ]              %  save L   (==const02)
        [ bus_A=PC->STACK ]             %  save PC  (==tmp1)
        [ bus_A=M->STACK ]              %  save M   (==tmp2)
        [ CONST->const02 D=002 SHIFT_EN ]
        [ bus_B=RW_const02     SHIFT_EN ]
        [ bus_B=RW_const02     SHIFT_EN ]
        [ CONST->constFF D=0FF SHIFT_EN ]
        [ bus_B=RW_constFF     SHIFT_EN ]
        [ bus_B=RW_constFF     SHIFT_EN ]

        [ ALU=ROL(A)  bus_A=RW_R1   FLAG=Z ]
        [ ALU=A       bus_A=constFF bus_B=WR_e1 ]
        [ ALU=A_AND_B bus_A=R1      bus_B=RW_e1 GO_TRUE ADR=UNPACK1 ]
        [ bus_B=RW_e1 SHIFT_EN ]
        [ ALU=A_AND_B bus_A=R1      CONST->s1 D=1 ]
        [ ALU=A_OR_B  bus_A=constFF CONST->m1 D=1 ]
        [ ALU=ROL(A_BIC_B) bus_A=R1   bus_B=RW_m1 ]
        [ ALU=A_OR_B bus_A=RW_m1 bus_B=const02 GOTO ADR=UNPACK2 ]

:UNPACK1[ ALU=B bus_A=WR_s1 CONST->m1 D=0 ]

:UNPACK2[ ALU=ROL(A)  bus_A=RW_Etop FLAG=Z ]
        [ ALU=A       bus_A=constFF bus_B=WR_e2 ]
        [ ALU=A_AND_B bus_A=Etop    bus_B=RW_e2 GO_TRUE ADR=UNPACK3 ]
        [ bus_B=RW_e2 SHIFT_EN ]
        [ ALU=A_AND_B bus_A=Etop    CONST->s2 D=1 ]
        [ ALU=A_OR_B  bus_A=constFF CONST->m2 D=1 ]
        [ ALU=ROL(A_BIC_B) bus_A=Etop bus_B=RW_m2 ]
        [ ALU=A_OR_B bus_A=RW_m2 bus_B=const02 RETURN ]

:UNPACK3[ ALU=B bus_A=WR_s2 CONST->m2 D=0 RETURN ]


:UNPACK_FFCT
        [ bus_A=Time->STACK ]                   %  save Time(==s2)
        [ bus_A=G->STACK ]                      %  save G   (==constFF)
        [ bus_A=L->STACK ]                      %  save L   (==const02)
        [ bus_A=PC->STACK ]                     %  save PC  (==tmp1)
        [ bus_A=M->STACK ]                      %  save M   (==tmp2)

        [ CONST->const02 D=002 SHIFT_EN ]
        [ bus_B=RW_const02     SHIFT_EN ]
        [ bus_B=RW_const02     SHIFT_EN ]
        [ CONST->constFF D=0FF SHIFT_EN ]
        [ bus_B=RW_constFF     SHIFT_EN ]
        [ bus_B=RW_constFF     SHIFT_EN RETURN ]

%%%%%     NORMAL   Time = max 118  min 18  avg 62
%%%%%     NORMAL 0 Time = 4
%%%%%     return FLAG if uderflow

:NORMAL_ADD
        [ ALU=A bus_A=m1 FLAG=Z CALL ADR=NORM_5 ]
        [ GO_FALSE ADR=PACK ]
        [ ALU=A-B bus_A=RW_Etop bus_B=Etop GOTO ADR=F_RESTORE ]

:NORMAL_MUL
        [ ALU=A bus_A=m1 FLAG=Z CALL ADR=NORM_5 ]
        [ GO_FALSE ADR=PACK ]

:TRAP43 [ ALU=A bus_A=constFF bus_B=WR_Etop ]
        [ ALU=ROR(A_OR_B) bus_A=RW_Etop bus_B=s1 CALL ADR=F_RESTORE ]
        [ CONST->R1 D=43 ]
        [ GOTO ADR=TRAPED ]

:NORM_5 [ ALU=ROL(A) bus_A=const02 bus_B=WR_tmp1 GO_FALSE ADR=NORM_1 ]
        [ CONST->e1 ALU=B bus_A=WR_s1 D=0 RETURN FLAG=ZERO ]
:NORM_1 [ ALU=A-B bus_A=m1 bus_B=tmp1 FLAG=CARRY ]
        [ GO_FALSE ADR=NORM_2 ALU=A+1 bus_A=RW_e1 ]% while m1>=INTEGER({26}) do
        [ ALU=A_BIC_B bus_A=RW_m1 CONST D=1 ]      % ASR->ROR because 80000000
        [ ALU=ROR(A) bus_A=RW_m1 GOTO ADR=NORM_1 ] %   inc(e1); m1:=shr(m1,1)
                                                   % end (max=2)
:NORM_2 [ ALU=A-B bus_A=m1 bus_B=const02 FLAG=CARRY ]
        [ GO_TRUE ADR=NORM_3 ALU=A-1 bus_A=RW_e1 ] % while m1<INTEGER({25}) do
        [ ALU=ASL(A) bus_A=RW_m1 GOTO ADR=NORM_2 ] %   dec(e1); m1:=shl(m1,1)
                                                   % end (max=24)
:NORM_3 [ ALU=A+B bus_A=RW_m1 CONST D=2 ]          % loop  m1:=m1+2
        [ ALU=A_AND_B bus_A=m1 bus_B=tmp1 FLAG=Z ] %   if 26 & m1 = 0 then
        [ GO_TRUE ADR=NORM_4 ]                     %     exit
        [ ALU=A+1 bus_A=RW_e1 ]                    %   else inc(e1)
        [ ALU=ASR(A) bus_A=RW_m1 GOTO ADR=NORM_3 ] %     m1:=shr(m1,1)
                                                   % end loop (max=2)
:NORM_4
        [ ALU=A-B bus_A=e1 CONST D=0FF FLAG=N_XOR_OVR+Z LONG ]
        [ ALU=A+B bus_A=e1 bus_B=e1 FLAG=CARRY RETURN_TRUE ]
        [ GOTO ADR=TRAP42 ]                        % if e1>0FF  then
                                                   %   goto TRAP42 end
                                                   % FLAG:= e1<0


%%%%          PACK     Time = 13
:PACK   [ bus_B=RW_e1 SHIFT_EN ]
        [ bus_B=RW_e1 SHIFT_EN ]
        [ bus_B=RW_e1 SHIFT_EN ]
        [ ALU=A_BIC_B bus_A=RW_m1 CONST D=3 ]          % m1:=m1-{0,1}
        [ ALU=ROR(A_BIC_B) bus_A=RW_m1 bus_B=const02 ] % m1:=ROR(m1-{25},1)
        [ ALU=A_OR_B  bus_A=RW_e1 bus_B=m1  ]          % e1:=e1+m1
        [ ALU=A_OR_B  bus_A=RW_e1 bus_B=s1  ]          % e1:=e1+s1
        [ ALU=ROR(A)  bus_A=e1    bus_B=WR_Etop        % Push(ror(e1,1))
          GOTO ADR=F_RESTORE                ]

%%%%   UNPACK+PACK+NORM  Time avg 142

:TRAP42 [ CALL ADR=F_RESTORE ]
        [ CONST->Etop D=0 ]
        [ CONST->R1 D=42 ]
        [ GOTO ADR=TRAPED ]

%%%%%     FADD_SUB  Time  min     max    avg
%%%%%               Time        best 69


:FSUB_SUB
        [ CALL ADR=FNEG_SUB ]
:FADD_SUB
        [ CALL ADR=UNPACK ]
        [ ALU=A-B bus_A=e1 bus_B=e2 FLAG=CARRY ]
        [ ALU=A-B bus_A=e1 bus_B=e2 FLAG=Z GO_TRUE ADR=FADD1 ]

    % e1<e2
        [ ALU=A-B bus_A=e2 bus_B=RW_e1 ]
        [ ALU=A-B bus_A=e1 CONST D=27. FLAG=CARRY ]
        [ GO_FALSE ADR=FADD2 ]
        [ ALU=ROR(A) bus_A=RW_Etop GOTO ADR=F_RESTORE ]
:FADD2  [ ALU=A_AND_B bus_A=e1 CONST D=10 FLAG=Z ]
        [ GO_TRUE ADR=FADD3 ]
        [ bus_B=RW_m1 SHIFT_EN CALL ADR=ASRm1_1 ]
        [ bus_B=RW_m1 SHIFT_EN CALL ADR=ASRm1_1 ]
:FADD3  [ ALU=A_AND_B bus_A=e1 CONST D=8 FLAG=Z ]
        [ CALL_FALSE ADR=ASRm1 ]
:FADD4  [ ALU=A_AND_B bus_A=RW_e1 CONST D=7 FLAG=Z ]
:FADD5  [ ALU=A-1 bus_A=RW_e1 FLAG=Z GO_TRUE ADR=FADD6 ]
        [ ALU=ASR(A) bus_A=RW_m1 GO_FALSE ADR=FADD5 ]
:FADD6  [ ALU=A_XOR_B bus_A=s1 bus_B=s2 FLAG=Z ]
        [ ALU=A bus_A=s2 bus_B=WR_s1 ]
        [ ALU=A bus_A=e2 bus_B=WR_e1 GO_FALSE ADR=FADD8 ]
        [ ALU=A+B bus_A=m2 bus_B=RW_m1 GOTO ADR=NORMAL_ADD ]
:FADD8  [ ALU=A-B bus_A=m2 bus_B=RW_m1 GOTO ADR=NORMAL_ADD ]

    % e1>e2
:FADD1  [ ALU=A-B bus_A=e1 bus_B=RW_e2 GO_TRUE ADR=FADD_EQ ]
        [ ALU=A-B bus_A=e2 CONST D=27. FLAG=CARRY ]
        [ GO_FALSE ADR=FADD12 ]
        [ ALU=ROR(A) bus_A=RW_R1 bus_B=WR_Etop GOTO ADR=F_RESTORE ]
:FADD12 [ ALU=A_AND_B bus_A=e2 CONST D=10 FLAG=Z ]
        [ GO_TRUE ADR=FADD13 ]
        [ bus_B=RW_m2 SHIFT_EN CALL ADR=ASRm2_1 ]
        [ bus_B=RW_m2 SHIFT_EN CALL ADR=ASRm2_1 ]
:FADD13 [ ALU=A_AND_B bus_A=e2 CONST D=8 FLAG=Z ]
        [ CALL_FALSE ADR=ASRm2 ]
        [ ALU=A_AND_B bus_A=RW_e2 CONST D=7 FLAG=Z ]
:FADD15 [ ALU=A-1 bus_A=RW_e2 FLAG=Z GO_TRUE ADR=FADD16 ]
        [ ALU=ASR(A) bus_A=RW_m2 GO_FALSE ADR=FADD15 ]
:FADD16 [ ALU=A_XOR_B bus_A=s1 bus_B=s2 FLAG=Z ]
        [ GO_FALSE ADR=FADD18 ]
        [ ALU=A+B bus_A=RW_m1 bus_B=m2 GOTO ADR=NORMAL_ADD ]
:FADD18 [ ALU=A-B bus_A=RW_m1 bus_B=m2 GOTO ADR=NORMAL_ADD ]

:FADD_EQ[ ALU=A_XOR_B bus_A=s1 bus_B=s2 FLAG=Z ]
        [ ALU=A-B bus_A=m1 bus_B=m2 FLAG=CARRY GO_FALSE ADR=FADD20 ]
        [ ALU=A+B bus_A=RW_m1 bus_B=m2 GOTO ADR=NORMAL_ADD ]
:FADD20 [ GO_FALSE ADR=FADD21 ]
        [ ALU=A-B bus_A=RW_m1 bus_B=m2 GOTO ADR=NORMAL_ADD ]
:FADD21 [ ALU=A bus_A=s2 bus_B=WR_s1 ]
        [ ALU=A-B bus_A=m2 bus_B=RW_m1 GOTO ADR=NORMAL_ADD ]

:ASRm1  [ bus_B=RW_m1 SHIFT_EN ]
:ASRm1_1[ bus_B=RW_m1 SHIFT_EN ]
        [ bus_B=RW_m1 SHIFT_EN ]
        [ ALU=A_BIC_B bus_A=RW_m1 bus_B=constFF RETURN ]
:ASRm2  [ bus_B=RW_m2 SHIFT_EN ]
:ASRm2_1[ bus_B=RW_m2 SHIFT_EN ]
        [ bus_B=RW_m2 SHIFT_EN ]
        [ ALU=A_BIC_B bus_A=RW_m2 bus_B=constFF RETURN ]


%%%%    Time 238
:FMUL_SUB
        [ CALL ADR=UNPACK ]
        [ ALU=A+B bus_A=RW_e1 bus_B=e2 ]                %  e1:=e1+e2
        [ ALU=A-B bus_A=RW_e1 CONST D=80 ]              %  e1:=e1+80
        [ ALU=A_XOR_B bus_A=RW_s1 bus_B=s2 ]            %  s1:=s1 xor s2
        [ ALU=A bus_A=m1 bus_B=WR_tmp1 ]                %  tmp1:=m1
        [ CONST->m1 D=0 ]                               %  m1:=0

:FMUL_1 [ ALU=A_AND_B bus_A=m2 CONST D=1 FLAG=Z ]       % repeat nz:=0 IN m2
        [ ALU=ASR(A)  bus_A=RW_m2  FLAG=Z               %   m2:=shr(m2,1)
                                                        %   z:=(m2=0)
                      GO_TRUE ADR=FMUL_2 ]              %   if nz then
        [ ALU=A+B bus_A=RW_m1 bus_B=tmp1 ]              %     m1:=m1+tmp1
                                                        %   end
:FMUL_2 [ ALU=ASR(A) bus_A=RW_m1 GO_FALSE ADR=FMUL_1 ]  %   m1:=shr(m1,1)
                                                        % until z
        [ GOTO ADR=NORMAL_MUL ]

%%%%  FDIV_SUB   Time  252

:FDIV_SUB
        [ CALL ADR=UNPACK ]
        [ ALU=A bus_A=m2 FLAG=Z ]                       % if m2=0 then
        [ GO_TRUE ADR=TRAP42                            %   goto TRAP42
          ALU=A-B bus_A=RW_e1 bus_B=e2 ]                % end; e1:=e1-e2
        [ ALU=A+B bus_A=RW_e1 CONST D=80 ]              % e1:=e1+80
        [ ALU=A_XOR_B bus_A=RW_s1 bus_B=s2 ]            % s1:=s1 xor s2
        [ ALU=A bus_A=m1 bus_B=WR_tmp1 ]                % tmp1:=m1
        [ CONST->m1 D=0 ]                               % m1:=0

:FDIV_1 [ ALU=A-B bus_A=tmp1 bus_B=m2 FLAG=CARRY ]      % repeat z:=tmp1>=m2
        [ GO_FALSE ADR=FDIV_2 ]                         %   if z then
        [ ALU=A-B bus_A=RW_tmp1 bus_B=m2 ]              %     tmp1:=tmp1-m2
        [ ALU=A+1 bus_A=RW_m1 ]                         %     m1:=m1+1
:FDIV_2 [ ALU=ASR(A) bus_A=RW_m2 FLAG=Z ]               %   end m2:=shr(m2,1)
        [ ALU=ROL(A) bus_A=RW_m1 GO_FALSE ADR=FDIV_1 ]  %   m1:=rol(m1,1)
                                                        % until m2=0
        [ GOTO ADR=NORMAL_MUL ]


:FCMP_SUB % EXIT by FINISH !
        [ ALU=A-B bus_A=Etop bus_B=R1 FLAG=Z ]   % if Etop=R1 then
        [ ALU=A+B bus_A=Etop bus_B=Etop FLAG=CARRY GO_FALSE ADR=FCMP_1 ]
:FCM_EQU
        [ CONST->Etop D=0 ]                      %  Push(0); Push(0);
        [ bus_A=Etop->STACK  FLAG=ZERO FINISH ]  %  FINISH
:FCMP_1
        [ ALU=ROR(B) CONST->R2 D=1 ]
        [ ALU=A+B bus_A=R1 bus_B=R1 FLAG=CARRY GO_FALSE ADR=FCMP_2 ]
        [ ALU=A-B-1 bus_A=R2 bus_B=RW_Etop ]
:FCMP_2
        [ ALU=A_BIC_B bus_A=RW_R3 bus_B=R3 GO_FALSE ADR=FCMP_3 ]% R3 := 0
        [ ALU=A-B-1 bus_A=R2 bus_B=RW_R1 ]
:FCMP_3
        [ ALU=A-B bus_A=R1 bus_B=Etop FLAG=N_XOR_OVR LONG ]
        [ ALU=ROL(A) bus_A=RW_R2 GO_FALSE ADR=FCMP_LSS ]% R2 := 1
:FCMP_GTR
        [ bus_A=R2->STACK CONST->Etop D=0 ] [ FLAG=ZERO FINISH ]
:FCMP_LSS
        [ bus_A=R3->STACK CONST->Etop D=1 ] [ FLAG=ZERO FINISH ]

:FFCT_SUB
        [ UPDATE_CASH ]
        [ ALU=B INC_PC bus_B=WR_R1 FLAG=Z ]
        [ GO_TRUE ADR=FFCT_FLOAT ALU=A-1 bus_A=RW_R1 FLAG=Z ]
        [ GO_TRUE ADR=FFCT_TRUNC ALU=A-1 bus_A=RW_R1 FLAG=Z ]
        [ CALL ADR=DEC_PC ]
        [ CONST->R1 D=7 ]
        [ GOTO ADR=TRAPED ]

:FFCT_FLOAT
        [ CALL ADR=UNPACK_FFCT ]
        [ CONST->e1 D=9A ]
        [ CONST->s1 D=00 ]
        [ ALU=A+B bus_A=Etop bus_B=Etop FLAG=CARRY ]
        [ ALU=A bus_A=Etop bus_B=WR_m1 GO_FALSE ADR=NORMAL_MUL ]
        [ CONST->s1 D=1 ]
        [ ALU=NEG(A) bus_A=RW_m1 GOTO ADR=NORMAL_MUL ]

:FFCT_TRUNC
        [ ALU=ROL(A)  bus_A=RW_Etop FLAG=Z ]
        [ RETURN_TRUE FLAG=ZERO ]
:FFCT_TRUNC1
        [ CALL ADR=UNPACK_FFCT ]
        [ ALU=A       bus_A=constFF bus_B=WR_e1 ]
        [ ALU=A_AND_B bus_A=Etop    bus_B=RW_e1 ]
        [ bus_B=RW_e1 SHIFT_EN ]
        [ ALU=A_AND_B bus_A=Etop    CONST->s1 D=1 ]
        [ ALU=A_OR_B  bus_A=constFF CONST->m1 D=1 ]
        [ ALU=ROL(A_BIC_B) bus_A=RW_Etop bus_B=m1 ]
        [ ALU=A_OR_B bus_A=RW_Etop  bus_B=const02 ]

        [ ALU=A-B bus_A=RW_e1 CONST D=80 FLAG=CARRY ]  %      if e1<80 then
        [ GO_TRUE ADR=TRUNC_1 ]
        [ ALU=A-B bus_A=Etop bus_B=RW_Etop GOTO ADR=F_RESTORE ] % Etop:=0
:TRUNC_1
        [ ALU=B-A CONST D=1A bus_A=RW_e1 FLAG=N ]
        [ GO_FALSE ADR=TRUNC_3 ALU=A bus_A=e1 FLAG=Z ]

:TRUNC_4  % shift right
        [ ALU=A-1 bus_A=RW_e1 FLAG=Z GO_TRUE ADR=F_RESTORE ]
        [ ALU=ASR(A) bus_A=RW_Etop FLAG=ZERO GO_FALSE ADR=TRUNC_4 ]
        [ ALU=A bus_A=s1 FLAG=Z ]
        [ FLAG=ZERO GO_TRUE ADR=F_RESTORE ]
        [ ALU=NEG(A) bus_A=RW_Etop GOTO ADR=F_RESTORE ]

:TRUNC_3  % shift left
        [ ALU=A+1 bus_A=RW_e1 FLAG=Z GO_TRUE ADR=TRUNC_OVR ]
        [ ALU=A+B bus_A=RW_Etop bus_B=Etop FLAG=OVR GO_FALSE ADR=TRUNC_3 ]
        [ ALU=A bus_A=s1 FLAG=Z GO_TRUE ADR=TRUNC_OVR ]
        [ FLAG=ZERO GO_TRUE ADR=F_RESTORE ]
        [ ALU=NEG(A) bus_A=RW_Etop GOTO ADR=F_RESTORE ]
:TRUNC_OVR
        [ CALL ADR=F_RESTORE ]
        [ GOTO ADR=TRAP41 ]

:FNEG_SUB
        [ ALU=A bus_A=Etop FLAG=Z ]
        [ ALU=ROR(B) CONST->R1 D=1 FLAG=ZERO RETURN_TRUE ]
        [ ALU=A_XOR_B bus_A=RW_Etop bus_B=R1 RETURN ]

:FABS_SUB
        [ ALU=ROR(B) CONST->R1 D=1 ]
        [ ALU=A_BIC_B bus_A=RW_Etop bus_B=R1 RETURN ]

%%%%%%% Bit block operations

:UNBPK_1
        [ bus_A=STACK->R1 ]
        [ ALU=A_AND_B bus_A=R1 CONST->R2 D=1F ] % R2:=offset MOD 32
        [ ALU=ASR(A) bus_A=RW_R1 ]
        [ ALU=ASR(A) bus_A=RW_R1 ]
        [ ALU=ASR(A) bus_A=RW_R1 ]
        [ ALU=ASR(A) bus_A=RW_R1 ]
        [ ALU=ASR(A) bus_A=RW_R1 ]
        [ ALU=A+B bus_A=STACK->R1 bus_B=R1 RD_MEM_A ]
        [ bus_B=WR_R3                      RD_MEM_D ]

        [ ALU=A-1 bus_A=RW_Etop ]
        [ ALU=A_BIC_B bus_A=Etop CONST D=1F FLAG=Z ]
        [ GO_FALSE ADR=TRAP4A ALU=A+1 bus_A=RW_Etop bus_B=WR_R5 ]
        % if not size in {1..32} then trap(4Ah) end
        % R5:=size

        [ ALU=A+B bus_A=RW_R5 bus_B=R2 ]
        [ ALU=B-A CONST D=20  bus_A=R5 FLAG=CARRY ]
        [ ALU=A-B bus_A=RW_R4 bus_B=R4 GO_TRUE ADR=UNBPK_2 ]
        [ ALU=A+1 bus_A=R1                 RD_MEM_A ]
        [ bus_B=WR_R4                      RD_MEM_D ]
        % R3:=(a+offset DIV 32)^
        % if offset+size>32 then R4:=(a+offset DIV 32 +1)^ else R4:=0 end
:UNBPK_2
        [ CONST->R5 D=0 ] % mask:=0
        [ ALU=A bus_A=R2 FLAG=Z ]
:UNBPK_3
        [ ALU=A-1 bus_A=RW_R2 FLAG=Z GO_TRUE ADR=UNBPK_4 ]
        [ ALU=ROR(A) bus_A=RW_R3 ]
        [ ALU=ROR(A) bus_A=RW_R4 ]
        [ ALU=ROR(A+1) bus_A=RW_R5 FLAG=ZERO GO_FALSE ADR=UNBPK_3 ]
:UNBPK_4
        [ ALU=A_BIC_B bus_A=RW_R3 bus_B=R5 ]
        [ ALU=A_AND_B bus_A=RW_R5 bus_B=R4 ]
        [ ALU=A_OR_B  bus_A=RW_R3 bus_B=R5 ]
        [ CONST->R5 D=0 ]
:UNBPK_5
        [ ALU=A-1 bus_A=RW_Etop FLAG=Z ]
        [ ALU=A+B+1 bus_A=RW_R5 bus_B=R5 GO_FALSE ADR=UNBPK_5 ]

        [ ALU=A_AND_B bus_A=RW_R3  bus_B=R5 ]
        [ FLAG=ZERO ALU=A bus_A=R3 bus_B=WR_Etop FINISH ]

:BPK_1  [ ALU=A-1 bus_A=STACK->R6 ]  % R6:=size-1
        [ ALU=A_BIC_B bus_A=R6 CONST D=1F FLAG=Z  ]
        [ GO_FALSE ADR=TRAP4A ALU=A+1 bus_A=RW_R6 ]
        % if not size in {1..32} then trap(4Ah) end
        % R6:=size
        [ bus_A=STACK->R1 ]  % R1:=offset
        [ ALU=A_AND_B bus_A=R1 CONST->R2 D=1F ] % R2:=offset MOD 32

% R6 = size
% R2 = offset MOD 32
% R1 = offset
% Etop = data
:BPK_2
        [ CONST->R5 D=0 ] % mask:={}
:BPK_5
        [ ALU=A-1 bus_A=RW_R6 FLAG=Z ]
        [ ALU=A+B+1 bus_A=RW_R5 bus_B=R5 GO_FALSE ADR=BPK_5 ]

        [ ALU=A bus_A=R2 FLAG=Z ]
        [ GO_TRUE ADR=BPK_4 ALU=ASR(A) bus_A=RW_R1 ]
:BPK_3
        [ ALU=A+B      bus_A=RW_R5   bus_B=R5 FLAG=CARRY ]
        [ ALU=A+B+FLAG bus_A=RW_R6   bus_B=R6 ]
        [ ALU=A-1 bus_A=RW_R2 FLAG=Z ]
        [ ALU=ROL(A)   bus_A=RW_Etop GO_FALSE ADR=BPK_3 ]
:BPK_4
% R5,R6 = {offset..offset+size-1}
% Etop = ROL(data,offset);
        [ ALU=ASR(A) bus_A=RW_R1 ]
        [ ALU=ASR(A) bus_A=RW_R1 ]
        [ ALU=ASR(A) bus_A=RW_R1 ]
        [ ALU=ASR(A) bus_A=RW_R1 ]
        [ ALU=A+B bus_A=STACK->R1 bus_B=R1 RD_MEM_A ]
        [ bus_B=WR_R3                      RD_MEM_D ]
        [ ALU=A_BIC_B bus_A=RW_R3 bus_B=R5 ]
        [ ALU=A_AND_B bus_A=RW_R5 bus_B=Etop ]
        [ ALU=A_OR_B  bus_A=RW_R3 bus_B=R5 ]
        [ ALU=A bus_A=R6 FLAG=Z ]
        [ bus_B=R1 WR_MEM_A ]
        [ bus_B=R3 WR_MEM_D GO_TRUE ADR=BPK_7 ]
        [ ALU=A+1 bus_A=R1 RD_MEM_A ]
        [ bus_B=WR_R3      RD_MEM_D ]
        [ ALU=A_BIC_B bus_A=RW_R3 bus_B=R6 ]
        [ ALU=A_AND_B bus_A=RW_R6 bus_B=Etop ]
        [ ALU=A_OR_B  bus_A=RW_R3 bus_B=R6 ]
        [ ALU=A+1 bus_A=R1 WR_MEM_A ]
        [ bus_B=R3         WR_MEM_D ]
:BPK_7  [ bus_A=STACK->Etop FLAG=ZERO FINISH ]

:LID_1  [ UPDATE_CASH ]
        [ bus_B=WR_R2 INC_PC SHIFT_EN ]
        [ ALU=A_OR_B bus_A=RW_Etop bus_B=R2 FINISH ]
:LEA_1  [ bus_B=WR_R1 RD_MEM_D UPDATE_CASH ]
        [ bus_B=R1 RD_MEM_A ]
        [ bus_B=WR_Etop RD_MEM_D ]
        [ ALU=A+B bus_A=RW_Etop INC_PC ]
        [ FINISH ]
:JFLC_1 [ bus_A=STACK->Etop GO_FALSE ADR=SKIP2 ]
:JFL_1  [ bus_B=WR_R1 INC_PC ]
        [ UPDATE_CASH ]
        [ bus_B=WR_R2 INC_PC SHIFT_EN ]
        [ ALU=A_OR_B bus_A=RW_R1 bus_B=R2 ]
:JUMP % R1 - смещение
        [ ALU=A+B bus_A=RW_R1 RW_CASH_PC ]
:JUMP1  [ ALU=ASR(A) bus_A=RW_R1 ]
        [ ALU=ASR(A) bus_A=RW_R1 ]
        [ ALU=A+B bus_A=RW_R1 bus_B=RW_PC RD_MEM_A ]
        [ WR_CASH   RD_MEM_D ]
        [ FLAG=ZERO FINISH ]
:SKIP2  [ INC_PC ]
        [ UPDATE_CASH ]
        [ INC_PC ]
:SKIP   [ FLAG=ZERO FINISH ]
:JFSC_1 [ bus_A=STACK->Etop bus_B=WR_R1 INC_PC GO_TRUE ADR=JUMP ]
        [ FLAG=ZERO FINISH ]
:JBLC_1 [ bus_A=STACK->Etop GO_FALSE ADR=SKIP2 ]
:JBL_1  [ bus_B=WR_R1 INC_PC ]
        [ UPDATE_CASH ]
        [ bus_B=WR_R2 INC_PC SHIFT_EN ]
        [ ALU=A_OR_B bus_A=RW_R1 bus_B=R2 ]
        [ ALU=NEG(A) bus_A=RW_R1 GOTO ADR=JUMP ]

:JBSC_1 [ bus_A=STACK->Etop bus_B=WR_R1 INC_PC GO_FALSE ADR=SKIP ]
        [ ALU=B-A bus_A=RW_R1 RW_CASH_PC GOTO ADR=JUMP1 ]

:ROL(R2,8)
        [ bus_B=RW_R2 SHIFT_EN RETURN ]
:ROR(R2,8)
        [ bus_B=RW_R2 SHIFT_EN ]
        [ bus_B=RW_R2 SHIFT_EN ]
        [ bus_B=RW_R2 SHIFT_EN RETURN ]

:LEW_1  [ bus_B=WR_Etop RD_MEM_D ]
        [ bus_B=Etop    RD_MEM_A ]
        [ bus_B=WR_Etop RD_MEM_D UPDATE_CASH ]
        [ ALU=A+B bus_A=RW_Etop INC_PC RD_MEM_A ]
:LLW_1  [ bus_B=WR_Etop RD_MEM_D FINISH ]
:SEW_1  [ bus_B=WR_R1 RD_MEM_D ]
        [ bus_B=R1    RD_MEM_A ]
        [ bus_B=WR_R1 RD_MEM_D UPDATE_CASH ]
        [ ALU=A+B bus_A=R1 INC_PC WR_MEM_A ]
:SLW_1  [ bus_A=STACK->Etop bus_B=R2 WR_MEM_D FLAG=ZERO FINISH ]
:SLW_2  [ bus_A=STACK->Etop FLAG=ZERO FINISH ]
:LXB_1  [ ALU=ASR(A) bus_A=RW_Etop ]
        [ ALU=A+B bus_A=STACK->Etop bus_B=Etop RD_MEM_A ]
        [ bus_B=WR_R2 RD_MEM_D GO_TRUE ADR=LXB_2 ]
        [ ALU=B-A bus_A=RW_R1 CONST D=4 ]
:LXB_3  [ ALU=A-1 bus_A=RW_R1 FLAG=Z ]
        [ GO_FALSE ADR=LXB_3 bus_B=RW_R2 SHIFT_EN ]
:LXB_2  [ FLAG=ZERO ALU=A_AND_B bus_A=R2 CONST->Etop D=0FF FINISH ]
:SXB_1  [ ALU=A_AND_B bus_A=Etop CONST->R1 D=3 FLAG=Z ]
        [ CONST->R4 D=0FF ]
        [ ALU=ASR(A) bus_A=RW_Etop ]
        [ ALU=ASR(A) bus_A=RW_Etop ]
        [ ALU=A+B bus_A=STACK->Etop bus_B=Etop RD_MEM_A ]
        [ bus_B=WR_R5 RD_MEM_D GO_TRUE ADR=SXB_2 ]
:SXB_3  [ ALU=A-1 bus_A=RW_R1 FLAG=Z ]
        [ bus_B=RW_R4 SHIFT_EN ]
        [ bus_B=RW_R3 SHIFT_EN GO_FALSE ADR=SXB_3 ]
:SXB_2  [ ALU=A_BIC_B bus_A=RW_R5 bus_B=R4 ]
        [ ALU=A_OR_B  bus_A=RW_R5 bus_B=R3 ]
        [ bus_B=Etop WR_MEM_A ]
        [ bus_A=STACK->Etop bus_B=R5 WR_MEM_D FLAG=ZERO FINISH ]
:SXW_1  [ bus_B=Etop WR_MEM_D ]
        [ bus_A=STACK->Etop FINISH ]
:TRA_1  [ bus_A=STACK->Etop GOTO ADR=TRANSFER ]
:TR_1   [ CONST D=0 WR_MEM_D FINISH ]
:IDLE_1 [ CALL ADR=DEC_PC ]
        [ IDLE_ON bus_B=M ]
:IDLE_3 [ GO_IF_ANY_INT ADR=IDLE_2 ]
        [ GOTO ADR=IDLE_3 ]
:IDLE_2 [ IDLE_OFF bus_B=M ]
        [ FLAG=ZERO FINISH ]
:ROL_1  [ SHIFT=ROL_1 bus_B=RW_Etop ]
        [ FLAG=ZERO FINISH ]
:SHR_1  [ GO_TRUE ADR=SHR_2 ]
        [ ALU=A-B bus_A=R1 CONST D=20 FLAG=CARRY ]
        [ GO_FALSE ADR=SHR_3 ]
        [ CONST->R1 D=20 ]
:SHR_3  [ ALU=A-1    bus_A=RW_R1   FLAG=Z ]
        [ ALU=ASR(A) bus_A=RW_Etop GO_FALSE ADR=SHR_3 ]
:SHR_2  [ FLAG=ZERO FINISH ]

:SHL_1  [ GO_TRUE ADR=SHR_2 ALU=A bus_A=Etop FLAG=Z ]
        [ GO_TRUE ADR=SHR_2 FLAG=ZERO ]
:SHL_3  [ GO_TRUE ADR=SHL_4 ALU=A-1 bus_A=RW_R1 FLAG=Z ]
        [ ALU=ASL(A) bus_A=RW_Etop FLAG=OVR GO_FALSE ADR=SHL_3 ]
        [ FINISH ]
:SHL_5  [ GO_TRUE ADR=TRAP41 ALU=A-1 bus_A=RW_R1 FLAG=Z ]
:SHL_4  [ ALU=ASL(A) bus_A=RW_Etop FLAG=Z GO_FALSE ADR=SHL_5 ]
        [ GOTO ADR=TRAP41 ]

:STOFV_1
        [ CALL ADR=CHECK_H ALU=A bus_A=Etop bus_B=WR_R5 ]
        [ bus_A=STACK->Etop CALL ADR=SAVE_STK ]
        [ bus_B=S   WR_MEM_A ]
        [ bus_B=R5  WR_MEM_D ]
        [ ALU=A+1 bus_A=RW_S FLAG=ZERO FINISH ]

:STORE_1[ ALU=A+B bus_A=M bus_B=M FLAG=CARRY GO_FALSE ADR=STORE1 ]
        [ GO_TRUE ADR=TRAP40 ]
:STORE1 [ FLAG=ZERO FINISH ]

:LODFV_1
        [ CALL ADR=RESTORE_STK ]
        [ bus_A=Etop->STACK ]
        [ ALU=A bus_A=R4 bus_B=WR_Etop FLAG=ZERO FINISH ]
:DECS_1
        [ FLAG=ZERO bus_A=STACK->Etop FINISH ]
:BIT_1
        [ GO_TRUE ADR=TRAP4A ]
        [ FINISH ]
:IN_1   [ ALU=A bus_A=Etop bus_B=WR_R1 FLAG=Z CALL ADR=BIT_SF ]
        [ ALU=A_AND_B bus_A=Etop bus_B=R4 FLAG=Z ]
        [ ALU=B+NE_FLAG CONST->Etop D=0 FLAG=ZERO FINISH ]

:BIT_S  [ ALU=A bus_A=Etop bus_B=WR_R1 FLAG=Z ]
:BIT_SF [ CONST->Etop D=1 FLAG=ZERO RETURN_TRUE ]
        [ ALU=A-B bus_A=R1 CONST D=20 FLAG=CARRY ]
        [ bus_A=R1 ALU=A LOAD_CNT GO_TRUE ADR=BIT_S1 ]
:BIT_S2 [ bus_B=RW_Etop SHIFT=BIT_S2 ]
        [ RETURN FLAG=ZERO ]
:BIT_S1 [ CONST->Etop D=0 RETURN ]


:CL_2   [ UPDATE_CASH ] [ bus_B=WR_R5 INC_PC ] [ GOTO ADR=Call_Global ]
:CF_1   [ ALU=A-1 bus_A=RW_S RD_MEM_A ]
        [ bus_B=WR_R4 RD_MEM_D REG_EN ADR=Call_External ]
        [ ALU=A bus_A=R4 bus_B=WR_R2 CALL ADR=ROL(R2,8) ]
        [ CONST->R1 D=0FF SHIFT_EN ]
        [ bus_B=RW_R1 SHIFT_EN ]
        [ bus_B=RW_R1 SHIFT_EN ]
        [ ALU=A_BIC_B bus_A=RW_R4 bus_B=R1 ]
        [ ALU=A_AND_B bus_A=R2 CONST->R5 D=0FF GO_REG ]
:CI_1   [ UPDATE_CASH ] [ bus_B=WR_R5 INC_PC ] [ GOTO ADR=Call_Local ]
:CX_1   [ UPDATE_CASH ] [ bus_B=WR_R4 INC_PC ]
        [ UPDATE_CASH ] [ bus_B=WR_R5 INC_PC ]
        [ ALU=A-B-1 bus_A=G bus_B=R4 RD_MEM_A ]
        [ bus_B=WR_R4 RD_MEM_D GOTO ADR=Call_External ]

:LPC_1  [ ALU=A-B-1 bus_A=G INC_PC RD_MEM_A ]
        [ bus_B=WR_Etop RD_MEM_D UPDATE_CASH ]
        [ REG_EN ADR=ROR(R2,8) ]
        [ CONST->R2 D=0FF CALL_REG ]
        [ ALU=A_BIC_B bus_A=RW_Etop bus_B=R2 ]
        [ bus_B=WR_R2 INC_PC CALL_REG ]
        [ ALU=A_OR_B bus_A=RW_Etop bus_B=R2 FLAG=ZERO FINISH ]

:STOT_1 [ bus_A=STACK->Etop ]
        [ ALU=A+1 bus_A=RW_S ]
        [ ALU=A-B bus_A=S bus_B=H FLAG=CARRY ]
        [ ALU=A+B bus_A=M bus_B=M FLAG=CARRY GO_TRUE ADR=STOT_2 ]
:STOT_3 [ FLAG=ZERO FINISH ]
:STOT_2 [ GO_FALSE ADR=STOT_3 ]
        [ GOTO ADR=TRAP40S ]

:PCOP_1 % Etop - high, R1 - adr
        [ ALU=A+1 bus_A=RW_Etop UPDATE_CASH ]
        [ ALU=A+B bus_A=L INC_PC WR_MEM_A ]
        [ bus_B=S WR_MEM_D ]
        [ ALU=A bus_A=Etop FLAG=Z ]
        [ GO_TRUE ADR=PCOP_2 ]
        [ ALU=A-1 bus_A=RW_S ]
        [ ALU=A-1 bus_A=RW_R1 ]
:PCOP_3 [ ALU=A-1 bus_A=RW_Etop FLAG=Z ]
        [ ALU=A+1 bus_A=RW_R1 RD_MEM_A ]
        [ bus_B=WR_R2 RD_MEM_D ]
        [ ALU=A+1 bus_A=RW_S WR_MEM_A ]
        [ bus_B=R2    WR_MEM_D GO_FALSE ADR=PCOP_3 ]
        [ ALU=A+1 bus_A=RW_S ]
:PCOP_2 [ bus_A=STACK->Etop FLAG=ZERO FINISH ]

:CPCOP_1[ ALU=A+B bus_A=Etop CONST->R1 D=4 ]
        [ ALU=ROR(A_BIC_B) bus_A=RW_R1 CONST D=3 ]
        [ ALU=ROR(A) bus_A=RW_R1 bus_B=WR_R2 CALL ADR=CHECK_H ]
        [ ALU=A-1    bus_A=R1 bus_B=WR_Etop ]
        [ bus_A=STACK->R1 GOTO ADR=PCOP_1 ]

:DEC_1  [ bus_B=Etop  RD_MEM_A ]
        [ bus_B=WR_R3 RD_MEM_D ]
        [ ALU=A-B bus_A=RW_R3 bus_B=R2 FLAG=OVR ]
        [ bus_B=Etop  WR_MEM_A ]
        [ bus_B=R3    WR_MEM_D bus_A=STACK->Etop FINISH ]

:INC_1  [ bus_B=Etop  RD_MEM_A ]
        [ bus_B=WR_R3 RD_MEM_D ]
        [ ALU=A+B bus_A=RW_R3 bus_B=R2 FLAG=OVR ]
        [ bus_B=Etop  WR_MEM_A ]
        [ bus_B=R3    WR_MEM_D bus_A=STACK->Etop FINISH ]

:DEC1_1 [ ALU=A-1 bus_A=RW_R1 FLAG=OVR ]
        [ bus_B=Etop  WR_MEM_A ]
        [ bus_B=R1    WR_MEM_D bus_A=STACK->Etop FINISH ]

:INC1_1 [ ALU=A+1 bus_A=RW_R1 FLAG=OVR ]
        [ bus_B=Etop  WR_MEM_A ]
        [ bus_B=R1    WR_MEM_D bus_A=STACK->Etop FINISH ]

:BITL_S [ ALU=A bus_A=Etop bus_B=WR_R2 FLAG=Z ]
:BITL_SF[ CONST->Etop D=1 RETURN_TRUE ]
        [ bus_A=R2 ALU=A LOAD_CNT ]
:BITL_S2[ bus_B=RW_Etop SHIFT=BITL_S2 ]
        [ RETURN ]

:INCL_1 [ ALU=A_BIC_B bus_A=Etop CONST->R3 D=1F FLAG=Z ]
        [ ALU=A-B bus_A=RW_Etop bus_B=R3 GO_TRUE ADR=INCL2 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=A+B bus_A=RW_R1 bus_B=R3 ]
:INCL2  [ ALU=A bus_A=Etop bus_B=WR_R2 FLAG=Z CALL ADR=BITL_SF ]
        [ bus_B=R1    RD_MEM_A ]
        [ bus_B=WR_R2 RD_MEM_D ]
        [ ALU=A_OR_B  bus_A=RW_R2 bus_B=Etop ]
        [ bus_B=R1    WR_MEM_A ]
        [ bus_B=R2    WR_MEM_D bus_A=STACK->Etop FLAG=ZERO FINISH ]

:EXCL_1 [ ALU=A_BIC_B bus_A=Etop CONST->R3 D=1F FLAG=Z ]
        [ ALU=A-B bus_A=RW_Etop bus_B=R3 GO_TRUE ADR=EXCL2 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=A+B bus_A=RW_R1 bus_B=R3 ]
:EXCL2  [ ALU=A bus_A=Etop bus_B=WR_R2 FLAG=Z CALL ADR=BITL_SF ]
        [ bus_B=R1    RD_MEM_A ]
        [ bus_B=WR_R2 RD_MEM_D ]
        [ ALU=A_BIC_B  bus_A=RW_R2 bus_B=Etop ]
        [ bus_B=R1    WR_MEM_A ]
        [ bus_B=R2    WR_MEM_D bus_A=STACK->Etop FLAG=ZERO FINISH ]

:INL_1  [ bus_A=STACK->R1 ] % r1 - adr
        [ bus_A=STACK->R2 ] % r2 - bit, etop - size
        [ ALU=A+B bus_A=R2 bus_B=R2   FLAG=CARRY ]
        [ ALU=A-B bus_A=R2 bus_B=Etop FLAG=CARRY GO_TRUE ADR=INL_FALSE ]
        [ GO_TRUE ADR=INL_FALSE ]
        [ ALU=A_BIC_B bus_A=R2 CONST->R3 D=1F FLAG=Z ]
        [ ALU=A-B bus_A=RW_R2  bus_B=R3 GO_TRUE ADR=INL2 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=ASR(A) bus_A=RW_R3 ]
        [ ALU=A+B bus_A=RW_R1 bus_B=R3 ]
:INL2   [ ALU=A bus_A=R2 FLAG=Z CALL ADR=BITL_SF ]
        [ bus_B=R1    RD_MEM_A ]
        [ bus_B=WR_R2 RD_MEM_D ]
        [ ALU=A_AND_B bus_A=R2 bus_B=Etop FLAG=Z ]
        [ ALU=B+NE_FLAG CONST->Etop D=0 FLAG=ZERO FINISH ]
:INL_FALSE
        [ CONST->Etop D=0 FLAG=ZERO FINISH ]

:QUOT_1 [ UPDATE_CASH ]
        [ ALU=B bus_B=WR_R1 INC_PC FLAG=Z ]
        [ ALU=A-1 bus_A=RW_R1 FLAG=Z GO_FALSE ADR=QUOT_2 ]
        % shrq
        [ ALU=A bus_A=Etop bus_B=WR_R1 FLAG=Z ]
        [ bus_A=STACK->Etop ]
        [ GO_TRUE ADR=SHRQ_2 ]
        [ ALU=A-B bus_A=R1 CONST D=20 FLAG=CARRY ]
        [ ALU=A bus_A=Etop FLAG=N GO_TRUE ADR=SHRQ_4 ]
:SHRQ_3 [ ALU=A+NE_FLAG bus_A=RW_Etop ]
        [ ALU=A-1 bus_A=RW_R1 FLAG=Z ]
        [ ALU=ASR(A) bus_A=RW_Etop FLAG=N GO_FALSE ADR=SHRQ_3 ]
:SHRQ_2 [ FLAG=ZERO FINISH ]
:SHRQ_4 [ CONST->Etop D=0 FLAG=ZERO FINISH ]
:QUOT_2 [ ALU=A-1 bus_A=RW_R1 FLAG=Z GO_FALSE ADR=QUOT_3 ]
        % qout
        [ bus_A=STACK->R1 CALL ADR=IQUOT ]
        [ FINISH ]
:QUOT_3 [ ALU=A-1 bus_A=RW_R1 FLAG=Z GO_FALSE ADR=QUOT_4 ]
        % andq
        [ bus_A=STACK->R1 ALU=A FLAG=N ]
        [ ALU=NE(A) bus_A=Etop  bus_B=WR_R2 GO_TRUE ADR=ANDQ_1 ]
        [ ALU=A_AND_B bus_A=RW_Etop bus_B=R1 FLAG=Z ]
        [ GO_TRUE ADR=ANDQ_1 ]
        [ ALU=A_OR_B bus_A=RW_Etop bus_B=R2 FLAG=ZERO FINISH ]
:ANDQ_1 [ ALU=A_AND_B bus_A=RW_Etop bus_B=R1 FLAG=ZERO FINISH ]
:QUOT_4 [ GO_FALSE ADR=QUOT_5 ]
        % rem
        [ bus_A=STACK->R1 CALL ADR=IQUOT ]
        [ ALU=A bus_A=R1 bus_B=WR_Etop FINISH ]
:QUOT_5 [ CALL ADR=DEC_PC ]
        [ GOTO ADR=NII ]

:ORJP_1 [ FLAG=NEG(FLAG) ]
:ANDJP_1[ bus_B=WR_R1 INC_PC GO_FALSE ADR=ANDJP_2 ]
        [ ALU=A+B bus_A=RW_R1 RW_CASH_PC GOTO ADR=JUMP1 ]
:ANDJP_2[ bus_A=STACK->Etop FINISH ]

:ALLOC_1[ ALU=A bus_A=S bus_B=RW_Etop ]
        [ ALU=A+B bus_A=R2 bus_B=RW_S FLAG=ZERO FINISH ]

:ENTR_1 [ ALU=A-B bus_A=R1 bus_B=H FLAG=CARRY ]
        [ GO_TRUE ADR=ENTER_2 ALU=A+B bus_A=M bus_B=M FLAG=CARRY ]
:ENTER_3[ ALU=A bus_A=R1 bus_B=WR_S FLAG=ZERO FINISH ]
:ENTER_2[ GO_FALSE ADR=ENTER_3 ]
        [ CALL ADR=DEC_PC ]
        [ GOTO ADR=TRAP40 ]

:DEC_PC [ ALU=A+B bus_A=RW_PC bus_B=PC ]
        [ ALU=A+B bus_A=RW_PC bus_B=PC ]
        [ ALU=A-1 bus_A=RW_PC ]
        [ ALU=A+B bus_A=RW_PC RW_CASH_PC ]
        [ ALU=ROR(A_BIC_B) bus_A=RW_PC CONST D=3 ]
        [ ALU=ROR(A) bus_A=RW_PC RD_MEM_A ]
        [ WR_CASH RD_MEM_D RETURN ]

:CHECK_FOR
        % R6 - high, R4 - low, FLAG - step >= 0
        % Return TRUE in FLAG if may continue
        [ RETURN_TRUE  ALU=A-B bus_A=R6 bus_B=R4 FLAG=N_XOR_OVR LONG ]
        [ RETURN       ALU=A-B bus_A=R4 bus_B=R6 FLAG=N_XOR_OVR LONG ]


:FOR1_1 [ CALL ADR=CHECK_H ]
        [ UPDATE_CASH ]
        [ bus_B=WR_R3 INC_PC CALL ADR=NEXT2 ]
        [ ALU=A bus_A=R3 FLAG=Z ]           % R1 - offset in code
        [ bus_A=STACK->R4 ]
        [ bus_A=STACK->R5 ]
        % Etop - high, R4 - low, R5 - address, FLAG - step positiv
        [ ALU=A bus_A=Etop bus_B=WR_R6 CALL ADR=CHECK_FOR ]
        [ bus_B=R5 WR_MEM_A ]
        [ bus_B=R4 WR_MEM_D GO_FALSE ADR=ABORT_FOR1 ]
        [ bus_B=S  WR_MEM_A ]
        [ bus_B=R5 WR_MEM_D ]
        [ ALU=A+1 bus_A=RW_S WR_MEM_A ]
        [ bus_A=STACK->Etop bus_B=R6 WR_MEM_D ]
        [ ALU=A+1 bus_A=RW_S FLAG=ZERO FINISH ]

:ABORT_FOR1
        [ bus_A=STACK->Etop FLAG=ZERO GOTO ADR=JUMP ]


:FOR2_1 [ bus_B=WR_R6               RD_MEM_D ]
        [ ALU=A-B bus_A=S CONST D=2 RD_MEM_A ]
        [ bus_B=WR_R5               RD_MEM_D UPDATE_CASH ]
        [ bus_B=WR_R3 INC_PC ]
        [ ALU=A-B bus_A=R3 CONST D=80 FLAG=CARRY ]
        [ bus_B=R5    RD_MEM_A GO_FALSE ADR=FOR2_2 ]
        [ bus_B=WR_R4 RD_MEM_D ]
        [ ALU=NE(B) CONST->R1 D=0FF ]
        [ ALU=A_OR_B bus_A=RW_R3 bus_B=R1
          FLAG=CASH_FULL GO_IF_NOT_REQUEST ADR=FOR2_21 ]
        [ ALU=A+1 bus_A=RW_PC RD_MEM_A GOTO ADR=FOR2_24 ]
:FOR2_2 % R3 - step, R6 - high, R5 - address.
        [ bus_B=WR_R4 RD_MEM_D FLAG=CASH_FULL GO_IF_NOT_REQUEST ADR=FOR2_21 ]
        [ ALU=A+1 bus_A=RW_PC RD_MEM_A ]
:FOR2_24[ WR_CASH RD_MEM_D ]
        [ bus_B=WR_R1 INC_PC ]
:FOR2_22[ bus_B=WR_R2 INC_PC SHIFT_EN ]
        [ ALU=A_OR_B bus_A=RW_R1 bus_B=RW_R2 GOTO ADR=FOR2_23 ]

:FOR2_21[ bus_B=WR_R1 INC_PC ]
        [ FLAG=CASH_FULL GO_IF_NOT_REQUEST ADR=FOR2_22 ]
        [ ALU=A+1 bus_A=RW_PC RD_MEM_A ]
        [ WR_CASH RD_MEM_D GOTO ADR=FOR2_22 ]

:FOR2_23[ ALU=A-B bus_A=R4 bus_B=R6 FLAG=Z ]
        [ GO_TRUE ADR=FOR2_3 ALU=A+B bus_A=RW_R4 bus_B=R3 ]
        [ bus_B=R5   WR_MEM_A ]
        [ bus_B=R4   WR_MEM_D ]
        [ ALU=B-A bus_A=RW_R1 RW_CASH_PC GOTO ADR=JUMP1 ]

:FOR2_3 [ ALU=A-B bus_A=RW_S CONST D=2 ]
        [ FLAG=ZERO FINISH ]

:RTN_1  [ ALU=A bus_A=L bus_B=WR_S GO_TRUE ADR=RTN_2 ]
        [ ALU=ROR(B) CONST->R1 D=1 ]
        [ ALU=A_BIC_B bus_A=RW_PC bus_B=R1 ]
        [ bus_B=S         RD_MEM_A ]
        [ bus_B=WR_G      RD_MEM_D ]
        [ bus_B=G         RD_MEM_A ]
        [ bus_B=WR_F      RD_MEM_D ]
:RTN_2  [ ALU=A bus_A=PC RW_CASH_PC CALL ADR=PUT_PC1 ]
        [ ALU=A+1 bus_A=S RD_MEM_A ]
        [ bus_B=WR_L      RD_MEM_D FLAG=ZERO FINISH ]

:LSTA_1 [ ALU=A+1 bus_A=G RD_MEM_A ]
        [ bus_A=Etop->STACK bus_B=WR_Etop RD_MEM_D ]
        [ UPDATE_CASH ]
        [ bus_B=WR_R1 INC_PC ]
        [ UPDATE_CASH ]
        [ bus_B=WR_R2 INC_PC ]
        [ CALL ADR=ROL(R2,8) ]
        [ ALU=A+B bus_A=RW_R1 bus_B=R2 ]
        [ ALU=A+B bus_A=RW_Etop bus_B=R1 FLAG=ZERO FINISH ]

:MOVE_1 [ bus_A=STACK->R1 ]
        [ bus_A=STACK->R2 ]
        [ ALU=A bus_A=Etop FLAG=Z ]
        [ ALU=A-1 bus_A=RW_R1 GO_TRUE ADR=MOVE_2 FLAG=ZERO ]
        [ ALU=A-1 bus_A=RW_R2 ]

:MOVE_L [ ALU=A+1 bus_A=RW_R1 RD_MEM_A ]
        [ bus_B=WR_R3         RD_MEM_D GO_IF_ANY_INT ADR=MOVE_3 ]
        [ ALU=A-1 bus_A=RW_Etop FLAG=Z ]
        [ ALU=A+1 bus_A=RW_R2 WR_MEM_A ]
        [ bus_B=R3            WR_MEM_D  GO_FALSE ADR=MOVE_L FLAG=ZERO ]

:MOVE_2 [ bus_A=STACK->Etop FLAG=ZERO FINISH ]

:MOVE_3 [ ALU=A-1 bus_A=RW_Etop ]
        [ ALU=A+1 bus_A=RW_R2 WR_MEM_A ]
        [ bus_B=R3            WR_MEM_D CALL ADR=DEC_PC ]
        [ ALU=A+1 bus_A=RW_R1 ]
        [ ALU=A+1 bus_A=RW_R2 ]
        [ bus_A=R2->STACK ]
        [ bus_A=R1->STACK FLAG=ZERO FINISH ]


:XIT_1  [ bus_B=WR_PC RD_MEM_D CALL ADR=PUT_PC ]
        [ FLAG=ZERO FINISH ]

:ENTC_1 [ CALL ADR=CHECK_H ]
        [ CALL ADR=NEXT2 ]
        [ CALL ADR=GET_PC ]
        [ ALU=A+B bus_A=RW_PC bus_B=R1 CALL ADR=PUT_PC ]
        [ CALL ADR=NEXT2 ]
        [ ALU=A bus_A=R1 bus_B=WR_R3 CALL ADR=NEXT2 ]
        % R1 - high, R3 - low
        [ ALU=A bus_A=R1 bus_B=WR_R4 CALL ADR=GET_PC ]
        [ ALU=A-B bus_A=RW_R4 bus_B=R3 ] % R4 = high-low
        [ ALU=ASL(A) bus_A=RW_R4 ]
        [ ALU=A+B bus_A=RW_R4 CONST D=4 ]
        [ ALU=A+B bus_A=RW_R4 bus_B=PC ] % R4 = PC+(high-low)*2+4
        [ bus_B=S  WR_MEM_A ]
        [ bus_B=R4 WR_MEM_D ]
        [ ALU=A+1 bus_A=RW_S ] % Mem[S]:=PC+(high-low)*2+4; Inc(S)
        [ ALU=A+B bus_A=Etop bus_B=Etop FLAG=CARRY ]
        [ GO_TRUE ADR=ENTC_2
          ALU=A-B bus_A=Etop bus_B=R3 FLAG=CARRY ]
        [ GO_FALSE ADR=ENTC_2
          ALU=A-B bus_A=R1 bus_B=Etop FLAG=CARRY ]
        [ GO_FALSE ADR=ENTC_2 ]
        [ ALU=A-B bus_A=RW_Etop bus_B=R3 ]
        [ ALU=A+1 bus_A=RW_Etop ]
        [ ALU=ASL(A) bus_A=RW_Etop ]
        [ ALU=A+B bus_A=RW_PC bus_B=Etop ]
:ENTC_2 [ bus_A=STACK->Etop CALL ADR=PUT_PC ]
        [ FLAG=ZERO GOTO ADR=JBL ]

:NEXT_RIGHT
        [ ALU=A-1 bus_A=RW_R1 FLAG=N ]
        [ GO_TRUE ADR=NR1 ]
        [ CONST->R1 D=3 ]
        [ ALU=A+1 bus_A=RW_Etop RD_MEM_A ]
        [ bus_B=WR_R2 RD_MEM_D GOTO ADR=NR2 ]
:NR1    [ CALL ADR=ROR(R2,8) ]
:NR2    [ ALU=A_AND_B bus_A=R2 CONST->R3  D=0FF RETURN ]

:NEXT_LEFT
        [ ALU=A-1 bus_A=RW_R5 FLAG=N ]
        [ GO_TRUE ADR=NL1 ]
        [ CONST->R5 D=3 ]
        [ ALU=A+1 bus_A=RW_R4 RD_MEM_A ]
        [ bus_B=WR_R6 RD_MEM_D GOTO ADR=NL2 ]
:NL1    [ ALU=ROR(A) bus_A=RW_R6 ]
        [ ALU=ROR(A) bus_A=RW_R6 ]
        [ ALU=ROR(A) bus_A=RW_R6 ]
        [ ALU=ROR(A) bus_A=RW_R6 ]
        [ ALU=ROR(A) bus_A=RW_R6 ]
        [ ALU=ROR(A) bus_A=RW_R6 ]
        [ ALU=ROR(A) bus_A=RW_R6 ]
        [ ALU=ROR(A) bus_A=RW_R6 ]
:NL2    [ ALU=A_AND_B bus_A=R6 CONST->Time  D=0FF RETURN ]

:COMP_1 [ bus_A=STACK->R4 ]
        [ bus_A=Time->STACK ]
        [ ALU=B bus_A=WR_R1 CONST->R5 D=0 ]
        [ ALU=A-1 bus_A=RW_Etop ]
        [ ALU=A-1 bus_A=RW_R4 ]
:COMP_L [ CALL ADR=NEXT_RIGHT ]
        [ CALL ADR=NEXT_LEFT ]
        [ ALU=A   bus_A=R3 FLAG=Z ]
        [ GO_TRUE ADR=COMP_2
          ALU=A-B bus_A=R3 bus_B=Time FLAG=Z ]
        [ GO_TRUE ADR=COMP_L ]
:COMP_2
% Last bytes in Time,R3
        [ ALU=A bus_A=R3 bus_B=WR_Etop ]
        [ ALU=A bus_A=Time bus_B=WR_R1 ]
        [ bus_A=STACK->Time ]
        [ bus_A=R1->STACK FLAG=ZERO FINISH ]

:GB_1   [ ALU=B bus_A=WR_R2 INC_PC FLAG=Z ]
:GB_3   [ ALU=A-1 bus_A=RW_R2 FLAG=Z GO_TRUE ADR=GB_2 ]
        [ bus_B=Etop    RD_MEM_A ]
        [ bus_B=WR_Etop RD_MEM_D GOTO ADR=GB_3 ]
:GB_2   [ FLAG=ZERO FINISH ]

:ABS_1  [ GO_FALSE ADR=NOP ]
        [ ALU=NEG(A) bus_A=RW_Etop FLAG=OVR FINISH ]

:DOT_1  [ ALU=A bus_A=Etop bus_B=WR_R1 ]
        [ bus_A=STACK->Etop CONST->R2 D=8 ]
        [ CALL ADR=CRLF ]
        [ CALL ADR=PUT_NUM ]
        [ FLAG=ZERO FINISH ]

:INP_1  [ CALL ADR=GET_IO_ADR ]
        [ CONST->R2 D=0FF ]
        [ CONST->R3 D=0FF SHIFT_EN ]
        [ ALU=A_OR_B bus_A=RW_R2 bus_B=R3 ]
        [ bus_B=R1 RD_MEM_A ]
        [ bus_B=WR_Etop FLAG=ZERO RD_MEM_D ]
        [ ALU=A_AND_B bus_A=RW_Etop bus_B=R2 FINISH ]

:OUT_1  [ ALU=A bus_A=Etop bus_B=WR_R2 ]
        [ bus_A=STACK->Etop CALL ADR=GET_IO_ADR ]
        [ bus_A=STACK->Etop bus_B=R1 WR_MEM_A ]
        [ bus_B=R2 FLAG=ZERO WR_MEM_D FINISH ]

:PIO_1  [ ALU=B FLAG=Z bus_B=WR_R1 INC_PC ]
        [ ALU=A-1 bus_A=RW_R1 FLAG=Z GO_TRUE ADR=PIO_INP ]
        [ ALU=A-1 bus_A=RW_R1 FLAG=Z GO_TRUE ADR=PIO_OUT ]
        [ GOTO ADR=NII ]
:PIO_INP[ bus_B=Etop RD_MEM_A ]
        [ bus_B=WR_Etop RD_PIO_D FLAG=ZERO FINISH ]
:PIO_OUT[ bus_A=STACK->R1 ALU=A WR_MEM_A ]
        [ bus_B=Etop WR_PIO_D FLAG=ZERO GOTO ADR=DROP ]

:RESET_QBUS
        [ CONST->R1 D=20 SHIFT_EN ]
        [ bus_B=RW_R1 SHIFT_EN RD_MEM_A ]
        [ RD_MEM_D ]
        [ CONST->R2 D=100. ]
:RESET2 [ ALU=A-1 bus_A=RW_R2 FLAG=Z ]
        [ GO_FALSE ADR=RESET2 ]
        [ CONST D=0 RD_MEM_A ]
        [ RD_MEM_D FLAG=ZERO RETURN ]

:ROR(R3)
        [ bus_B=RW_R3 SHIFT_EN ]
        [ bus_B=RW_R3 SHIFT_EN ]
        [ bus_B=RW_R3 SHIFT_EN RETURN ]

:SYS_SWITCH
        [ ALU=A-B bus_A=R1 CONST D=0 FLAG=Z ]
        [ GO_TRUE ADR=SYS0 ]
        [ ALU=A-B bus_A=R1 CONST D=2 FLAG=Z ]
        [ GO_TRUE ADR=SYS2 ]
        [ ALU=A-B bus_A=R1 CONST D=1 FLAG=Z ]
        [ GO_TRUE ADR=DOT_1 ]
        [ CALL ADR=DEC_PC ]
        [ CONST->R1 D=7 ]
        [ GOTO ADR=TRAPED ]
:SYS0   [ bus_A=Etop->STACK ]
        [ CONST->Etop D=6 FLAG=ZERO FINISH ]
:SYS2   [ bus_A=Etop->STACK ]
        [ CONST->Etop D=9 FLAG=ZERO FINISH ]

:CM_1   [ ALU=A-1 bus_A=RW_S  bus_B=WR_R4 GOTO ADR=Call_External ]

:ADDPC_1[ ALU=ASL(A) bus_A=RW_R1 FLAG=CASH_FULL ]
        [ ALU=A+B bus_A=RW_R1 RW_CASH_PC ]
        [ ALU=A+FLAG bus_A=RW_PC RD_MEM_A ]
        [ WR_CASH  RD_MEM_D ]
        [ ALU=A+B bus_A=RW_Etop bus_B=R1 FLAG=ZERO FINISH ]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%         Word Arrays Compare            %%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               (* Andy 12-Sep-1989. (c) KRONOS *)
% Команда возвращает на стеке 2 адреса
% последних сравненных слов
% Длина словных сегментов должна быть >=0

:ARR_CMP_1
        [ ALU=A bus_A=Etop FLAG=N ]
        [ GO_FALSE ADR=ARR_CMP_ERR
          ALU=A bus_A=Etop FLAG=Z ]
        [ ALU=A-1 bus_A=RW_R1
          GO_TRUE ADR=ARR_EXIT0 ]
        [ ALU=A-1 bus_A=RW_R2 ]

:ARR_LOOP
        [ ALU=A+1 bus_A=RW_R1 RD_MEM_A ]
        [ bus_B=WR_R3         RD_MEM_D FLAG=ZERO ]
        [ ALU=A+1 bus_A=RW_R2 RD_MEM_A ]
        [ bus_B=WR_R4         RD_MEM_D
          GO_IF_ANY_INT ADR=ARR_CMP_ON_IPT ]
        [ ALU=A-B bus_A=R3 bus_B=R4 FLAG=Z ]
        [ GO_FALSE ADR=ARR_EXIT
          ALU=A-1 bus_A=RW_Etop FLAG=Z ]
        [ GO_FALSE ADR=ARR_LOOP ]
:ARR_EXIT
        [ bus_A=R2->STACK ]
        [ ALU=A bus_A=R1 bus_B=WR_Etop FLAG=ZERO FINISH ]
:ARR_CMP_ON_IPT
        [ ALU=A-B bus_A=R3 bus_B=R4 FLAG=Z ]
        [ GO_FALSE ADR=ARR_EXIT
          ALU=A-1 bus_A=RW_Etop FLAG=Z ]
        [ GO_TRUE  ADR=ARR_EXIT ]
        [ ALU=A+1 bus_A=RW_R1 ]
        [ ALU=A+1 bus_A=RW_R2 ]
        [ bus_A=R2->STACK CALL ADR=DEC_PC ]
        [ bus_A=R1->STACK FLAG=ZERO FINISH ]
:ARR_EXIT0
        [ ALU=A bus_A=R2 bus_B=WR_R1 GOTO ADR=ARR_EXIT ]
:ARR_CMP_ERR
        [ CONST->R1 D=4F ] [ GOTO ADR=TRAPED ]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%% End of Arrays Compare %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:BOX_CHK[ CONST->R2 D=0FF SHIFT_EN ]
        [ ALU=A_OR_B bus_A=RW_R2 CONST D=0FF ]
        [ ALU=A+B bus_A=Etop CONST D=0 RD_MEM_A ]
        [ bus_B=WR_R3 RD_MEM_D ]
        [ ALU=A+B bus_A=R1   CONST D=1 RD_MEM_A ]
        [ bus_B=WR_R4 RD_MEM_D ]
% Etop - box1
% R1   - box2
% R2   - mask
% R3   - A
% R4   - D
        [ ALU=A-B bus_A=R4 bus_B=R3 FLAG=CARRY ]
        [ GO_FALSE ADR=BOX0
          ALU=A_AND_B bus_A=RW_R3 bus_B=R2 ]
        [ ALU=A_AND_B bus_A=RW_R4 bus_B=R2 ]
        [ ALU=A-B bus_A=R4 bus_B=R3 FLAG=CARRY ]
        [ GO_FALSE ADR=BOX0 ]
        [ ALU=A+B bus_A=Etop CONST D=1 RD_MEM_A ]
        [ bus_B=WR_R3 RD_MEM_D ]
        [ ALU=A+B bus_A=R1   CONST D=0 RD_MEM_A ]
        [ bus_B=WR_R4 RD_MEM_D ]
% R3   - B
% R4   - C
        [ ALU=A-B bus_A=R3 bus_B=R4 FLAG=CARRY ]
        [ GO_FALSE ADR=BOX0
          ALU=A_AND_B bus_A=RW_R3 bus_B=R2 ]
        [ ALU=A_AND_B bus_A=RW_R4 bus_B=R2 ]
        [ ALU=A-B bus_A=R3 bus_B=R4 FLAG=CARRY ]
        [ GO_FALSE ADR=BOX0 ]
        [ CONST->Etop D=1 FLAG=ZERO FINISH ]
:BOX0   [ CONST->Etop D=0 FLAG=ZERO FINISH ]

:PDX_1  [ ALU=A+1 bus_A=R1 RD_MEM_A ]
        [ bus_A=R2->STACK bus_B=WR_R3 RD_MEM_D ]
        % Etop - index, R1 - descriptor, STACK,R2 - adr, R3 - high
        [ ALU=A+B bus_A=Etop bus_B=Etop FLAG=CARRY ]
        [ ALU=A-B bus_A=Etop bus_B=R3   FLAG=N_XOR_OVR+Z LONG
          GO_TRUE ADR=TRAP4A ]
        [ GO_FALSE ADR=TRAP4A FLAG=ZERO ]
        [ FINISH ]

%-----------------------------------------------------------------------
%-------------------------- WORD MOVE ----------------------------------
%-----------------------------------------------------------------------
%                                       (* Andy 10-Nov-88. (c) KRONOS *)
%                                       (* Andy 15-Dec-88. (c) KRONOS *)

:WM_1   % R1 - адрес источника
        % R2 - адрес приемника
        [ ALU=A bus_A=Etop FLAG=Z ]
        [ GO_TRUE ADR=WM_EXIT
          ALU=A-B bus_A=R1 bus_B=R2 FLAG=CARRY ]
        [ CONST->R4 D=1 ]
        [ GO_FALSE ADR=WM_right % R1<R2
          ALU=A-B bus_A=R1 bus_B=R2 FLAG=Z ]
:WM_left
        [ GO_TRUE ADR=WM_EXIT % R1=R2
          ALU=A-1 bus_A=RW_R1 ]
        [ ALU=A-1 bus_A=RW_R2 GOTO ADR=WM_loop FLAG=ZERO ]
:WM_right
        [ ALU=NEG(A) bus_A=RW_R4 ]
        [ ALU=A+B bus_A=RW_R1 bus_B=Etop ]
        [ ALU=A+B bus_A=RW_R2 bus_B=Etop FLAG=ZERO ]
:WM_loop
        [ ALU=A+B bus_A=RW_R1 bus_B=R4 RD_MEM_A ]
        [ bus_B=WR_R3 RD_MEM_D GO_IF_ANY_INT ADR=WM_int ]
        [ ALU=A-1 bus_A=RW_Etop FLAG=Z ]
        [ ALU=A+B bus_A=RW_R2 bus_B=R4 WR_MEM_A ]
        [ bus_B=R3 WR_MEM_D GO_FALSE ADR=WM_loop FLAG=ZERO ]
:WM_EXIT
        [ bus_A=STACK->Etop FLAG=ZERO FINISH ]
:WM_int [ ALU=A-1 bus_A=RW_Etop CALL ADR=DEC_PC ]
        [ ALU=A+B bus_A=RW_R2 bus_B=R4 WR_MEM_A ]
        [ bus_B=R3 WR_MEM_D ]
        [ ALU=A-B bus_A=R4 CONST D=1 FLAG=Z ]
        [ GO_TRUE ADR=WM_2 ]
        [ ALU=A-B bus_A=RW_R2 bus_B=Etop ]
        [ ALU=A-B bus_A=RW_R1 bus_B=Etop GOTO ADR=WM_fin ]
:WM_2   [ ALU=A+1 bus_A=RW_R2 ]
        [ ALU=A+1 bus_A=RW_R1 ]
:WM_fin [ bus_A=R2->STACK ]
        [ bus_A=R1->STACK FLAG=ZERO FINISH ]
%-----------------------------------------------------------------------
%----------------------- END OF WORD MOVE ------------------------------
%-----------------------------------------------------------------------

%-----------------------------------------------------------------------
%---------------------- BIT BLOCK TRANSFER -----------------------------
%-----------------------------------------------------------------------
%                                       (* Andy 11-Nov-88. (c) KRONOS *)
%                                       (* Andy 14-Nov-88. (c) KRONOS *)
%                                       (* Andy 14-Dec-88. (c) KRONOS *)
%                                       (* Andy 18-Dec-88. (c) KRONOS *)
%                                       (* Andy 12-Sep-89. (c) KRONOS *)
%                                       -- Исправлена ошибка в основном
%                                       -- цикле.
% Все сдвиги = 5 тактов
% Выбор направления                  26 тактов
% + обработка первого слова          85 тактов
%   пересылка слова в основном цикле 15 тактов
% + запись последнего слова и выход  35 тактов
% Обработка прерывания               36 тактов

:BM_start
        [ GO_FALSE ADR=BM_enter ]
        [ bus_A=STACK->Etop ]
        [ bus_A=STACK->Etop ]
        [ bus_A=STACK->Etop ]
        [ bus_A=STACK->Etop ]
        [ bus_A=STACK->Etop FLAG=ZERO FINISH ]

:BM_enter % Etop#0
        [ CALL ADR=get_pair ]           % R5 - координата источника.
        [ ALU=A bus_A=R5 bus_B=WR_R4    % R4 - координата источника.
          CALL ADR=get_pair ]           % R5 - координата приемника.
% Спасаем регистры
        [ bus_A=M->STACK ]
        [ bus_A=P->STACK ]
        [ bus_A=L->STACK ]
        [ bus_A=G->STACK ]
        [ bus_A=Time->STACK ]
        [ bus_A=H->STACK ]
        [ bus_A=PC->STACK CONST->H D=1 ]        % H:= 1
% Выбираем направление
        [ ALU=A-B bus_A=R5 bus_B=R4 FLAG=CARRY ]
        [ GO_FALSE ADR=BMOVE_LEFT
          ALU=A-B bus_A=R5 bus_B=R4 FLAG=Z ]
        [ GO_FALSE ADR=BMOVE_RIGHT ]    % else R4=R5 - dummy move
:BM_EXIT
        [ CALL ADR=BM_rest_regs ]
        [ bus_A=STACK->Etop FLAG=ZERO FINISH ]

% На выбор направления - 26 тактов
:BMOVE_LEFT
% H=1
% Etop - размер в битах
        [ CALL ADR=BM_unpack ]
        [ ALU=B-A bus_A=G CONST->R5 D=020 ] % R5:= емкость приемника
        [ ALU=A-B bus_A=R5 bus_B=Etop FLAG=CARRY ]
        [ GO_FALSE ADR=BM_1 ] % R5<Etop <==> слово не последнее
        [ ALU=A bus_A=Etop bus_B=WR_R5 ]
% R5 - число битов, которое нужно переписать в R3
:BM_1   [ ALU=A bus_A=R5 bus_B=WR_R6 CALL ADR=BM_mkmask ]
        % маска для R3 ->Time
        [ ALU=A bus_A=G LOAD_CNT ]
:BM_mv1 [ bus_B=RW_Time SHIFT=BM_mv1 ] % Time:= Time << G
        [ ALU=A bus_A=Time bus_B=WR_PC ] % маска для R3 ->PC
        [ ALU=A bus_A=L bus_B=WR_R6 CALL ADR=BM_mkmask ]
        % маска для R2 ->Time
        [ ALU=A bus_A=Time bus_B=WR_R4 CALL ADR=BM_first ]
        [ ALU=A-B bus_A=RW_Etop bus_B=R5 FLAG=Z REG_EN ADR=BM_2 ]
        [ GO_TRUE ADR=BM_EXIT
% R5= число битов, записанных в R3.
% Модифицируем ввод и готовим маски для основного цикла.
          ALU=A+B bus_A=RW_L bus_B=R5 ]
        [ ALU=A-B bus_A=L CONST D=020 FLAG=CARRY ]
        [ ALU=A_AND_B bus_A=RW_L CONST D=01F FLAG=Z % L=0 <==> попали на
                                                    % границу слова.
% L - битовое смещение в очередном слове-источнике.
% FLAG=TRUE, если R1 прочитано полностью.
          GO_REG_FALSE ]
        [ ALU=A bus_A=R2 bus_B=WR_R1
          GO_TRUE ADR=BM_WM ] % Оптимизация словной пересылкой.
        [ ALU=A+B bus_A=RW_M bus_B=H RD_MEM_A ]
        [ bus_B=WR_R2                RD_MEM_D ]
% (R1,L)+(R2=M^) - буфер ввода. Последнее слово записано по адресу P.
:BM_2   [ ALU=A bus_A=L bus_B=WR_R6 CALL ADR=BM_mkmask ]
        [ ALU=NE(A) bus_A=Time bus_B=WR_PC GOTO ADR=BM_loop ]
% На выход к основному циклу 83 такта

:BMOVE_RIGHT
% Etop - размер в битах
        [ ALU=A-1 bus_A=Etop bus_B=WR_R6 ]
        [ ALU=A+B bus_A=RW_R4 bus_B=R6 ]
        [ ALU=A+B bus_A=RW_R5 bus_B=R6 ]
        [ ALU=NEG(A) bus_A=RW_H   % H:= -1;
          CALL ADR=BM_unpack ]
        [ ALU=A+1 bus_A=RW_G bus_B=WR_R5 ] % R5:= емкость приемника
        [ ALU=A-B bus_A=R5 bus_B=Etop FLAG=CARRY ]
        [ GO_FALSE ADR=BM_3 ] % R5<Etop <==> слово не последнее
        [ ALU=A bus_A=Etop bus_B=WR_R5 ]
% R5 - число битов, которое нужно переписать в R3
:BM_3   [ ALU=A bus_A=R5 bus_B=WR_R6 CALL ADR=BM_mkmask ]
        [ ALU=A bus_A=G  bus_B=WR_R6 ]
        [ ALU=A-B bus_A=RW_R6 bus_B=R5 ]
        [ ALU=A   bus_A=R6 LOAD_CNT ]
:BM_mv3 [ bus_B=RW_Time SHIFT=BM_mv3 ] % Time:= Time << (G-R5)
        [ ALU=A bus_A=Time bus_B=WR_PC ] % маска для R3 ->PC
        [ ALU=A+1 bus_A=RW_L bus_B=WR_R6 CALL ADR=BM_mkmask ] % L:= L+1
        % маска для R1 ->Time
        [ ALU=NE(A) bus_A=RW_Time bus_B=WR_R4 CALL ADR=BM_first ]
% ---------------------------------------------------------------
        [ ALU=A-B bus_A=RW_Etop bus_B=R5 FLAG=Z ]
        [ GO_TRUE ADR=BM_EXIT
% R5= число битов, записанных в R3.
% Модифицируем ввод и готовим маски для основного цикла.
% L= емкость R1
          ALU=A-B bus_A=RW_L bus_B=R5 FLAG=CARRY ] % L:= L-R5
        [ ALU=A bus_A=L FLAG=Z
          GO_TRUE ADR=BM_4 ] % L >= 0
% L < 0 <==> прочитали R1 и часть R2
        [ ALU=A+B bus_A=RW_L CONST D=020 ]
        [ ALU=A bus_A=R2 bus_B=WR_R1 ]
        [ ALU=A+B bus_A=RW_M bus_B=H RD_MEM_A ]
        [ bus_B=WR_R2                RD_MEM_D GOTO ADR=BM_5 ]
:BM_4   [ GO_TRUE ADR=BM_WM ] % Оптимизация словной пересылкой.
:BM_5 % Подготовка масок.
        [ ALU=A bus_A=L bus_B=WR_R6 CALL ADR=BM_mkmask ]
        [ ALU=A bus_A=Time bus_B=WR_PC ]
        [ ALU=NE(A) bus_A=RW_Time ]
% На выход к основному циклу 88 тактов

:BM_loop
% G - сдвиг для рез-та
        [ ALU=A bus_A=Time bus_B=WR_R4 ]
% R4= маска для R2= Time
% Основной цикл 15 тактов
:BM_main
        [ ALU=A_AND_B bus_A=RW_R1 bus_B=PC ]
        [ ALU=A_AND_B bus_A=R2->STACK bus_B=RW_R4 ]
        [ ALU=A_OR_B  bus_A=RW_R1 bus_B=R4 ]
        [ ALU=A bus_A=G LOAD_CNT ]
:BM_mv4 [ bus_B=RW_R1 SHIFT=BM_mv4 ]
        [ ALU=A-B bus_A=RW_Etop CONST D=20 FLAG=CARRY ]
        [ ALU=A bus_A=Time bus_B=WR_R4  % R4:= Time
          GO_FALSE ADR=BM_end_0 FLAG=ZERO ]
        [ ALU=A+B bus_A=RW_P bus_B=H WR_MEM_A ]
        [                   bus_B=R1 WR_MEM_D
          GO_IF_ANY_INT ADR=BM_int_0 ]
        [ ALU=A+B bus_A=RW_M bus_B=H RD_MEM_A ]
        [ bus_A=STACK->R1 % R1:= old(R2)
          bus_B=WR_R2 RD_MEM_D FLAG=ZERO GOTO ADR=BM_main ]

:BM_end_0
% На выход 35 тактов
        [ ALU=A+B bus_A=Etop CONST D=020 FLAG=Z ]
        [ bus_A=STACK->R6   GO_TRUE ADR=BM_EXIT ]

:BM_end % Пишем последнее неполное слово
% Etop= остаток в битах - 32
% R1 - готовое слово ввода
        [ ALU=A+B bus_A=RW_P bus_B=H RD_MEM_A ]
        [ bus_B=WR_R3 RD_MEM_D REG_EN ADR=BM_mkmask ]
        [ ALU=A+B bus_A=Etop CONST->R6 D=020 CALL_REG ]
% В Time - маска на Etop битов для R3.
        [ ALU=A-B bus_A=H CONST D=1 FLAG=Z ]
        [ ALU=NEG(A) bus_A=RW_Etop LOAD_CNT % Etop:= -(ост.-32)=32-ост.
          GO_TRUE ADR=BM_6 ]
:BM_mv5 [ bus_B=RW_Time SHIFT=BM_mv5 ]
:BM_6   [ ALU=A_AND_B bus_A=RW_R1 bus_B=Time ]
        [ ALU=A_BIC_B bus_A=RW_R3 bus_B=Time ]
        [ ALU=A_OR_B  bus_A=RW_R3 bus_B=R1 ]
        [ ALU=A bus_A=P WR_MEM_A ]
        [ bus_B=R3 WR_MEM_D GOTO ADR=BM_EXIT ]
%-----------------------------------------------------------------------
:BM_int_0
        [ bus_A=STACK->R6 ]
:BM_int
% R2= destination bit address
% R4= source bit address
% влево:  R2= (P+h)*32
%         R4=  M*32+L
% вправо: R2= (P+h)*32+32-Etop
%         R4=  M*32+L-Etop
        [ ALU=A+B bus_A=RW_P bus_B=H ]
        [ ALU=A bus_A=P bus_B=WR_R6 CALL ADR=mult32 ]
        [ ALU=A bus_A=R6 bus_B=WR_R2 ] % R2:= (P+h)*32
        [ ALU=A bus_A=M bus_B=WR_R6 CALL ADR=mult32 ]
        [ ALU=A bus_A=R6 bus_B=WR_R4 ] % R4:=  M*32
        [ ALU=A bus_A=H FLAG=N ]
        [ ALU=A+B bus_A=RW_R4 bus_B=L GO_TRUE ADR=BM_8 ]
% Вправо
        [ ALU=A+B bus_A=RW_R2 CONST D=020 ]
        [ ALU=A-B bus_A=RW_R2 bus_B=Etop ]
        [ ALU=A-B bus_A=RW_R4 bus_B=Etop ]
:BM_8   [ ALU=A_XOR_B bus_A=RW_R6 bus_B=R6 CALL ADR=BM_rest_regs ]
:BM_fin3
        [ bus_A=R6->STACK CALL ADR=DEC_PC ]
        [ bus_A=R2->STACK ]
        [ bus_A=R6->STACK ]
        [ bus_A=R4->STACK FLAG=ZERO FINISH ]

:BM_wint
% Etop>0 - остаток в битах;
% последнее слово прочитано по адресу M и записано по адресу P.
% R2= destination bit address
% R4= source bit address
% влево:  R2= (P+h)*32
%         R4= (M+h)*32
% вправо: R2= (P+h)*32+32-Etop
%         R4= (M+h)*32+32-Etop
        [ ALU=A+B bus_A=RW_P bus_B=H ]
        [ ALU=A bus_A=P bus_B=WR_R6 CALL ADR=mult32 ]
        [ ALU=A bus_A=R6 bus_B=WR_R2 ] % R2:= (P+h)*32
        [ ALU=A bus_A=H FLAG=N ]
        [ ALU=A+B bus_A=RW_M bus_B=H ]
        [ ALU=A bus_A=M bus_B=WR_R6 CALL ADR=mult32 ]
        [ ALU=A bus_A=R6 bus_B=WR_R4   % R4:= (M+h)*32
          GO_TRUE ADR=BM_8 ]
% Вправо
        [ ALU=B-A bus_A=Etop CONST->R5 D=020 ]
        [ ALU=A+B bus_A=RW_R2 bus_B=R5 ]
        [ ALU=A+B bus_A=RW_R4 bus_B=R5 GOTO ADR=BM_8 ]

:BM_WM
% Словная пересылка: прочитано слово R2= M^;
% последнее слово записано по адресу P;
% Etop - длина пересылки в битах.
        [ CONST->R6 D=020 ] % R6:= 32
:BM_wmain
        [ ALU=B-A bus_A=Etop CONST D=020 FLAG=CARRY ]
        [ ALU=A-B bus_A=RW_Etop bus_B=R6 GO_TRUE ADR=BM_w1 FLAG=Z ]
        [ ALU=A+B bus_A=RW_P bus_B=H WR_MEM_A FLAG=ZERO ]
        [ bus_B=R2 WR_MEM_D GO_IF_ANY_INT ADR=BM_wint ]
        [ ALU=A+B bus_A=RW_M bus_B=H RD_MEM_A ]
        [ bus_B=WR_R2 RD_MEM_D GOTO ADR=BM_wmain ]
:BM_w1 % Etop+32 <= 32
% FLAG= (Etop=0)
        [ ALU=A bus_A=R2 bus_B=WR_R1 GO_FALSE ADR=BM_end ]
        [ ALU=A+B bus_A=RW_P bus_B=H WR_MEM_A ]
        [ bus_B=R2 WR_MEM_D GOTO ADR=BM_EXIT ]

%-----------------------------------------------------------------------
%------------------------- Подпрограммы --------------------------------
:BM_mkmask % R6= (0..32)
% 9 тактов
        [ ALU=A bus_A=R6 LOAD_CNT REG_EN ADR=BM_mk1 ]
        [ ALU=A-B bus_A=R6 CONST D=020 FLAG=Z ]
        [ CONST->Time D=1 GO_REG_TRUE ]
:BM_mk2 [ bus_B=RW_Time SHIFT=BM_mk2 ]
        [ ALU=A-1 bus_A=RW_Time FLAG=ZERO RETURN ]
:BM_mk1 [ ALU=NEG(A) bus_A=RW_Time FLAG=ZERO RETURN ]

:BM_first
% Формирование и запись первого слова
% PC - mask for R3, Time - mask for R2
% R4=Time
% G:= сдвиг для результата
% Destroyed: R4, R6.
% 15 тактов
        [ ALU=A-B bus_A=RW_G bus_B=L LOAD_CNT ] % G:= G-L сдвиг для рез-та
        [ ALU=A_AND_B bus_A=RW_R4 bus_B=R2 ]
        [ ALU=NE(A) bus_A=Time bus_B=WR_R6 ] % R6= маска для R1
        [ ALU=A_AND_B bus_A=RW_R6 bus_B=R1 ]
        [ ALU=A_OR_B bus_A=RW_R4 bus_B=R6 ]
:BM_mv2 [ bus_B=RW_R4 SHIFT=BM_mv2 ]
        [ ALU=A_BIC_B bus_A=RW_R3 bus_B=PC ]
        [ ALU=A_AND_B bus_A=RW_R4 bus_B=PC ]
        [ ALU=A_OR_B  bus_A=RW_R3 bus_B=R4 ] % Сформировали R3
        [ bus_B=P  WR_MEM_A ]
        [ bus_B=R3 WR_MEM_D RETURN ]

:BM_unpack
% Инициализация чтения битов, R4 - абс. номер бита
% 16 тактов
        [ ALU=A_AND_B bus_A=R4 CONST->L D=1F ]  % L=номер бита
        [ ALU=ASR(A) bus_A=R4 bus_B=WR_M ]
        [ ALU=ASR(A) bus_A=RW_M ]
        [ ALU=ASR(A) bus_A=RW_M ]
        [ ALU=ASR(A) bus_A=RW_M ]
        [ ALU=ASR(A) bus_A=RW_M RD_MEM_A ]      % M - словный адрес
        [ bus_B=WR_R1           RD_MEM_D ]
        [ ALU=A+B bus_A=RW_M bus_B=H RD_MEM_A ]
        [ bus_B=WR_R2                RD_MEM_D ]
% Инициализация записи битов
        [ ALU=A_AND_B bus_A=R5 CONST->G D=1F ]  % G=номер бита
        [ ALU=ASR(A) bus_A=R5 bus_B=WR_P ]
        [ ALU=ASR(A) bus_A=RW_P ]
        [ ALU=ASR(A) bus_A=RW_P ]
        [ ALU=ASR(A) bus_A=RW_P ]
        [ ALU=ASR(A) bus_A=RW_P RD_MEM_A ]      % P - словный адрес
        [ bus_B=WR_R3           RD_MEM_D RETURN ]

:get_pair
% Со стека снимается пара: (словный адрес + битовое смещение);
% конечный номер бита пишется в R5,
% R6 портится.
% 6 тактов
        [ bus_A=STACK->R5 ]
        [ bus_A=STACK->R6 CALL ADR=mult32 ]
        [ ALU=A+B bus_A=RW_R5 bus_B=R6 RETURN ]

:mult32 % R6:= R6*32
% 3 такта
        [ ALU=ASL(A) bus_A=RW_R6 ]              % := * 2
        [ ALU=ASL(A+B) bus_A=RW_R6 bus_B=R6 ]   % := * 8
        [ ALU=ASL(A+B) bus_A=RW_R6 bus_B=R6     % := *32
          RETURN ]

:BM_rest_regs
% 7 тактов
        [ bus_A=STACK->PC ]
        [ bus_A=STACK->H ]
        [ bus_A=STACK->Time ]
        [ bus_A=STACK->G ]
        [ bus_A=STACK->L ]
        [ bus_A=STACK->P ]
        [ bus_A=STACK->M RETURN ]
%-----------------------------------------------------------------------
%------------------ END OF BIT BLOCK TRANSFER --------------------------
%-----------------------------------------------------------------------
