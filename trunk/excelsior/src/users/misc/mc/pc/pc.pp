                 О переносимости компиляторов

0. Задача: 1 -> N или 1+e -> N

1. Выбор разбиения
        - промежуточный язык;
        - структура данных;
                целиком модуль из-за сложности генерации;

   Деление работы:
        - вычисление констант;
        - структурные константы;
        - контроль типов;
        - представление данных;


   Уровень трансформаций:
        структуры управление:
                переходы или как есть;
        обобщенные структуры;

2. промежуточный язык
3. front-end
4. back-end
---------------------------------------------------------------
     Авторы  приносят свои извинения за не очень умные шуточки
(и  просто-просто-просто-просто-просто  сосиски)  в скобочках,
встречающиеся  в  тексте,  но  честное  слово - это не мы, это
какой-то локальный полтергейст, живущий в нашей машине. Ну вот
опять!
---------------------------------------------------------------

     В   глубину   веков   уходит   своими   корнями  проблема
переносимости  компиляторов.  Вспомним  проект  Бета (и снимем
шляпу:  "Вееечная  память").  Не  будем идеалистами и поставим
светлую  мечту "фабрики компиляторов" на полку рядом с другими
светлыми мечтами.
     Постараемся  разобраться в проблеме компиляция 1->N, т.е.
один  язык  ->  много машин. В качестве некоторого реверанса в
сторону  светлой  мечты  мы  будем иногда думать о возможности
компиляции  нескольких  близких  (но  очень близких (ну просто
очень близких (...)) языков.

     Определим главное требование к переносимому компилятору:

1. "Хорошесть"

     Не    очевидным    является   факт,   что   "хороший"   в
общеупотребительном  (скорость,  качество  кода,  ...)  смысле
компилятор  будет  более  переносим,  чем  плохой. Скорее даже
наоборот.  Конечно,  можно  сравнивать  компиляторы по степени
переносимости,   но   такое   определение,   к  сожалению,  не
конструктивно.

2. Разделение машинно-зависимые частей от машинно-независимых.

     Такое   требование  является  более  конструктивным.  При
анализе  нескольких  компиляторов  можно  построить  частичный
порядок  по  степени  переносимости,  а  при  разработке  есть
опорная точка.

     Разделение   компилятора   можно   обеспечить  выделением
машинно-зависимых процедур и данных или разбиением компилятора
на  две  неравные  половины. Первый способ используется в PCC.
Для  его  переноса  на  общий  скелет  генерации  навешивается
конкретные  трансдукторы.  Такой подход выглядит более гибким,
так  как  при  переносе можно подстраивать весь компилятор под
новую   архитектуру,   но   это  влечет  потерю  надежности  и
необходимость  отладки  целиком компилятора при настройке его.
Разбиение транслятора на front-end и back-end избавляет нас от
необходимости  думать о первой половине компилятора, но в тоже
време  такое  разбиение  не  мешает  нам иметь "скелет" (общую
часть) генерацию для различных архитектур.
     Как  правило  компилятор  разбивается не на две, а на три
неравные  половины.  Выделяется некоторая общая часть, которая
используется как парсером, так и генератором.

     При  разбиении  компилятора  основным  вопросом  является
взаимодействие частей. Способы взаимодействия:

        - процедурный интерфейс;
        - промежуточный язык;
        - промежуточная структура данных.

     Процедурный  интерфейс  используется  в  компиляторе  mx.
Интерфейс модуля генерации содержит процедуры, соответствующие
конструкциям   языка.   Конкретный   кодогенератор  может  или
непосредственно порождать объектный код, или строить некоторую
структуру    данных   удобную   для   последующей   генерации.
Кодогенератор  для  Кроноса  порождает  код  для  выражений  и
простых  операторов  (вызов,  присваивание) непосредственно, а
для   составных  операторов  строит  граф  переходов,  который
оптимизируются и компилируется в код в конце процедуры. Модуль
генерации  имеет доступ к таблице объектов и можно сказать что
весь парсер является общей частью компилятора.
     Промежуточный   язык   является   традиционным  средством
деления  компиляторов  (к  сожалению  компиляторы  делением не
размножаются).   Очевидное   достоинство   -  это  возможность
полностью  отделить генерацию от разбора; очевидный недостоток
- необходимость иметь свои таблицы символов и свой мини-парсер
(а  может  и макси). Вообще говоря, этот подход почти ничем не
отличается   от   предыдущего,   разве   что  писать  на  диск
последовательность процедурных вызовов не очень удобно.
     Рассмотрим  теперь  вариант  с  промежуточной  структурой
данных.  Парсер  порождает  дерево разбора в памяти и передает
его целиком генератору, который строит код, обходя это дерево.
Никаких  очевидных  достоинств  этот  метод  не  имеет,  за то
очевидные недостатки можно перечислять долго. Вот некоторые из
них:

1) Компилятору требуется большой объем памяти.

2)  Какую  бы  структуру  дерева  разбора мы не придумали, она
(структура)   будет  не  нужна  для  парсера  и  неудобна  для
генератора (ввиду ее независимости от целевой машины).

3)  Невозможно придумать структуру, удобную для генерации кода
на разные машины.

     Рассмотрим  хотя бы один пример - информацию о размещении
переменной.  Сколько  полей и какого типа должно быть в записи
для  переменной для хранения этой информации для любой неперед
неизвестной  машины?  С  первого взгляда может показаться, что
расширение  типа [] решает эту проблему. Парсер породит запись
для  переменной,  в  которой не будет информации о размещении.
Генератор  расширит  эту  запись, добавив поля необходимые для
данной машины:

TYPE                           TYPE
  front_var  = RECORD            back_var = RECORD (front_var)
                 ident:                       level :
                 type :                       offset:
                 .....                        .....
               END;                         END;

Но   теперь,  при  замене  экземпляра  записи  на  расширенный
необходима  глобальная  модификация дерева, так как существуют
ссылки на запись, описывающую переменныю.

     Другой  выход  из  положения - это добавить в запись поле
типа  адрес.  Генератор запишет в это поле указатель на запись
описывающую размещение для данной машины.

TYPE                           TYPE
  front_var  = RECORD            displacement = RECORD
                 ident:                           level :
                 type :                           offset:
                 .....                            .....
                 disp : ADDRESS;                END;
               END;

Увы, поле типа адрес приводит к потере контроля типов и потере
комфорта программиста. Вот здесь как раз расширение типа может
вернуть   комфорт  за  счет  динамического  контоля  типов.  К
сожалению Оберон у нас еще никто не написал (халявы, сэр).

     Вернемся  к  проблеме  выбора способа взаимодействия. Все
последующее  (!)  обсуждение  приводит  нас  к  тому, что надо
выбирать промежуточную стуктуру данных.

     Во-первых,  мы  собираемся  порождать  код в основном для
RISC-процессоров.  Генерация  хорошего  кода  для  них требует
сбора  полной  информации  о  единице  компиляции. И только на
основании этой информации можно перестроить дерево оптимальным
образом  для  данной  целевой  машины.  Во-вторых,  два других
способа  взаимодействия  просто  ставят  дополнительный барьер
между  парсером  и генератором, который приходиться мучительно
преодолевать  в генераторе. В-третьих, парсеру ничего не стоит
породить   дерево   разбора.   И  в-четвертых,  смешно  писать
компилятор на машину у которой нет 16MB оперативной памяти.
     Что же касается очевидного недостатка номер 3 (см. выше),
то  должны же быть у программистов хоть какие-то проблемы, для
того, чтобы с блеском решать их.

     После  выбора  способа  взаимодействия  остается обсудить
следующие мелкие проблемы:

        - разделение работы между парсером и генератором;
        - структура дерева разбора;
        - организация процесса компиляции.
