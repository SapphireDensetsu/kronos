1. Структура компилятора

Компилятор  состоит  из  ядра,  парсеров  для  языков  Модула-2 и
Оберон,  и  набора  генераторов  для  целевых  машин.  Компилятор
построен  по  стандартной  схеме  [1]:  первая  часть компилятора
(front-end)  строит  таблицу  объектов  и  синтаксическое  дерево
модуля,   выполняя   контроль   семантики  модуля;  вторая  часть
компилятора (back-end) реализует генератор для конкретной машины.
Генератор  реализует  две  основные  функции: размещение объектов
модуля  и  собственно  генерация  кода.  Схема  компиляции модуля
выглядит следующим образом:

        парсер;
        размещение объектов модуля;
        IF определяющий модуль OR оберон-модуль THEN
          запись симфайла
        END;
        IF  реализующий или программный модули OR оберон-модуль THEN
          генерация кода
        END

При  обнаружении  ошибок  компиляция следующая фаза компиляции не
выполняется.

С  точки  зрения импорта структура компилятора выглядит следующим
образом:

                головная часть
                /     |      \
          парсер      |       генератор
                \     |      /
               ядро компилятора

Не допускается импорт парсера из генератора и наоборот.

2. Ядро компилятора

Ядро  компилятора состоит из модулей, реализующих интерфейс с ОС,
сканер   и   таблицу  объектов,  включая  операции  чтения/записи
симфайлов. В ядро входят следующие модули:
    pcМ    - интерфейс с ОС;
    pcK    - определения объектов и синтаксического дерева;
    pcS    - сканер;
    pcO    - таблица объектов, видимость, операции
             чтения/записи симфайлов;
    pcB    - построение синтаксического дерева и контроль типов.

Для  упрощения  структуры ядра были внесены некоторые изменения в
язык Модула-2, которые сближают его с языком Оберон:
        - исключены локальные модули;
        - исключена конструкция FROM IMPORT;
        - добавлены знаковые типы SHORTINT, LONGINT и
          беззнаковые типы SHORTCARD и CARDINAL и
          вещественный тип LONGREAL;
        - добавлен тип BYTE (а в Оберон тип WORD).

Для  целых и вещественных определено включение типов; больший тип
содержит  значения меньших типов.

                           LONGREAL
                              |
                             REAL
                              |
                           LONGINT
                          /       \
                      INTEGER   CARDINAL
                       /     \    /
                  SHORTINT  SHORTCARD

Тип результата бинарной операции вычисляется следующим образом:
     - если оба операнда константы, то вычисления всегда выполняются
       в типе LONGINT, а тип результата вычисляется по значению
       результата;
     - если оба операнда беззнакового типа, то выполняется беззнаковая
       операция;
     - eсли один из операндов знаковый, а другой беззнаковый,
       то оба операнда приводятся к целому типу, который не меньше
       типов обоих операндов.
       Например: SHORTINT + SHORTCARD => INTEGER;

Система  типов,  реализуемая  ядром, является объединением систем
типов  языков  Модулы-2  и  Оберона. При этом реализация парсеров
предусматривает  возможность  использования типов, которые нельзя
явно  описать  на  этом  языке.  Например, в программе на Обероне
можно  использовать  массив  с  ненулевой  нижней  границей (если
импортировать  тип массива или переменную из модуля на Модуле-2),
хотя описать такой тип на Обероне невозможно.

Опишем более детально модули ядра компилятора и его фунции.

2.1. Модуль pcМ

Модуль  реализует  интерфейс  с  операционной  системой,  который
включает в себя операции чтения исходного текста, операции чтения
и  записи  (элементов) симфайла, операцию сообщения об ошибках, а
также  операции  записи кодофайла и дополнительной информации для
отладчиков  (реффайла).  Операции  записи  кодофайла  и  реффайла
используются  только  генераторами  кода  и могут отсутствовать в
данном модуле.

Кроме  того, модуль содержит набор переменных, которые определяют
максимальные  и  минимальные  значения  численных типов, значения
константы  NIL,  а  также  ограничения на экспоненту вещественных
чисел. Эти переменные используются модулями ядра и парсера.

2.2. Модуль pcK

Модуль  определяет  три  основных  типа  компилятора.  Тип OBJECT
описывает  структуру  объекта,  тип  STRUCT  - структуру типового
значения, а тип NODE - структуру узла синтаксического дерева.

Кроме типов, модуль содержит наборы констант, определяющие виды
объектов, типов и узлов, а также три переменные, определяющие
начальные значения для этих типов.

2.3. Модуль pcS

Модуль  реализует  общий  сканер  для  двух языков. Для литералов
реализованы  объединение  представлений.  Так  целое  число может
завершатся  символами  "H"  и "B", а литерные константы символами
"X"   и  "C", обозначающими  соответственно  шестнадцетиричное  и
восьмеричное    представление.    При   разборе   ключевых   слов
используется переменная, определяющая язык, который компилируется
в   данный  момент.  Эта  переменная  позволяет  не  распознавать
некоторые  слова  как  ключевые.  Например,  "SET" - это ключевое
слово  для  Модулы-2  и  стандартный идентификатор для Оберона. К
счастью набор ключевых слов для этих языков практически совпадает
и различия не создают больших проблем.

2.4. Модуль pcO

Модуль  реализует  операции  описания  объекта,  поиска объекта в
контексте,  операции входа в новый блок и выхода а также операции
чтения/записи  симфайла.  Ввиду  удаления  локальных  модулей  из
реализации   языка   Модула-2   правила   видимость   практически
совпадают.  Исключение  составляет операция поиска поля в записи.
Реализована  обероновская  расширенная концепция записи.

Основные  различия  (с точки зрения данного модуля) в этих языках
лежат  в  области раздельной компиляции. В Обероне нет разделения
модуля  на  определяющий  и  реализующий  модуль.  Экспортируемые
объекты  явным  образом  помечены в тексте модуля. При компиляции
каждого  модуля  строиться  симфайл, который затем сравнивается с
предыдущим  симфайлов  для  данного  модуля.  Если  эти  симфайлы
совпадают,  то новый симфайл не записывается и индикант версии не
меняется.  Некоторое усложнение алгоритмов чтения/записи симфайла
оправдано  тем,  что это позволяет обеспечить возможность (почти)
свободного смешивания языков при написание ПО.

Некоторая  проблема  при  разработке  и  алгоритмов чтения/записи
симфайла   была   связана   с   тем,  что  симфайл  содержит  как
машинно-независимую  (типы,  параметры),  так и машинно-зависимую
(размещение   переменных,   адреса   процедур)   информацию.  Для
разрешения  этой проблемы данный модуль параметризован операциями
операциями   чтения/записи   машинно-зависимой   информации   для
объектов  и  типов.  После  записи  (чтения)  элемента  в симфайл
вызывается  процедура,  которая  записывает  (читает)  информации
необходимую       генератору.      Эти      четыре      процедуры
(get_object/put_object,    get_struct/put_struct)   должны   быть
выставлены при инициализации компилятора.

2.5. Модуль pcB

Модуль реализует примитивы построения синтаксического дерева и
операции контроля типов.

Модуль   параметризованы  процедурой  инициализации  генератора,
операциями  вычисления  константных выражений и множеством типов,
совместимых по присваиванию с типом WORD.


3. Парсеры

Модули  pcM2,  pcO2  реализуют  парсеры для языков Модула-2 и
Оберон соответственно. Каждый парсер строит синтаксическое дерево
модуля,   выполняя   семантические   проверки  в  соответствии  с
правилами   языка.

4. Как писать генераторы

Разработчик генератора (back-end) для конкретной машины должен
выполнить следующие действия:

1) Присвоить значения переменным из модуля pcSystem, обозначающим
размеры следующих типов:
    cardinal
    integer
    longint
    real
    longreal
    boolean
    bitset
    byte        = shortcard, shortint, char
    word
    addr        = pointer
    proctype

Эти  размеры  выставляются в единицах памяти, принятых для данной
машины   (как  правило  в  байтах).  Предполагается,  что  размер
значения  типа byte равен размеру значения типов shortint и char,
а размер значения типа addr, равен размеру значения указателей.

Размеры    стандартных    типов    выставляются    при   создании
соответстующих  типовых  значений,  размеры  процедурных  типов и
типов  указателей  также  выставляются  при  чтении  из  симфайла
соответствующих  типов.  Размеры  остальных  типов записываются в
симфайл  и  выставляются  при чтении из него, за исключением типа
отрезка, размер которого равен размеру базового типа.

Также  необходимо  выставить  значения  для следующих переменных,
используемых сканером и парсером:

nilval    - значение константы NIL;
min_sint  - MIN(SHORTINT)
max_sint  - MAX(SHORTINT)
max_scard - MAX(SHORTCARD)
max_card  - MAX(CARDINAL)
min_int   - MIN(INTEGER)
max_int   - MAX(INTEGER)
min_lint  - MIN(LONGINT)
max_lint  - MAX(LONGINT)
min_real  - MIN(REAL)
max_real  - MAX(REAL)

max_hex_dig - максимальное число цифр в шестнадцетиричном
              представлении значения типа LONGINT;

max_dig     - максимальное число цифр в мантиссе типа LONGREAL;
max_exp     - максимальное значение экспоненты типа LONGREAL.

Заметим,  что  после  переноса компилятора на целевую машину, эти
значения  могут  быть выставлены в инициализации модуля pcM,
или переменные могут быть заменены на константы с соответстующими
значениями.

2)  При  создании  объектов, типовых значений и узлов дерева всем
полям соответствующих записей выставляются значения по умолчанию.
В  случае  необходимости  генератор  может  заменить  значения по
умолчанию  для  полей,  которые  используются только генератором:
STRUCT.adr,   STRUCT.size,   OBJECT.adr.   Для   этого  нобходимо
выставить     нужные     значения     полей     для    переменных
pcKernel.null_struct, pcKernel.null_object.

3)    Реализовать   процедуры   чтения/записи   машинно-зависимой
информации в симфайл:

PROCEDURE put_object(o: pcKernel.OBJECT);
PROCEDURE put_struct(o: pcKernel.STRUCT);

PROCEDURE get_object(o: pcKernel.OBJECT);
PROCEDURE get_struct(o: pcKernel.STRUCT);

Процедуры записи вызываются после того, как все машинно-независимая
информация о данном объекте или типе уже записана в симфайл. Запись
информации осуществляется процедурами из модуля pcSystem:

PROCEDURE put(x: LONGINT);      -- запись байта
PROCEDURE put2(x: LONGINT);     -- запись 2 байтов
PROCEDURE put4(x: LONGINT);     -- запись 4 байтов
PROCEDURE put8(x: LONGREAL);    -- запись 8 байтов

PROCEDURE put_name(s: ARRAY OF CHAR);
-- запись имени (завершается символом LF)

PROCEDURE put_bytes(x: ARRAY OF BYTE; len: LONGINT);
-- запись len байтов (без завершителя).

Процедуры    чтения    вызываются    после    того,    как    все
машинно-независимая  информация  о  данном  объекте  или типе уже
прочитна из симфайл. Чтение информации осуществляется процедурами
из модуля pcSystem:

PROCEDURE get(VAR x: LONGINT);
PROCEDURE get2(VAR x: LONGINT);
PROCEDURE get4(VAR x: LONGINT);
PROCEDURE get8(VAR x: LONGREAL);
PROCEDURE get_name(VAR s: ARRAY OF CHAR);
PROCEDURE get_bytes(VAR x: ARRAY OF BYTE; len: LONGINT);

4)  Реализовать  процедуры  вычисления  константных  выражений. В
компиляторе   принята   следующая  схема  вычисления  константных
выражений:  парсер  не  обладает  информацией  о целевой машине и
поэтому   не  может  вычислить  некоторые  константные  выражения
(например, значение константы типа ARRAY OF INTEGER). Поэтому для
вычисления константного (под-)выражения парсер вызывает процедуру

PROCEDURE eval(expr: pc.NODE; VAR val: LONGINT; VAR e: pc.EXT);

Для хранения значений констант и литералов используются два поля:

В узле дерева: val: LONGINT; ext: EXT;
В объекте    : adr: LONGINT; ext: EXT;

Скалярные  значения должны храниться в целом поле. Все остальные:
множества,  вещественные,  строки,... могут храниться генератором
произвольно в этих двух полях.

Парсер  выставляет  значение  перечислимого  типа  в  поле  adr у
константы  и  значение константы NIL (pcSystem.nilval) в поле val
соответствующего  узла. При создании узла дерева соответствующего
использованию  константы, поля adr,ext объекта компируются в поля
val,ext узла дерева.

При разборе литерала парсер вызывает процедуру

   literal(n: pc.NODE)

Генератор  должен  заполнить поля val, ext данного узла пользуясь
переменными   сканера,   содержащими   информацию   о   последней
прочитанной лексеме.

При  генерации  кода  все,  что  можно  вычислить  константно уже
вычисленно.  Так  например  в  дереве  нет  HIGH(a), если a - это
простой массив (не динамический).

5)  Реализовать  процедуру обхода дерева, определяющую размещения
(адреса)  переменных,  параметров,  полей, процедур и структурных
констант и размеры типов.

5. Особенности языка Оберон-2.

В этом пункте описываются специфические черты языка Оберон-2 и
их возможная реализация:

1) Динамический контроль типов.
2) Контроль присваивания записей.
3) Определение и вызов метода.
4) Сборка мусора.
5) Многомерные открытые и динамические массивы.

5.1. Динамический контроль типов

Динамический контроль типов должен выполняться в трех случаях:

        - type guard;
        - операция IS;
        - оператор WITH;

Во всех случаях обьект контроля должен быть указателем или
VAR параметром типа запись, а тип к которому приводят должен быть
типом указателя или записи соответственно.

Пусть  p  -  указатель  или  VAR-запись, T тип указателя и записи
соответственно:

p(T)
WITH p: T DO ... END
p IS T

Парсер  проверяет,  что  статический  тип  p (то есть тип в точке
описания)  не  больше  типа T, то есть тип Т получен расширениями
статического типа p.
В динамике должна быть выполнена проверка,  что динамический
тип p не меньше типа T.

Пример:

TYPE
  ptr0 = POINTER TO rec0;
  rec0 = RECORD a: INTEGER END;
  ptr1 = POINTER TO rec1;
  rec1 = RECORD (rec0) b: INTEGER END;

VAR
  p0: ptr0;    -- статический тип ptr0 (rec0)
  p1: ptr1;    -- статический тип ptr1 (rec1)

BEGIN
  NEW(p1);
  p0:=p1;         -- динамический тип p0 - ptr1 (rec1)
  p0(ptr1).b:=1;  -- проверка того, что динамический тип p0,
                  -- не меньше (больше или равно) ptr1,
                  -- следовательно поле b есть и ему можно присвоить.
  IF p0 IS ptr1 THEN p0.a:=p0(T).b END;
  WITH p0: ptr1 DO p0.b:=1 END;
END

Реализация контроля:

Динамический   контроль   выполняется  за  константое  время  при
условии,  что возможность расширения записей ограничена некоторой
константой  (т.е.  запись  нельзя  расширять  более  чем  N раз).
Величина  N может выбираться генераптором достаточно произвольно,
но должна быть одинакова для всех записей (рекомендуется N=7).

Для  каждой  записи известен уровень ее расширения. Уровень равен
0,  если запись базовая, и равен n+1, если уровень базовой записи
равен n.

Генератор  порождает  для  каждой  записи  таблицy  размера  N, в
которой  в  элементе с номером i содержиться указатель на таблицу
соответствующую  i-базовой  записи (где i от 1 до уровня записи).
Эта  таблица далее будет называться дескриптором типа (вернее это
часть дескриптора типа, см. дальше).

Для   предыдущего   примера   компилятор   должен  построить  два
дескриптора  типа. Дескриптор типа ptr0 пустой (соотоит из NIL's)
согласно  определению.  Дескриптор  типа  ptr1  содержит в первом
слове  указатель  на  себя.  Заметим,  что 0 слово дескриптора не
используется,  поэтому  таблицу  лучше  рассматривать  как массив
[1..N].

Собственно проверка p IS T выглядит так:

динамический_тип_p [ номер_уровня_T ] = указатель_на_дескриптор_типа_Т

где динамический тип p хранится в -1 поле записи для указателя,
а для VAR-записи передается в процедуру вместе с адресом записи.

Эта запись расшифровывается следующим образом:

Если тип p расширяет тип T, то его n-предок есть T.

Конструкции p(T) и WITH p: T DO эквивалентны:

IF NOT (p IS T) THEN interrupt END.

Вид дерева для дин.контроля:

p(T), p IS T
              GUARD | IS
             /
            p

node^.obj^.type - тип к которому нужно приводить.

WITH p: T DO stat_seq END;

              WGUARD
             /      \
           p(T)    stat_seq

5.2. Контроль присваивания записей

В конструкциях
    p^:=r;      -- p  - указатель на запись
    vr:=r       -- vr - var параметр запись

необходимо выполнить динамическую проверку того, что динамический
тип левой части равен ее статическому типу.

Парсер вставляет узел с видом eguard в левую часть присваивания.

5.3. Определение и вызов метода

К любой записи в Обероне может быть добавлен метод:

PROCEDURE (VAR r: rec0) m1 ((* parameters*));
PROCEDURE (p: ptr0) m2 (....)

Метод может быть перекрыт для любой записи расширяющей данныю:

PROCEDURE / (VAR r: rec1) m1 ((* parameters*));
PROCEDURE / (p: ptr1) m2 (....)

Профиль метода при этом должен совпадать.

Вызов метода происходит по динамическому типу. Дескриптор
типа записи содержит таблицу методов (формальных процедур).
Вызов метода:

   p.m1(x) => динамический_тип_p [ m1_номер ] (p,x)

Внутри метода может быть вызван метод базовой записи:

   p.m1^(x)

При  этом  парсер статически знает вызываемую процедуру и генерит
простой  вызов  (не  вызов  метода).  Также преобразуется посылка
метода  записи (не var-параметру). Т.о. с точки зрения генератора
вызовы   методов   бывают   только  динамические  (через  таблицу
методов).

Парсер  порождает  для  метода  два  объекта.  Один  объект - это
нормальная  процедура, другой объект с видом method соответствует
элементу в таблице методов. Процедуры провязаны в список объектов
модуля для того, чтобы обеспечить корректную их нумерацию. Методы
каждой  записи  связаны в список record^.link. Признак redefine у
метода означает, что это переопределение метода из базовой записи
и,  следовательно, номер в таблице должен быть взят у предыдущего
метода.  Процедурный  тип  метода (т.е. тип процедурного об'екта)
содержит и неявный параметр метода.

Вызов метода:

                CALL
               /    \
            METHOD   param_list
             /
          designator

METHOD^.type - процедурный тип метода
METHOD^.obj  - об'ект метод

5.4. Сборка мусора

Андрей знает

5.5. Многомерные динамические и открытые массивы.

Тип параметра: { ARRAY OF } Type.

Многомерные динамические массивы не реализованы.
