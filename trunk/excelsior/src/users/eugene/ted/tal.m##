IMPLEMENTATION MODULE tal; (* 26-Oct-89. (c) KRONOS *)FROM SYSTEM     IMPORT  ADR, ADDRESS;FROM VIDEO      IMPORT  rect, rep, color, mode, start, finish, patt, vect, com;FROM Terminal   IMPORT  print, Read;CONST  min_integer=-10000h;  max_integer=10000h;  board=min_integer;  free=0;VAR  mem: ARRAY [0..399] OF tile_rec;  fr : ARRAY [0..HIGH(mem)] OF BOOLEAN;PROCEDURE xe(t: tile): INTEGER;BEGIN  ASSERT(t#NIL);  ASSERT(t^.rt#NIL);  RETURN t^.rt^.x-1;END xe;PROCEDURE ye(t: tile): INTEGER;BEGIN  ASSERT(t#NIL);  ASSERT(t^.up#NIL);  RETURN t^.up^.y-1;END ye;PROCEDURE ALLOCATE(VAR a: ADDRESS; s: INTEGER);  VAR i: INTEGER;BEGIN  ASSERT(s=SIZE(tile_rec));  FOR i:=0 TO HIGH(fr) DO    IF fr[i] THEN fr[i]:=FALSE; a:=ADR(mem[i]); RETURN END;  END;  HALT(1);END ALLOCATE;PROCEDURE DEALLOCATE(VAR a: ADDRESS; s: INTEGER);  VAR i: INTEGER;BEGIN--  print('(%4d,%4d)-(%4d,%4d)\n',t^.x,t^.y,xe(t),ye(t))  ASSERT(s=SIZE(tile_rec));  i:=(a-ADR(mem)) DIV SIZE(tile_rec);  ASSERT(a=ADR(mem[i]));  ASSERT(NOT fr[i]);  fr[i]:=TRUE;END DEALLOCATE;PROCEDURE show(t: tile);  VAR x,y,x1,y1: INTEGER;BEGIN  x:=t^.x; y:=t^.y;  x1:=t^.rt^.x-1; y1:=t^.up^.y-1;  mode(rep); patt(1);  IF (t^.dt=board) OR (t^.dt=0) THEN    color(0);  ELSE    color(t^.dt)  END;  rect(x,y,x1,y1);  mode(com); patt(1); color(3);  vect(x,y,x,y1);  vect(x,y,x1,y);END show;PROCEDURE go(x,y: INTEGER);BEGIN  LOOP    IF    xe(wsp)<x THEN wsp:=wsp^.rt    ELSIF ye(wsp)<y THEN wsp:=wsp^.up    ELSIF wsp^.x>x  THEN wsp:=wsp^.lf    ELSIF wsp^.y>y  THEN wsp:=wsp^.dw    ELSE RETURN    END;  END;END go;PROCEDURE div_h(t: tile; y: INTEGER);  VAR s,u: tile;BEGIN  ASSERT(t#NIL);  IF t^.y=y THEN RETURN END;  ASSERT(t^.up^.y>y);  ALLOCATE(u,SIZE(u^));  u^:=t^; u^.y:=y; u^.dw:=t; t^.up:=u;  s:=t^.lf;  WHILE ye(s)<y DO s:=s^.up END;  ASSERT(s^.y<=y);  u^.lf:=s;  WHILE ye(s)<=ye(u) DO s^.rt:=u; s:=s^.up END;  s:=u^.rt;  WHILE s^.y>=y DO s^.lf:=u; s:=s^.dw END;  t^.rt:=s;  s:=u^.up;  WHILE s^.x>=u^.x DO s^.dw:=u; s:=s^.lf END;END div_h;PROCEDURE cat_h(t: tile);  VAR s,u: tile;BEGIN  ASSERT(t#NIL);  u:=t^.up;  ASSERT(u^.x=t^.x);  ASSERT(xe(u)=xe(t));  t^.up:=u^.up; t^.rt:=u^.rt;  s:=u^.lf;  WHILE ye(s)<=ye(u) DO s^.rt:=t; s:=s^.up END;  s:=u^.rt;  WHILE s^.y>=u^.y DO s^.lf:=t; s:=s^.dw END;  s:=u^.up;  WHILE s^.x>=u^.x DO s^.dw:=t; s:=s^.lf END;  DEALLOCATE(u,SIZE(u^));END cat_h;PROCEDURE div_v(t: tile; x: INTEGER);  VAR s,u: tile;BEGIN  ASSERT(t#NIL);  IF t^.x=x THEN RETURN END;  ASSERT(t^.rt^.x>x);  ASSERT(t^.x<x);  ALLOCATE(u,SIZE(u^));  u^:=t^; u^.x:=x; u^.lf:=t; t^.rt:=u;  s:=t^.dw;  WHILE xe(s)<x DO s:=s^.rt END;  ASSERT(s#NIL);  ASSERT(s^.x<=x);  u^.dw:=s;  WHILE xe(s)<=xe(u) DO s^.up:=u; s:=s^.rt END;  s:=u^.up;  WHILE s^.x>=x DO s^.dw:=u; s:=s^.lf END;  t^.up:=s;  s:=u^.rt;  WHILE s^.y>=u^.y DO s^.lf:=u; s:=s^.dw END;END div_v;PROCEDURE cat_v(t: tile);  VAR s,u: tile;BEGIN  ASSERT(t#NIL);  u:=t^.rt;  ASSERT(u^.y=t^.y);  ASSERT(ye(u)=ye(t));  t^.rt:=u^.rt; t^.up:=u^.up;  s:=u^.dw;  WHILE xe(s)<=xe(u) DO s^.up:=t; s:=s^.rt END;  s:=u^.up;  WHILE s^.x>=u^.x DO s^.dw:=t; s:=s^.lf END;  s:=u^.rt;  WHILE s^.y>=u^.y DO s^.lf:=t; s:=s^.dw END;  DEALLOCATE(u,SIZE(u^));END cat_v;PROCEDURE cat(t: tile);BEGINRETURN;  IF t^.dt=board THEN RETURN END;  LOOP    IF (t^.rt^.dt=t^.dt) & (t^.y=t^.rt^.y) & (t^.up^.y=t^.rt^.up^.y) THEN      cat_v(t)    ELSIF (t^.up^.dt=t^.dt) & (t^.x=t^.up^.x) & (t^.rt^.x=t^.up^.rt^.x) THEN      cat_h(t)    ELSE RETURN    END;  END;END cat;PROCEDURE app(x,y,sx,sy,dt: INTEGER);  VAR new: tile;  PROCEDURE compress(): BOOLEAN;    VAR d: INTEGER;  BEGIN    go(x,y);    LOOP      IF (sx=0) OR (sy=0) THEN RETURN TRUE END;      IF wsp^.dt=dt THEN        IF (wsp^.x<=x) & (wsp^.rt^.x>=x+sx) THEN          d:=wsp^.up^.y-y;          IF d>=sy THEN d:=sy END;          DEC(sy,d); INC(y,d);          wsp:=wsp^.up;          WHILE wsp^.x>x DO wsp:=wsp^.lf END;        ELSIF (wsp^.y<=y) & (wsp^.up^.y>=y+sy) THEN          d:=wsp^.rt^.x-x;          IF d>=sx THEN d:=sx END;          DEC(sx,d); INC(x,d);          wsp:=wsp^.rt;          WHILE wsp^.y>y DO wsp:=wsp^.dw END;        ELSE EXIT        END;      ELSE EXIT      END;    END;    RETURN FALSE;  END compress;  PROCEDURE kill_up(t: tile); FORWARD;  PROCEDURE kill_rt(t,tt: tile); FORWARD;  PROCEDURE kill_dw(s,t,rt,u: tile);    VAR d: tile;  BEGIN    ASSERT(s#new);    IF s^.y>=y+sy THEN RETURN END;    d:=s^.dw;    IF d^.y>=t^.y THEN      kill_dw(d,t,rt,u);    ELSE      kill_rt(rt,u);    END;    DEALLOCATE(s,SIZE(s^));  END kill_dw;  PROCEDURE kill_rt(t,u: tile);    VAR s: tile;  BEGIN    s:=t^.rt;    IF s^.x>=x+sx THEN      kill_up(u)    ELSIF s^.y>=t^.y THEN      kill_dw(s,t,s^.rt,u);    END;  END kill_rt;  PROCEDURE kill_up(s: tile);    VAR u: tile;  BEGIN    ASSERT(s#new);    IF s^.y>=y+sy THEN RETURN END;    ASSERT(s^.x=x);    u:=s^.up;    WHILE u^.x>x DO u:=u^.lf END;    kill_rt(s^.rt,s^.y,u);    DEALLOCATE(s,SIZE(s^));  END kill_up;  VAR t,s: tile;BEGIN--  IF compress() THEN RETURN END;  go(x,y);  ASSERT(wsp^.x<=x); ASSERT(wsp^.y<=y);  ASSERT(xe(wsp)>=x); ASSERT(ye(wsp)>=y); -- (x,y) внутри тайла wsp  ALLOCATE(new,SIZE(new^));  new^.x:=x; new^.y:=y;  new^.an:=0; new^.dt:=dt;  s:=wsp; go(x+sx-1,y+sy-1);  IF ye(wsp)>=y+sy THEN div_h(wsp,y+sy) END;  IF s^.y<y THEN div_h(s,y); IF wsp=s THEN wsp:=s^.up END; s:=s^.up END;  IF xe(wsp)>=x+sx THEN div_v(wsp,x+sx) END;  IF s^.x<x THEN div_v(s,x); IF wsp=s THEN wsp:=s^.rt END; s:=s^.rt END;  new^.rt:=wsp^.rt; new^.up:=wsp^.up;  new^.lf:=s^.lf; new^.dw:=s^.dw;  -- s - левый нижний угол, wsp - правый верхний угол  t:=wsp^.up;  WHILE xe(t)>=x DO    ASSERT(t^.y<=y+sy);    IF t^.y<y+sy THEN div_h(t,y+sy); t:=t^.up END; t:=t^.lf;  END;  t:=wsp^.rt;  WHILE ye(t)>=y DO    ASSERT(t^.x<=x+sx);    IF t^.x<x+sx THEN div_v(t,x+sx); t:=t^.rt END; t:=t^.dw;  END;  ASSERT(s^.x<=x); ASSERT(s^.y<=y);  ASSERT(xe(s)>=x); ASSERT(ye(s)>=y); -- (x,y) внутри тайла s  t:=s^.dw;  WHILE t^.x<x+sx DO    ASSERT(ye(t)+1>=y);    IF ye(t)>=y THEN div_h(t,y); IF t=wsp THEN wsp:=wsp^.up END END; t:=t^.rt;  END;  t:=s^.lf;  WHILE t^.y<y+sy DO    ASSERT(xe(t)+1>=x);    IF xe(t)>=x THEN div_v(t,x); IF t=wsp THEN wsp:=wsp^.rt END END; t:=t^.up;  END;  ASSERT(s^.x<=x); ASSERT(s^.y<=y);  ASSERT(xe(s)>=x); ASSERT(ye(s)>=y); -- (x,y) внутри тайла s  t:=wsp^.up;  WHILE t^.x>=x DO t^.dw:=new; t:=t^.lf END;  t:=wsp^.rt;  WHILE t^.y>=y DO t^.lf:=new; t:=t^.dw END;  t:=s^.dw;  WHILE xe(t)<x+sx DO t^.up:=new; t:=t^.rt END;  t:=s^.lf;  WHILE ye(t)<y+sy DO t^.rt:=new; t:=t^.up END;  wsp:=new;  kill_up(s);  box(x-1,y-1,sx+2,sy+2,cat);END app;PROCEDURE box(x,y,sx,sy: INTEGER; p: iter_proc);  PROCEDURE bend(t: tile);    VAR y0: INTEGER;  BEGIN    ASSERT(t^.y<y+sy); ASSERT(ye(t)>=y);    ASSERT(t^.x<x+sx); ASSERT(xe(t)>=x); -- тайл t попал в окно    y0:=t^.y; t:=t^.rt;    IF t^.x>=x+sx THEN RETURN END;    IF y0<=y THEN y0:=y+1 END;    WHILE t^.y>=y+sy DO t:=t^.dw END;    WHILE t^.y>=y0 DO bend(t); p(t); t:=t^.dw END;  END bend;  VAR t,s: tile;BEGIN  go(x,y); s:=wsp;  bend(s); p(s);  t:=s^.rt;  WHILE t^.x<x+sx DO    WHILE t^.y>y DO t:=t^.dw END;    bend(t); p(t); t:=t^.rt;  END;  t:=s^.up;  WHILE t^.y<y+sy DO    WHILE t^.x>x DO t:=t^.lf END;    bend(t); p(t); t:=t^.up;  END;END box;PROCEDURE nab(s: tile; p: iter_proc);  VAR t: tile;BEGIN  t:=s^.dw;  IF (t^.x=s^.x) & (s^.lf^.y=s^.y) THEN    t:=t^.lf;    WHILE t^.up^.y<s^.y DO t:=t^.up END;  END;  REPEAT p(t); t:=t^.rt UNTIL t^.x>s^.rt^.x;  t:=s^.lf;  REPEAT p(t); t:=t^.up UNTIL t^.y>s^.up^.y;  t:=s^.up;  IF (xe(t)=xe(s)) & (ye(s^.rt)=ye(s)) THEN    t:=t^.rt;    WHILE t^.y>s^.up^.y DO t:=t^.dw END;  END;  REPEAT p(t); t:=t^.lf UNTIL t^.rt^.x<=s^.x;  t:=s^.rt;  REPEAT p(t); t:=t^.dw UNTIL t^.up^.y<=s^.y;END nab;VAR  t: ARRAY [0..10] OF tile_rec;  i: INTEGER;PROCEDURE brd(n,x,y,lf,dw,rt,up: INTEGER);BEGIN  t[n].x:=x; t[n].y:=y;  t[n].lf:=ADR(t[lf]); t[n].rt:=ADR(t[rt]);  t[n].dw:=ADR(t[dw]); t[n].up:=ADR(t[up]);  t[n].an:=0; t[n].dt:=board;END brd;BEGIN  brd( 0,min_integer  ,min_integer  ,9,10,1,3);  brd( 1,min_integer+1,min_integer  ,0,10,2,4);  brd( 2,max_integer-1,min_integer  ,1,10,9,5);  brd( 3,min_integer  ,min_integer+1,9,0,4,6);  brd( 4,min_integer+1,min_integer+1,3,1,5,7);  brd( 5,max_integer-1,min_integer+1,4,2,9,8);  brd( 6,min_integer  ,max_integer-1,9,3,7,10);  brd( 7,min_integer+1,max_integer-1,6,4,8,10);  brd( 8,max_integer-1,max_integer-1,7,5,9,10);  brd( 9,max_integer  ,min_integer  ,2,10,6,10);  brd(10,min_integer  ,max_integer  ,10,6,10,9);  t[4].dt:=free;  wsp:=ADR(t[4]);  FOR i:=0 TO HIGH(mem) DO fr[i]:=TRUE END;END tal.