.TAIL 1 ''
.TAIL 0 ''
.HEAD 1 ''
.HEAD 0 ''



                - Сибирское отделение  АН СССР -




                   - Институт информатики -













:::::      ::::
:::::      ::::
 :::      :::
 :::     ::
 :::    ::
 ::: : :        ::::::       :::    :::   :::    :::       :::
 :::    ::      ::    ::   ::: :::  :::   :::  ::: :::   ::: :::
 :::     :::    ::     :: ::     ::  ::   ::  ::     :: ::
 :::      :::   ::     :: ::     ::  :::::::  ::     :: ::
:::::      :::: :::  :::   ::: :::  :::   :::  ::: :::   ::: :::
:::::      :::: ::::::       :::    :::   :::    :::       :::
                ::
                ::
                ::  РУКОВОДСТВО ПО ОС EXCELSIOR











                         Новосибирск - 90
.PAGE
.TAIL 0 '@U%62x@u'
.TAIL 1 '@U%62x@u'
.TAIL 2 '%62d'
.TAIL 3 '%62d'

























                    Наш адрес:

                         630090,   Новосибирск-90,    проспект
                    ак. Лаврентьева, 6,  ВЦ СОАН СССР,  к.503,
                    тел. 35-50-67.
                         Для сотрудников ВЦ СOАН тел. 8-97.



Последнее изменение 7.08.91.
.PAGE
.HEAD 0 '@U                                                    СОДЕРЖАНИЕ@u'
.HEAD 1 '@U                                                    СОДЕРЖАНИЕ@u'
.HEAD 2 ''
.HEAD 3 ''

                          СОДЕРЖАНИЕ

   Структура этой и других книг о Кроносе  . . . . . . . . . 9

Книга первая. ОС Excelsior ДЛЯ НАЧИНАЮЩИХ . . . . . . . . . 11

   Короткое вступление . . . . . . . . . . . . . . . . . . .12

Часть 1. Диалог с Кроносом . . . . . . . . . . . . . . . . .13
  1.1. Клавиатура и экран  . . . . . . . . . . . . . . . . .13
    1.1.1. Курсор . . . . . . . . . . . . . . . . . . . . . 13
    1.1.2. Литеры . . . . . . . . . . . . . . . . . . . . . 13
    1.1.3. Управляющие клавиши  . . . . . . . . . . . . . . 13
    1.1.4. Контрольные символы  . . . . . . . . . . . . . . 13
  1.2. Вход в систему  . . . . . . . . . . . . . . . . . . .15
    1.2.1. Приглашение к работе. . . . . . . . . . . . . . .15
    1.2.2. Как войти в систему . . . . . . . . . . . . . . .15
  1.3. Командная строка  . . . . . . . . . . . . . . . . . .17
    1.3.1. Редактирование командной строки . . . . . . . . .17
    1.3.2. Режимы замены и вставки . . . . . . . . . . . . .17
    1.3.3. Переход в режим кириллицы . . . . . . . . . . . .18

Часть 2. Файловая система: первое знакомство. . . . . . . . 19
  2.1. Корни и ветви дерева. . . . . . . . . . . . . . . . .19
    2.1.1. Файл . . . . . . . . . . . . . . . . . . . . . . 19
    2.1.2. Директория . . . . . . . . . . . . . . . . . . . 19
    2.1.3. Носитель . . . . . . . . . . . . . . . . . . . . 19
  2.2. Имя файла  . . . . . . . . . . . . . . . . . . . . . 20
    2.2.1. Расширители имен файлов  . . . . . . . . . . . . 20
    2.2.2. Полное имя файла . . . . . . . . . . . . . . . . 20
    2.2.3. Соглашения об именах . . . . . . . . . . . . . . 21
  2.3. Прогулки по файловому дереву . . . . . . . . . . . . 22
  2.4. Создание и редактирование файла  . . . . . . . . . . 23
    2.4.1. Запуск редактора . . . . . . . . . . . . . . . . 23
    2.4.2. Как выйти из редактора . . . . . . . . . . . . . 23
    2.4.3. Экран  . . . . . . . . . . . . . . . . . . . . . 23
    2.4.4. Клавиатура . . . . . . . . . . . . . . . . . . . 24
           Драгоценные кнопочки . . . . . . . . . . . . . . 24
           Перемещения по тексту  . . . . . . . . . . . . . 25
           Вставка и удаление . . . . . . . . . . . . . . . 25
           Операции над строками  . . . . . . . . . . . . . 25
           Операции над единицами текста  . . . . . . . . . 25
           Выход в другие режимы редактора  . . . . . . . . 26
    2.4.5. Возможности редактора  . . . . . . . . . . . . . 26

Часть 3. Задачи для Кроноса . . . . . . . . . . . . . . . . 27
  3.1. Запуск задач . . . . . . . . . . . . . . . . . . . . 27
    3.1.1. Установка пути  . . . . . . . . . . . . . . . . .27
    3.1.2. Как запустить задачу  . . . . . . . . . . . . . .27
    3.1.3. Как остановить задачу . . . . . . . . . . . . . .28
    3.1.4. Стандартный ввод-вывод. . . . . . . . . . . . . .28
    3.1.5. Параллельное исполнение задач . . . . . . . . . .29
             Запуск независимой задачи . . . . . . . . . . .29
             Перечень задач  . . . . . . . . . . . . . . . .29
             Прекращение исполнения независимой задачи . . .29
  3.2. Утилиты  . . . . . . . . . . . . . . . . . . . . . . 31
    3.2.1. Ключи  . . . . . . . . . . . . . . . . . . . . . 31
    3.2.2. Запуск утилиты . . . . . . . . . . . . . . . . . 31
    3.2.3. Подсказка  . . . . . . . . . . . . . . . . . . . 32
  3.3. Командный файл . . . . . . . . . . . . . . . . . . . 33
    3.3.1. Запуск командного файла  . . . . . . . . . . . . 33
    3.3.2. Прекращение командного файла . . . . . . . . . . 33
    3.3.3. Соглашения для командных файлов  . . . . . . . . 33
    3.3.4. Пример командного файла  . . . . . . . . . . . . 34
    3.3.5. Запуск командного файла пользователя . . . . . . 35

Часть 4. Создание программ . . . . . . . . . . . . . . . . .36
  4.1. О языке Модула-2 . . . . . . . . . . . . . . . . . . 36
  4.2. Как пользоваться библиотеками  . . . . . . . . . . . 37
    4.2.1. Модульность и библиотеки . . . . . . . . . . . . 37
    4.2.2. Назначение и название . . . . . . . . . . . . . .37
    4.2.3. StdIO - стандартный вывод . . . . . . . . . . . .37
             Примеры употребления процедуры print . . . . . 40
  4.3. Компиляция . . . . . . . . . . . . . . . . . . . . . 42
    4.3.1. Запуск  компилятора  . . . . . . . . . . . . . . 42
    4.3.2. Что получается в результате компиляции . . . . . 42
    4.3.3. Сообщения компилятора  . . . . . . . . . . . . . 43
             Для турбо-компилятора . . . . . . . . . . . . .43

Книга вторая. ОС EXCELSIOR ДЛЯ ВСЕХ . . . . . . . . . . . . 41
  Первое предисловие соавтора . . . . . . . . . . . . . . . 41

Часть 5. Система программирования Модула. . . . . . . . . . 41

  5.1. Входной язык компилятора . . . . . . . . . . . . . . 41
    5.1.1. Ограничения реализации . . . . . . . . . . . . . 41
    5.1.2. Изменения, внесенные в язык. . . . . . . . . . . 41
       5.1.2.1. Список изменений. . . . . . . . . . . . . . 41
       5.1.2.2. Дополнения к Сообщению о языке Модула-2 . . 41
       5.1.2.3. Синтаксис входного языка. . . . . . . . . . 41
    5.1.3. Еще раз о расширениях. . . . . . . . . . . . . . 41
       5.1.3.1. Динамические массивы. . . . . . . . . . . . 41
       5.1.3.2. Процедуры с переменным числом параметров. . 41
       5.1.3.3. Динамическая поддержка, определяемая
                пользователем . . . . . . . . . . . . . . . 41
    5.1.4. Режимы компиляции. . . . . . . . . . . . . . . . 41
    5.1.5. Стиль программирования . . . . . . . . . . . . . 41
       5.1.5.1. Расположение текста . . . . . . . . . . . . 41
       5.1.5.2. Комментарии . . . . . . . . . . . . . . . . 41
       5.1.5.3. Именование. . . . . . . . . . . . . . . . . 41
       5.1.5.4. Использование языковых конструкций. . . . . 41
       5.1.5.5. Оформление определяющего модуля библиотек . 41
    5.1.6. Примеры программ . . . . . . . . . . . . . . . . 41

  5.2. Использование компилятора. . . . . . . . . . . . . . 41
    5.2.1. Имена модулей и файлов . . . . . . . . . . . . . 41
    5.2.2. Пакетный компилятор. . . . . . . . . . . . . . . 41
    5.2.3. Турбо-компилятор . . . . . . . . . . . . . . . . 41
    5.2.4. Перечень сообщений компилятора . . . . . . . . . 41
    5.2.5. Порядок компиляции . . . . . . . . . . . . . . . 41
    5.2.6. О конфликте версий . . . . . . . . . . . . . . . 41
    5.2.7. Среда компиляции . . . . . . . . . . . . . . . . 41

  5.3. Реализация компилятора . . . . . . . . . . . . . . . 41
    5.3.1. Детали реализации. . . . . . . . . . . . . . . . 41
    5.3.2. Структура компилятора. . . . . . . . . . . . . . 41
       5.3.2.1. Интерфейс компилятора . . . . . . . . . . . 41

  5.4. Средства отладки и визуализации программ . . . . . . 41
    5.4.1. Визуализация М-кода. . . . . . . . . . . . . . . 41
    5.4.2. Посмертный историк . . . . . . . . . . . . . . . 41
    5.4.3. Симфайлы, кодофайлы, реффайлы. . . . . . . . . . 41

  5.5. Еще о Модула-x компиляторе . . . . . . . . . . . . . 41

Часть 6. RFE

Часть 7. Shell: пользовательская оболочка ОС. . . . . . . . 50

  7.1. Окружение и его параметры. . . . . . . . . . . . . . 50
    7.1.1. Приглашение к вводу команды. . . . . . . . . . . 50
    7.1.2. Изменение параметров окружения . . . . . . . . . 50
    7.1.3. Изменение параметров чужого окружения. . . . . . 50
    7.1.4. О приватных параметрах . . . . . . . . . . . . . 50
    7.1.5. Имя параметра вместо его значения. . . . . . . . 50

  7.2. Команды shell. . . . . . . . . . . . . . . . . . . . 50
    7.2.1. Как узнать текущие значения параметров (set) . . 50
    7.2.2. Информация о задачах (ps). . . . . . . . . . . . 50
      7.2.2.1. Модификатор usr. . . . . . . . . . . . . . . 50
      7.2.2.2. Модификатор tty. . . . . . . . . . . . . . . 50
      7.2.2.3. Модификатор mem. . . . . . . . . . . . . . . 50
      7.2.2.4. Модификатор l. . . . . . . . . . . . . . . . 50
      7.2.2.5. Модификатор all. . . . . . . . . . . . . . . 50
    7.2.3. Привилегированный доступ (su и us) . . . . . . . 50
    7.2.4. Как гулять по директориям (cd) . . . . . . . . . 50
    7.2.5. Показ распределения памяти (mem) . . . . . . . . 50
    7.2.6. История задачи (his) . . . . . . . . . . . . . . 50
    7.2.7. Задержка на несколько секунд (delay) . . . . . . 50
    7.2.8. Монтирование дисков (mount,unmount). . . . . . . 50
    7.2.9.. Управление задачами (stop, kill, wait). . . . . 50
    7.2.10. Завершение работы с shell . . . . . . . . . . . 50

  7.3. Запуск задач . . . . . . . . . . . . . . . . . . . . 50
    7.3.1. Простой случай . . . . . . . . . . . . . . . . . 50
    7.3.2. Запуск независимых задач . . . . . . . . . . . . 50
    7.3.3. После того, как задача запущена. . . . . . . . . 50
      7.3.3.1. Прекращение зависимой задачи . . . . . . . . 50
      7.3.3.2. Параметр CHAIN . . . . . . . . . . . . . . . 50
      7.3.3.3. О трупах задач зависимых и независимых . . . 50
    7.3.4. Управление деревом задач . . . . . . . . . . . . 50
    7.3.5. Управление поиском кодофайлов. . . . . . . . . . 50
    7.3.6. Управление окружением запускаемых задач. . . . . 50

  7.4. Запуск командных файлов. . . . . . . . . . . . . . . 50
    7.4.1. Запуск со специальным интерпретатором и без него 50
    7.4.2. Как shell интерпретирует командный файл. . . . . 50
    7.4.3. Кто исполняет командный файл . . . . . . . . . . 50

  7.5. Когда CTRL_C не действует. . . . . . . . . . . . . . 50

  7.6. Общее описание утилиты shell . . . . . . . . . . . . 50
    7.6.1. Раскрутка системы после загрузки . . . . . . . . 50
    7.6.2. Ведение диалога с пользователем. . . . . . . . . 50
    7.6.3. Интерпретация командных файлов . . . . . . . . . 50
    7.6.4. Запуск без аргументов. . . . . . . . . . . . . . 50

  7.7. Приложение: перечень параметров окружения. . . . . . 50
  7.8. Приложение: синтаксис команд shell . . . . . . . . . 50

Часть 8. Файловая подсистема. . . . . . . . . . . . . . . . 50
  Предисловие . . . . . . . . . . . . . . . . . . . . . . . 50
  Короткий словарик . . . . . . . . . . . . . . . . . . . . 50
  8.1. Виды файлов. . . . . . . . . . . . . . . . . . . . . 50
    8.1.1. Обычные файлы. . . . . . . . . . . . . . . . . . 50
    8.1.2. Директории . . . . . . . . . . . . . . . . . . . 50
    8.1.3. Файлы-устройства . . . . . . . . . . . . . . . . 50
  8.2. Параллелизм. . . . . . . . . . . . . . . . . . . . . 50
  8.3. Корневая и текущая директории. . . . . . . . . . . . 50
  8.4. Имена файлов . . . . . . . . . . . . . . . . . . . . 50
    8.4.1. Маршрут. . . . . . . . . . . . . . . . . . . . . 50
    8.4.2. Поиск от корня . . . . . . . . . . . . . . . . . 50
    8.4.3. Поиск от текущей директории. . . . . . . . . . . 50
    8.4.4. Имена для текущей и материнской директорий . . . 50
    8.4.5. Именование файла . . . . . . . . . . . . . . . . 50
    8.4.6. О привязанностях . . . . . . . . . . . . . . . . 50
  8.5. Хранение файлов. . . . . . . . . . . . . . . . . . . 50
  8.6. Защита файлов. . . . . . . . . . . . . . . . . . . . 50
  8.7. Библиотека BIO . . . . . . . . . . . . . . . . . . . 50
    8.7.1. Общие замечания. . . . . . . . . . . . . . . . . 50
    8.7.2. Об ошибках . . . . . . . . . . . . . . . . . . . 50
    8.7.3. chdir, chroot. . . . . . . . . . . . . . . . . . 50
    8.7.4. fname, splitpathname . . . . . . . . . . . . . . 50
    8.7.5. equal, open, fopen . . . . . . . . . . . . . . . 50
    8.7.6. create, fcreate. . . . . . . . . . . . . . . . . 50
    8.7.7. du, dup. . . . . . . . . . . . . . . . . . . . . 50
    8.7.8. close, purge . . . . . . . . . . . . . . . . . . 50
    8.7.9. link, flink. . . . . . . . . . . . . . . . . . . 50
    8.7.10. unlink, funlink . . . . . . . . . . . . . . . . 50
    8.7.11. mkdir, fmkdir . . . . . . . . . . . . . . . . . 50
    8.7.12. fmvdir. . . . . . . . . . . . . . . . . . . . . 50
    8.7.13. seek, buffers, check_io . . . . . . . . . . . . 50
    8.7.14. pos, eof. . . . . . . . . . . . . . . . . . . . 50
    8.7.15. fread, fwrite, read, write, get, put. . . . . . 50
    8.7.16. doio. . . . . . . . . . . . . . . . . . . . . . 50
    8.7.17. getch, putch, getstr, putstr, print . . . . . . 50
    8.7.18. cut, end, extend. . . . . . . . . . . . . . . . 50
    8.7.19. fstype. . . . . . . . . . . . . . . . . . . . . 50
    8.7.20. flush . . . . . . . . . . . . . . . . . . . . . 50
    8.7.21. mkfs. . . . . . . . . . . . . . . . . . . . . . 50
    8.7.22. mount, fmount, unmount, funmount. . . . . . . . 50
    8.7.23. mknode, fmknode . . . . . . . . . . . . . . . . 50
    8.7.24. kind. . . . . . . . . . . . . . . . . . . . . . 50
    8.7.25. chmode. . . . . . . . . . . . . . . . . . . . . 50
    8.7.26. access, owner, chcmask. . . . . . . . . . . . . 50
    8.7.27. chaccess, chowner . . . . . . . . . . . . . . . 50
    8.7.28. get_attr, set_attr. . . . . . . . . . . . . . . 50
    8.7.29. dir_walk, end_walk, restart_walk. . . . . . . . 50
    8.7.30. get_entry . . . . . . . . . . . . . . . . . . . 50
    8.7.31. open_paths, close_paths, get_paths. . . . . . . 50
    8.7.32. lookup. . . . . . . . . . . . . . . . . . . . . 50
    8.7.33. lock, unlock. . . . . . . . . . . . . . . . . . 50

Часть 9.  Диск в файловой системе . . . . . . . . . . . . . 50
  9.1. Блок . . . . . . . . . . . . . . . . . . . . . . . . 50
  9.2. Суперблок. . . . . . . . . . . . . . . . . . . . . . 50
    9.2.1. Метка носителя . . . . . . . . . . . . . . . . . 50
    9.2.2. Количество файлов. . . . . . . . . . . . . . . . 50
    9.2.3. Количество блоков. . . . . . . . . . . . . . . . 50
    9.2.4. Карта файлов . . . . . . . . . . . . . . . . . . 50
    9.2.5. Карта блоков . . . . . . . . . . . . . . . . . . 50
  9.3. Область дескрипторов файлов. . . . . . . . . . . . . 50
  9.4. Дескриптор  файла. . . . . . . . . . . . . . . . . . 50
    9.4.1. Таблица соответствия номеров блоков. . . . . . . 50
    9.4.2. Время создания файла . . . . . . . . . . . . . . 50
    9.4.3. Время модификации файла. . . . . . . . . . . . . 50
    9.4.4. Информация о правах доступа. . . . . . . . . . . 50
    9.4.5. Размер файла . . . . . . . . . . . . . . . . . . 50
    9.4.6. Количество ссылок на файл. . . . . . . . . . . . 50
    9.4.7. Специальные признаки . . . . . . . . . . . . . . 50
  9.5. Файл . . . . . . . . . . . . . . . . . . . . . . . . 50
  9.6. Директория . . . . . . . . . . . . . . . . . . . . . 50
    9.6.1. Узел директории. . . . . . . . . . . . . . . . . 50
      9.6.1.1. Имя узла . . . . . . . . . . . . . . . . . . 50
      9.6.1.2. Номер файла. . . . . . . . . . . . . . . . . 50
      9.6.1.3. Специальные признаки файла . . . . . . . . . 50

Часть 10. Драйверы внешних устройств. . . . . . . . . . . . 50
  10.1. Поддержка драйверов в системе . . . . . . . . . . . 50
  10.2. Типы драйверов. . . . . . . . . . . . . . . . . . . 50
  10.3. Структура драйвера. . . . . . . . . . . . . . . . . 50
     10.3.1. Описатель устройств. . . . . . . . . . . . . . 50
     10.3.2. Процедура обработки запроса. . . . . . . . . . 50

Часть 11. Базовая поддержка графики . . . . . . . . . . . . 50
  11.1. Общие сведения. . . . . . . . . . . . . . . . . . . 50
     11.1.1 Типы графических дисплеев . . . . . . . . . . . 50
     11.1.2. Буфер кадра. . . . . . . . . . . . . . . . . . 50
  11.2. Битовые карты . . . . . . . . . . . . . . . . . . . 50
  11.3. Библиотеки определения. . . . . . . . . . . . . . . 50
     11.3.1. Модуль defBMD. . . . . . . . . . . . . . . . . 50
     11.3.2. Модуль defScreen . . . . . . . . . . . . . . . 50
        11.3.2.1. Представление  экранов, тип  операции,
                  маска записи. . . . . . . . . . . . . . . 50
        11.3.2.2. Область отсечения (Clip Rectangle). . . . 50
        11.3.2.3. Описание прямоугольного блока . . . . . . 50
        11.3.2.4 Инструмент (Tool). . . . . . . . . . . . . 50
        11.3.2.5. Палитра (Palette) . . . . . . . . . . . . 50
        11.3.2.6 Описание Экрана. . . . . . . . . . . . . . 50
        11.3.2.7. Управляющие коды для драйверов. . . . . . 50
     11.3.3. Модуль defFonts. . . . . . . . . . . . . . . . 50
        11.3.3.1. Дескриптор шрифта . . . . . . . . . . . . 50
        11.3.3.2. DCH-шрифты. . . . . . . . . . . . . . . . 50
        11.3.3.3. PACKED-шрифты . . . . . . . . . . . . . . 50
        11.3.3.4. Дополнения. . . . . . . . . . . . . . . . 50
  11.4. Прикладные библиотеки . . . . . . . . . . . . . . . 50
     11.4.1 Модуль BMG (BitMap Graphics). . . . . . . . . . 50
        11.4.1.1 Процедуры работы с блоками . . . . . . . . 50
        11.4.1.2. Процедуры стирания и заполнения . . . . . 50
        11.4.1.3. Процедуры рисования графических
                  примитивов. . . . . . . . . . . . . . . . 50
     11.4.2 Модуль BMT (BitMap Text). . . . . . . . . . . . 50
     11.4.3. Модуль Screen. . . . . . . . . . . . . . . . . 50
        11.4.3.1. Переменные "done", "error". . . . . . . . 50
        11.4.3.2 Процедуры управления . . . . . . . . . . . 50
  11.5. Тексты определяющих модулей библиотек . . . . . . . 50
     11.5.1. Текст библиотеки defBMD. . . . . . . . . . . . 50
     11.5.2. Текст библиотеки defScreen . . . . . . . . . . 50
     11.5.3. Текст библиотеки defFont . . . . . . . . . . . 50
     11.5.4. Текст библиотеки BMG . . . . . . . . . . . . . 50
     11.5.5. Текст библиотеки BMT . . . . . . . . . . . . . 50
     11.5.6. Текст библиотеки Screen. . . . . . . . . . . . 50
     11.5.7. Текст библиотеки Fonts . . . . . . . . . . . . 50
.PAGE
.HEAD 1 '@U                        СТРУКТУРА ЭТОЙ И ДРУГИХ КНИГ О КРОНОСЕ@u'
.HEAD 0 '@U                        СТРУКТУРА ЭТОЙ И ДРУГИХ КНИГ О КРОНОСЕ@u'
.HEAD 2 ''
.HEAD 3 ''
            СТРУКТУРА ЭТОЙ И ДРУГИХ КНИГ О КРОНОСЕ


                                          Структура этого тома

     Том,  который вы держите в руках, состоит, собственно, из
трех книг.
     Первую  книгу  -  "Кронос  для  начинающих" - мы адресуем
читателям,  не  имеющим  опыта  работы  на  других машинах и в
других  системах.  В  этой  книге  они  найдут  самые  первые,
начальные  сведения  о Кроносе и программировании. Кроме того,
сюда   вошли  определения  некоторых  понятий  и  обозначения,
принятые в ОС Excelsior.

     Вторая  книга  -  "Кронос для всех" - является фактически
руководством  по  операционной системе Excelsior, и рассчитана
на  программистов,  знакомых  с  другими  системами  или  с ОС
Excelsior по первой книге.

     Книга третья - "Кронос не для всех" - содержит информацию
о внутреннем устройстве ОС Excelsior, системы программирования
Модула-2  и  о том, как все это ложится на Кронос-архитектуру.
Эта  информация  предназначается  разработчикам  компиляторов,
отладчиков,  потенциальным  администраторам  системы,  а также
всем тем, кому это интересно.

     В  Приложении  читатель  найдет примеры программ на языке
Модула-2.   Мы  постарались  максимально  проиллюстрировать  с
помощью  этих  примеров  работу на Кроносе, поэтому Приложение
будет  полезно  как  начинающим,  так  и  выросшим  до  уровня
администратора системы программистам.
     Том снабжен глоссарием, который позволяет быстро получить
ссылки на разделы по ключевым словам.


                                      Что еще читать о Кроносе

     Помимо  этой, основной, на наш взгляд, книги, имеются еще
четыре.  "Архитектура процессоров семейства КРОНОС" - содержит
общие  сведения  об  архитектуре  и  системе команд Кроноса, а
также  интерпретатор  М-кода  на языке Модула-2. Кроме того, в
этом   томе   вы   найдете  фрагменты  программ  на  Модуле-2,
иллюстрирующие систему команд семейства.
     Две  следующие  книги  -  справочного  характера. В книге
"Библиотеки   ОС   Excelsior"  вы  найдете  общие  сведения  о
библиотеках  и назначении каждой из них. Собственно справочная
часть  включает  тексты  определяющих модулей всех библиотек с
подробными  комментариями  об  использовании каждой процедуры.
Книга   "Утилиты   ОС   Excelsior"  является  справочником  по
утилитам.  Описания всех утилит следуют в алфавитном порядке и
содержат  всю  необходимую  информацию  для  того,  чтобы даже
неподготовленный  программист  мог  воспользоваться  утилитой:
порядок   запуска,  этимологию  названия,  действие,  варианты
использования и примеры.
     Последняя  книга  носит  специальный  характер, поскольку
адресована  непосредственно  администратору системы. Она так и
называется:   "Кронос  для  администратора".  Это  руководство
поможет  администратору выполнять все действия, понимаемые под
выражением  "поддержка  системы",  начиная  с запуска тестовых
программ  в момент, когда Кронос только распакован и включен в
сеть,   и  кончая  написанием  драйверов  специальных  внешних
устройств,  подключаемых  по  желанию пользователей. Поскольку
поддержка  системы  -  дело  нешуточное,  этот  том оформлен в
соответствии   с   нормативными  требованиями  Единой  Системы
Программной Документации.
.PAGE
.HEAD 0 ''
.HEAD 1 ''




















                         Книга первая
                 ОС Excelsior ДЛЯ НАЧИНАЮЩИХ
.PAGE
.HEAD 1 '@U                                           КОРОТКОЕ ВСТУПЛЕНИЕ@u'
.HEAD 0 '@U                                           КОРОТКОЕ ВСТУПЛЕНИЕ@u'
.HEAD 2 ''
.HEAD 3 ''
.TAIL 0 '@U%62x@u'
.TAIL 1 '@U%62x@u'
.TAIL 2 'ОС Excelsior ДЛЯ НАЧИНАЮЩИХ%35d'
.TAIL 3 'ОС Excelsior ДЛЯ НАЧИНАЮЩИХ%35d'
                         Кронос,  в  древнегреческой мифологии
                    титан,  сын  Урана  (Неба)  и Геи (Земли).
                    Уран,  боясь  погибнуть от одного из своих
                    детей,  возвращал  их снова в недра земли.
                    Поэтому   Гея,  изнемогавшая  от  бремени,
                    уговорила  Кроноса, родившегося последним,
                    оскопить   Урана.  Кронос  стал  верховным
                    богом.  Испугавшись  предсказания  матери,
                    что он в свою очередь будет свергнут одним
                    из   сыновей,  Кронос  проглатывал  детей,
                    рожденных  ему  сестрой  Реей,  пока ей не
                    удалось  спрятать  от  Кроноса и вырастить
                    втайне   Зевса.  Возмужав,  Зевс  заставил
                    Кроноса  изрыгнуть  проглоченных им детей,
                    составивших  поколение олимпийских богов,а
                    сам  Кронос  и  другие титаны, побежденные
                    Зевсом,  были заключены в Тартар. По более
                    позднему     варианту     мифа,     Кронос
                    впоследствии  был  переселен  на  "острова
                    блаженных". Отсюда в представлении древних
                    греков  "царство  Кроноса" соответствовало
                    сказочному   "золотому   веку".   Считаясь
                    первоначально    богом    жатвы,    Кронос
                    изображался  старцем  с покрытой головой и
                    серпом в руке.
                         Позднейшее  представление  о Кроносе,
                    как  о  боге  времени, возникло вследствие
                    созвучия  имени  Кронос и греческого слова
                    "хронос" - "время".

                                        Из русских и советских
                                     энциклопедических изданий


     Теперь,     когда     законное    любопытство    читателя
удовлетворено,   можно   начинать   рассказ  о  Кроносе  и  об
операционной   системе   Excelsior,  под  управлением  которой
работает Кронос.
     Эта  книжка похожа на слоеный пирог. Каждый может выбрать
для   себя  наиболее  подходящий  слой.  Опытный  программист,
работавший  на  разных  машинах  и  в  разных системах, скорее
всего, выберет слой, бегло знакомящий читателя с соглашениями,
принятыми  в  ОС Excelsior.
     Для  другого  программиста, возможно, ОС Excelsior станет
первой  системой,  которая научит его работать, а эта книжка -
первым   путеводителем   в  науку  программирования  (computer
science).
     Многие,   работая  на  Кроносе,  ощущают  его  как  живое
существо.  Как хорошо, когда это существо тебя понимает, и как
нелегко  -  понять  его. Наша цель - научиться разговаривать с
Кроносом.
.PAGE
.HEAD 1 '@UДИАЛОГ С КРОНОСОМ                                   КЛАВИАТУРА@u'
.HEAD 0 '@UДИАЛОГ С КРОНОСОМ                                   КЛАВИАТУРА@u'
.HEAD 2 ''
.HEAD 3 ''
                  Часть 1. ДИАЛОГ С КРОНОСОМ


                                 Глава 1.1. Клавиатура и экран



     Для  общения  с  Кроносом необходимы две вещи: клавиатура
(чтобы  вы  могли говорить) и экран (чтобы вы могли видеть его
ответ).

     1.1.1. Курсор

     На  экране  почти  всегда  можно  найти  ярко  светящийся
прямоугольник.  Это курсор. Он указывает ту позицию на экране,
на  которой  вы  сейчас  "находитесь".  Если  теперь нажать на
клавишу   "А",   на  том  месте,  где  был  курсор,  возникнет
изображение  символа  "А",  а  сам курсор переместится на одну
позицию вправо.
     При   нажатии   некоторых   клавиш   никакие  символы  не
появляются,   а   происходит  что-нибудь  другое  -  например,
перемещается  курсор.  Это  зависит  от того, какую клавишу вы
нажали - литерную или управляющую.


     1.1.2. Литеры

     Литерные  клавиши  - это те, при нажатии которых на экран
выдается какой-нибудь печатный символ: ABcd @#$ !* пЮЪЙ.
     Литеры  бывают  прописные  (ABCАБВ)  и строчные (abcабв),
кириллица  (АБВгде)  и  латиница (ABCdef). ОС Excelsior все их
различает  и  понимает.  В  системе используются две кодировки
символов.  Для  латиницы  кодировка ASCII-8 (American Standard
for Information Interchange), для кириллицы - КОИ-8. Кодировку
каждой  клавиши  можно  узнать  с помощью утилиты ascii (см. в
томе "Утилиты ОС Excelsior").


     1.1.3. Управляющие клавиши

     Управляющие   клавиши  -  клавиши,  при  нажатии  которых
терминал отрабатывает какие-либо функции.
     Терминалы   (и  клавиатуры)  бывают  разные,  и  на  всех
работает  одна и та же система. Везде в дальнейшем описании мы
будем  пользоваться  некоторыми  условными  названиями кнопок.
Каждой такой кнопке соответствует какое-либо действие. Где они
расположены   на   вашей   клавиатуре,   вы  можете  узнать  у
администратора системы.


     1.1.4. Контрольные символы

     Этот раздел можно прочитать потом.
     Кроме  основных функциональных клавиш, используются еще и
контрольные   символы   -  символы,  полученные  одновременным
нажатием  клавиши  CTRL  и  литеры.  Заметим,  что  при наборе
контрольного   символа   на   клавиатуре   не  происходит  его
высвечивания   на  экране.  Кроме  того,  не  имеет  значения,
набирать   контрольный   символ  с  прописной  буквой  или  со
строчной.  Можно  набирать  его  с  включенным регистром РУС -
результат   будет  одинаков.  В  дальнейшем  будем  обозначать
контрольные символы CTRL_<ЛИТЕРА>.

     Некоторые контрольные символы имеют особую интерпретацию.
Среди  них:

     CTRL_C - прекращение текущей задачи;
     CTRL_X - открепление текущей задачи;
     CTRL_S - останавливает  процесс  вывода на терминал;
     CTRL_Q - возобновляет вывод на терминал;
     CTRL_Z - переключает режимы вставки/замены.

     Такая  интерпретация контрольных символов сохраняется при
любой  работе  с терминалом - в частности, в редакторе текстов
'ex' (см. главу про редактор).
.PAGE
.HEAD 1 '@UДИАЛОГ С КРОНОСОМ                               ВХОД В СИСТЕМУ@u'
.HEAD 0 '@UДИАЛОГ С КРОНОСОМ                               ВХОД В СИСТЕМУ@u'
.HEAD 2 ''
.HEAD 3 ''

                                     Глава 1.2. Вход в систему


                         -   Так,  значит,  тут  разыгрывается
                    Настоящая Шахматная Партия?! И целый мир -
                    шахматная   доска.   Если,   конечно,  это
                    настоящий  мир.  Как  здорово!  Как  бы  я
                    хотела   туда   попасть!   И...   и  стать
                    пешкой... если позволят! Хотя БОЛЬШЕ ВСЕГО
                    НА СВЕТЕ я хотела бы стать Королевой.

                                 Л.Кэрролл. Алиса в Зазеркалье


     1.2.1. Приглашение к работе

     Сядьте   поудобней   и  посмотрите  на  экран.  Если  все
работает,  то  вы  увидите  на  экране  приглашение. Например,
такое:

17:55 usr

     Не  огорчайтесь, если приглашение выглядит совсем не так.
Просто  это  не ваше приглашение. Чтобы приглашали именно вас,
попросите  администратора  вашей машины зарегистрировать вас в
системе и завести для вас рабочую директорию.
     Как  правило,  вас  регистрируют  под  каким-то (разумной
длины)  именем или иным милым вашему сердцу буквосочетанием. С
этого  момента  система  знает,  что  вы  являетесь  одним  из
пользователей,  со  всеми вытекающими отсюда последствиями. Вы
имеете  право войти в систему и получить доступ к определенной
информации;  в свою очередь, вы можете хранить свою информацию
и    определять   степень   ее   доступности   для   остальных
пользователей.  Кроме  того,  вы  можете  создать  себе  свою,
отличную  от  окружающей,  обстановку  и  работать  в  ней.  В
частности, установить любое понравившееся вам приглашение.


     1.2.2. Как войти в систему


                         -  Уважаемый Гладиолус, как жаль, что
                    ты не можешь сказать ни слова.
                         -   Отчего   же,   могу,  -  вымолвил
                    Гладиолус.   -   Могу,   если  рядом  есть
                    кто-нибудь, кто этого ЗАСЛУЖИВАЕТ.

                                 Л.Кэрролл. Алиса в Зазеркалье

     После  того,  как  машину  включили  и произошла загрузка
системы, на экране появляется надпись

username:

     Наберите   на   клавиатуре   то   имя,  под  которым  вас
зарегистрировали  в  системе.  Затем  найдите  главную кнопку,
которая  называется ENTER, а может быть, CR (Carriage Return),
или  ВК  (Возврат Каретки) - зависит от клавиатуры, на которой
вы работаете. Нажмите ее. После этого на экране появится слово

password:

     Это  значит,  что  вы должны набрать ваш пароль. Если имя
или   пароль   набраны   неверно  (а  исправления  при  наборе
запрещены),  вам  предложат попытаться набрать пароль еще пару
раз.  Если  вы снова ошибетесь (или имя было набрано неверно),
то после некоторой задержки опять появится надпись

username:

и все начнется сначала.

     Когда, наконец, имя и пароль набраны правильно, на экране
должно  появиться ваше приглашение. Если это произошло, то все
в  порядке:  можно  начинать  знакомство.
.PAGE
.HEAD 0 '@UДИАЛОГ С КРОНОСОМ                             КОМАНДНАЯ СТРОКА@u'
.HEAD 1 '@UДИАЛОГ С КРОНОСОМ                             КОМАНДНАЯ СТРОКА@u'
.HEAD 2 ''
.HEAD 3 ''

                                   Глава 1.3. Командная строка


     Диалог  с ОС Excelsior ведется с помощью командных строк.
Командная  строка  -  набор  символов,  завершающийся нажатием
клавиши  ENTER.
     Ведущие   пробелы   в   командной   строке  игнорируются;
следующие  за командной строкой пробелы отсекаются. Количество
пробелов между словами несущественно.
     Командная строка должна содержать только одну команду.
     Набранную командную строку можно редактировать.


     1.3.1. Редактирование командной строки

     Самая  важная  клавиша - ENTER (Carriage Return - Возврат
Каретки).  Именно она завершает набор каждой командной строки.
Неважно,  в  какой  позиции строки при нажатии ENTER находился
курсор  -  будет  введена  вся  командная  строка от начала до
конца.
     Ввод  командной  строки  с  "обрубанием"  хвоста (то есть
всего того, что находится правее курсора) осуществляет клавиша
LF  (Line  Feed  - Перевод Строки - ПС). На клавиатуре рабочей
станции  это  кнопка  с  букавами  SysReq.  Возможно,  кому-то
покажется более удобным пользоваться именно этой клавишей.
     Дальше идут стрелки (ARROWS):

     LEFT            - переход на символ влево;
     RIGHT           - переход на символ вправо.

     Клавиши  HOME  и  END  осуществляют  переходы на начало и
конец строки.

     Можно возвратить содержимое предыдущих командных строк. В
памяти  хранятся  одновременно 16 команд (15 предыдущих и одна
текущая,  то  есть  та,  которая  набирается в данный момент),
которые  можно  перебирать,  двигаясь назад и вперед с помощью
стрелок UP и DOWN:

     UP              - переход вверх на строку;
     DOWN            - переход вниз на строку.

     Другие полезные клавиши:

     TAB               - табуляция  (переход  на  8  символов)
                         вправо;
     BACK TAB          - табуляция влево;
     InsCh             - вставка  символа  с подвижкой  хвоста
                         строки вправо;
     DelCh             - удаление символа  с  подвижкой  конца
                         строки влево;
     BACKSPACE         - замена  символа  слева  на  пробел  с
                         переходом на него курсора.


     1.3.2. Режимы вставки и замены

     Можно  вводить  символы  в  так называемом режиме замены,
когда  слово,  набираемое  поверх  другого слова, заменяет его
(как на пишущей машинке).
     Можно,  наоборот,  пользоваться  режимом  вставки. В этом
случае  при  наборе  поверх  старого  слова  вновь  набираемые
символы  пишутся  не вместо него, а перед ним, отодвигая хвост
строки все дальше вправо.
     Заметим, что сами разработчики предпочитают второй режим.
Для того, чтобы сменить режим редактирования, нажмите CTRL Z.


     1.3.3. Переход в режим кириллицы

     Для  того, чтобы перейти с латиницы на кириллицу, нажмите
последовательно  левую,  а  затем  правую  кнопку  SHIIFT  (на
клавиатуре  она  обозначена  стрелкой  вверх). Для перехода на
латиницу эти кнопки нажимаются в обратной последовательности.
.PAGE
.HEAD 1 '@UФАЙЛОВАЯ СИСТЕМА                          КОРНИ И ВЕТВИ ДЕРЕВА@u'
.HEAD 0 '@UФАЙЛОВАЯ СИСТЕМА                          КОРНИ И ВЕТВИ ДЕРЕВА@u'
.HEAD 2 ''
.HEAD 3 ''

            Часть 2. ФАЙЛОВАЯ СИСТЕМА ОС Excelsior


                               Глава 2.1. Корни и ветви дерева

                         Forest  лес  # Совокупность деревьев;
                    удаление   корневой   вершины   превращает
                    дерево в лес.

                                                  А.Борковский
                                         Англо-русский словарь
                             по программированию и информатике


     Тексты  и  коды  программ,  статьи  и  эта книжка - одним
словом,   вся  информация,  с  которой  работает  программист,
хранится на магнитных носителях в файлах.


     2.1.1. Файл

     Файл - это набор информации, имеющий имя; он представляет
собой  последовательность  байтов  на  носителе (байт = 8 бит;
например, код ASCII-символа занимает в точности один байт).

     2.1.2. Директория

     Директория  - специальный вид файла; содержит список имен
других  файлов  и  указание  на  их  местоположение в файловой
системе.
     Файловая   система   ОС   Excelsior   имеет   древовидную
структуру.   Корневой   директорией   называется   файл-корень
файлового дерева.

     2.1.3. Носитель

     Носитель  -  единица  совместного хранения файлов (обычно
диск  или дисковый пакет), устанавливаемая на любое подходящее
устройство.
.PAGE
.HEAD 1 '@UФАЙЛОВАЯ СИСТЕМА                                     ИМЯ ФАЙЛА@u'
.HEAD 0 '@UФАЙЛОВАЯ СИСТЕМА                                     ИМЯ ФАЙЛА@u'
.HEAD 2 ''
.HEAD 3 ''


                                          Глава 2.2. Имя файла


                         - А для чего вообще нужны имена?
                         - Понятия не имею, - ответил Комар. -
                    Дальше  в  лесу есть такое место, где ни у
                    кого нет имени.

                                 Л.Кэрролл. Алиса в Зазеркалье


     У  каждого  файла  есть имя, которое дается файлу при его
создании.   Имя   файла   -  последовательность  символов,  за
исключением символов " " (пробел), "/" (косая черта) и символа
с кодировкой 0. Все остальные символы можно использовать, хотя
использование  некоторых  символов приводит к неудобствам. Для
начала  рекомендуем  пользоваться  только печатными символами.
Смысл  этих  ограничений  станет  ясен позже. Имя файла должно
быть не длиннее 32 символов. Например:

     my_file   @@@   2*2=4 и так далее.


     2.2.1. Расширители имен файлов

     Часто  имена  файла  снабжаются расширителем. Расширитель
имени  файла  -  последовательность литер, отделяемая от имени
символом  "." (точка). Например: util.doc - расширитель - doc.
Существуют   также   стандартные   расширители  для  некоторых
специальных  файлов, принятые в ОС Excelsior.
     .d  -  расширитель  для  файла,  содержащего определяющий
модуль (DEFINITION MODULE);
     .m  -  расширитель  для  файла,  содержащего  реализующий
модуль (IMPLEMENTATION MODULE);
     .cod - расширитель для файла, содержащего код модуля;
     .sym - расширитель для симфайла;
     .ref - расширитель для реффайла.

     Заметим,  что  директориям  не  принято  давать  имена  с
расширителями.


     2.2.2. Полное имя файла

     Местоположение    каждого   файла   в   файловом   дереве
определяется последовательностью директорий, которые требуется
пройти  системе  до этого файла. Точкой отсчета при этом может
быть  как  текущая  директория, так и корневая директория. Это
позволяет ввести понятие полного имени файла. Полное имя - имя
файла  с  указанием  маршрута к этому файлу от корня файлового
дерева:

<полное имя файла> ::= ["/"]{<директория>"/"}<имя файла>

Например:
     /doc/util1.doc
     /users/andy/ccScan.m
     /bin/StdIO.cod

     Кроме того, местоположение файла можно определить, указав
маршрут   до  него  от  текущей  директории.  Итак,  определим
маршрут:

<маршрут> ::= [ "/" | "." ] { ".."/ } { <директория>"/"}

Замечание. Возможно, читатель удивится, увидев слово "маршрут"
           вместо  привычного  слова "путь". Leopold предложил
           использовать   именно   этот  термин  во  избежание
           путаницы  (что не удалось переводчикам документации
           по  ОС  UNIX).  А  что  такое путь в ОС Excelsior -
           читайте дальше.


     2.2.3. Соглашения об именах

     В  ОС  Excelsior  приняты  следующие  соглашения для имен
файлов:
     -  имена  директорий  в полном имени разделяются символом
"/" (косая черта);
     - именем  корневой директории является строка "/";
     - имя  текущей  директории  обозначается  символом  "."
(точка);
     -  имя родительской директории обозначается символом ".."
(две  точки),  который можно повторить несколько раз, двигаясь
при этом к корню файлового дерева.
.PAGE
.HEAD 1 '@UФАЙЛОВАЯ СИСТЕМА                  ПРОГУЛКИ ПО ФАЙЛОВОМУ ДЕРЕВУ@u'
.HEAD 0 '@UФАЙЛОВАЯ СИСТЕМА                  ПРОГУЛКИ ПО ФАЙЛОВОМУ ДЕРЕВУ@u'
.HEAD 2 ''
.HEAD 3 ''


                       Глава 2.3. Прогулки по файловому дереву


                         Сунул я руку в карман, вытащил горсть
                    гаек.  Показал  их  Кириллу  на  ладони  и
                    говорю:
                         -   Мальчика   с   пальчик   помнишь?
                    Проходили  в  школе?  Так вот сейчас будет
                    все  наоборот.  Смотри!  - и бросил первую
                    гаечку.  Недалеко  бросил,  как  положено.
                    Метров на десять. Гаечка прошла нормально.
                         - Видел?
                         - Ну? - говорит.
                         - Не "ну", а видел, я спрашиваю?
                         - Видел.
                         - Теперь  самым малым веди "галошу" к
                    этой  гаечке  и  в  двух  метрах до нее не
                    доходя остановись, понял?

                                    А.Стругацкий, Б.Стругацкий
                                             Пикник на обочине



     Для  перехода  на  другую  директорию служит команда 'cd'
(cHANGE  dIRECTORY).  Команде  необходимо  указать  маршрут до
новой директории.

     cd  ["/"|"."] {"../"} {<директория>"/"} <имя_директории>

     Например:

     cd
     -  показывает  маршрут  до  текущей  директории  от корня
     файлового дерева;

     cd ..
     - переход на директорию, содержащую текущую;

     cd /
     - переход на корневую директорию;

     cd ../../users/my
     -  переход  на директорию my, расположенную на директории
     users.

     Заметим,  что  'cd'  является  командой  пользовательской
оболочки  shell, о которой можно почерпнуть подробные сведения
в разделе "SHELL: ПОЛЬЗОВАТЕЛЬСКАЯ ОБОЛОЧКА ОС".
.PAGE
.HEAD 1 '@UФАЙЛОВАЯ СИСТЕМА                                СОЗДАНИЕ ФАЙЛА@u'
.HEAD 0 '@UФАЙЛОВАЯ СИСТЕМА                                СОЗДАНИЕ ФАЙЛА@u'
.HEAD 2 ''
.HEAD 3 ''



                    Глава 2.4. Создание и редактирование файла


     2.4.1. Запуск редактора

     Чтобы  создать новый текст, требуется создать новый файл.
Новые  файлы  создаются  с  помощью  редактора  текстов  'ex'.
Редактор запускается так:

     ex <имя_файла> [-ключ]

     Ключ   у   редактора  только  один  -  'w'.  Он  означает
"запретить запись в файл", то есть файл открывается только для
чтения (о ключах см. раздел 8.1).
     Если  редактор  не  находит  файла  с  таким  именем,  то
сообщает об этом и после вашего подтверждения нажатием клавиши
ENTER  создает новый файл. Если вы передумали, нажмите CTRL C,
и файл не будет создан.


     2.4.2. Как выйти из редактора

     Если  вы  закончили набирать или исправлять текст, то для
того,  чтобы  выйти  из  режима редактирования и сохранить все
ваши исправления, нажмите одновременно CTRL и e (^E).
     Если    вы    хотите,   чтобы   прежний   текст   остался
неисправленным, или вам не требуется сохранить набранный файл,
выходите из редактора без записи, набрав ^C. После этого у вас
запросят подтверждение, и после Y или y (yes) произойдет выход
из  редактора.  Если  вы  вдруг  передумали, наберите N или n,
чтобы остаться в редакторе.


     2.4.2.1. Полезный совет

                         -  Мне  никогда, никогда не забыть, -
                    заявил Король, - это кошмарное мгновенье!
                         -  Ты  непременно  о  нем забудешь, -
                    сказала Королева, - если не запишешь его в
                    записную книжку.

                                 Л.Кэрролл. Алиса в Зазеркалье

     Во избежание потерь при неожиданном сбое полезно время от
времени  записывать  набираемый  текст.  Это можно сделать, не
выходя  из редактора. Нажмите последовательно кнопки F10 и w -
и ваш текст спасен на диск.


     2.4.3. Экран

     Вы  находитесь  в редакторе. Перед вами чистая страница -
экран, который вы можете заполнять по своему усмотрению.
     В  нашей  системе  экранное  редактирование  построено по
принципу  "что  на  витрине,  то  и в магазине", иначе говоря,
программист  имеет ровно то, что видит на экране. Для примера:
редактор   не  делает  различия  между  пробелами,  набранными
клавишей  SPACE, и пробелами, получившимися с помощью TAB. Как
на  экране,  так  и  в  файле  это будут просто пробелы. То же
относится и ко всяческим контрольным символам - если символ не
изображен  на  экране,  программист может быть уверен, что его
нет и в редактируемом файле.

     Самая нижняя строка экрана - информационная. Она выглядит
приблизительно так:

<<<SCREEN 10:14 INS off  BELL on  3:59 p.m.  0071 FILE x.m >>>

     Первые  два  числа  в  информационной  строке - положение
курсора  на  экране  (номер  строки,  считая  сверху,  и номер
знакоместа,  считая  слева,  разумеется,  с  нуля). Далее идет
сообщение, включен ли режим вставки (INS on - включен, INS off
-  выключен).  Затем  - сообщение, включен ли звуковой сигнал,
затем  -  текущее  время  (post  meridiam или ante meridiam, в
зависимости  от  времени суток), далее - номер строки в файле,
на  которой  находится  курсор, и, наконец, имя редактируемого
файла.
     В   процессе   редактирования  могут  выполняться  разные
действия  - например, запись редактируемого файла на диск, или
форматирование  текста,  и  всякий раз сообщение о выполняемом
действии появляется в информационной строке.


     2.4.4. Клавиатура

     Литерные  клавиши  в текстовом редакторе работают так же,
как и в однострочном командном редакторе.
     Редактору  приходится  работать  с  самыми разными типами
терминалов  (Фрящик,  Видеотон, Mera, Labtam, Elorg и т.д.), с
разными  клавиатурами  и  разными  названиями  клавиш  на них.
Поэтому, как мы уже условились раньше, рассказ будет вестись в
терминах функциональных кнопок.


     2.4.4.1. Драгоценные кнопочки

     Кроме  обычных  управляющих  кнопок, в редакторе выделены
три  кнопки  с  условными названиями GOLD, SILVER, BRONZE. Эти
кнопки  меняют  смысл  кнопки,  которая  нажата  после них. На
клавиатуре   рабочей   станции   это   кнопки   F1,F10   и  F2
соответственно. С кнопкой SILVER вы уже частично знакомы. (F10
'w' - запись вашего текста на диск без выхода из редактора).
     Кнопка  GOLD  (F1)  предназначена для "усиления" действия
следущей  кнопки,  то  есть  она  является  точкой  опоры  для
переворачивания мира. Например:
        F1 "стрелка вправо"   - переход на конец строки;
        F1 "стрелка влево"    - переход на начало строки;
        F1 PageUp             - переход на начало файла;
        F1 PageDn             - переход на конец файла.

     Кроме этого, кнопка F1 поможет вам быстро набирать тексты
программы  и  выполнять поиск и замену кусков текста (когда вы
доберетесь до соответствующих разделов книги "ОС Excelsior для
всех").
     Кнопка  F2 предназначена в основном для ваших собственных
расширений возможностей редактора.
     Подробности обо всем этом можно узнать из документации по
редактору  или  с  помощью  утилиты  "help". А пока перечислим
действия всех управляющих кнопок вашей клавиатуры.


     2.4.4.2. Перемещения по тексту

переход вверх на строку                        UP
переход вниз на строку                         DOWN
переход на символ влево                        LEFT
переход на символ вправо                       RIGHT
табуляция вправо                               TAB
табуляция влево                                BACK TAB
переход  на 16 строк вверх                     PageUp
переход  на 16 строк вниз                      PageDw
переход на начало текущей строки               Enter
со стиранием хвоста текущей строки             SysReq

     2.4.4.3. Вставка и удаление

вставка  символа  с подвижкой  хвоста          InsCh
строки вправо
удаление символа  с подвижкой  хвоста          DelCh
строки влево
замена  символа  слева  на  пробел  с          BACKSPACE
переходом на него курсора
удаление хвоста строки                         F8
удаление      хвоста     строки     с          F4
приклеиванием хвоста следующей
вставка  строки с отламыванием хвоста          F3
на следующую строку
отмена последнего DelLn                        F1 F2


     2.4.4.4. Операции над строками

дублирование хвоста строки                     F7
обмен хвостов вверх от курсора                 F5
обмен хвостов вниз от курсора                  F6
склеивание строк                               F1 F4
разрыв строки                                  F1 F3
дублирование хвоста  поверх следующей          F1 F7
строки


     2.4.4.5. Операции над единицами текста

переход к началу  слова                        F1 UP
                                               (F2 LEFT)
переход к концу слова                          F1 DOWN
                                               (F2 RIGHT)
удаление слова                                 F1 DelCh

переход к началу строки                        F1 LEFT
                а также                        Home
переход за конец строки                        F1 RIGHT
                а также                        End
переход на конец текста                        F1 PageDw
переход к началу текста                        F1 PageUp

форматирование текущего абзаца                 F10 1
центрирование заголовка                        F10 2

возврат к первоначальному содержимому          BRONZE F1
строки


     2.4.4.6. Выход в другие режимы редактора

командный режим                                F1 F1
установка параметров (SETUP-монитор)           F1 F10
вход   в  shell  редактора  (выход -           F10 PgDn
ESC)


     2.4.5. Возможности редактора

     После  того, как вы освоитесь с клавиатурой, переходите к
к ознакомлению с возможностями редактора.
     Редактор располагает следующими возможностями:

     - позиционирование в файле;
     - поиск в файле;
     - контекстная замена;
     - работа с файлами (переименование и пр.);
     - работа с областью текста;
     - установка макросов;
     - установка параметров редактирования;
     - форматирование абзаца и области текста;
     - запуск задач из shell редактора.

     Подробное описание всего этого дается в книге "Утилиты ОС
Excelsior", глава 'ex'.
     Редактор  - достаточно сложный инструмент. Чтобы овладеть
им  в  совершенстве,  нужно не только понять, как он работает,
изучить  его  функции, но и привыкнуть к нему настолько, чтобы
пользоваться  его  возможностями не раздумывая, автоматически.
На это потребуется некоторое время, как требуется время, чтобы
научиться игре на музыкальном инструменте.
.PAGE
.HEAD 1 '@UЗАДАЧИ ДЛЯ КРОНОСА                                ЗАПУСК ЗАДАЧ@u'
.HEAD 0 '@UЗАДАЧИ ДЛЯ КРОНОСА                                ЗАПУСК ЗАДАЧ@u'
.HEAD 2 ''
.HEAD 3 ''
                 Часть 3. ЗАДАЧИ ДЛЯ КРОНОСА


                                       Глава 3.1. Запуск задач


     Для запуска любой задачи в ОС Excelsior достаточно просто
набрать на экране ее имя (с соответствующими параметрами, если
они  есть).  Именем  задачи служит имя кодового файла (файла с
расширителем '.cod') программного модуля задачи. Вот как будет
выглядеть   запуск  задачи  "my_task",  находящейся  на  вашей
рабочей директории, скажем, "wrk":

     /users/vasya/wrk/my_task

     Приходится   набирать  довольно  длинную  строчку,  чтобы
указать  системе,  с  какой именно директории она должна взять
коды  задачи.  Но  полное имя указывать не обязательно, если у
вас установлен путь поиска кодофайлов.


     3.1.1. Путь поиска кодофайлов

     Этот пункт можно пропустить при первом чтении.

     Умея  определять  местоположение  файла, можно установить
очередность  маршрутов при поиске файлов для запуска программ.
Это  позволит  вместо  полного  имени файла указывать лишь его
имя,  даже  если  файл  лежит  на  удаленной директории или на
другом носителе.

     Путь,  на  которых  будут  разыскиваться коды запускаемой
задачи, устанавливается так:

     BIN='"'[.] [..] {{'/'<имя_директории>}' '} '"'

     Теперь  задана последовательность полных имен директорий,
на которых надо искать коды загружаемой программы, например:

     BIN=" . .. /ii/моя_дир"
     - файл будет разыскиваться сначала на текущей директории,
затем - на директории, содержащей текущую, затем на директории
'/ii/моя_дир'.

     Можно узнать ранее установленный путь, набрав команду

     set

     Кроме   всего   прочего,  в  строчке  "BIN"  команда  set
показывает установленный путь.


     3.1.2. Как запустить задачу


     Итак, для запуска задачи достаточно указать имя кодофайла
ее головного модуля:

     my_task

и, если таковой будет найден на какой-нибудь из указанных пуем
директорий, задача начнет исполняться.

Заметим, что если на текущей директории имеются файлы name.cod
(кодофайл)  и  name.@ (командный файл с тем же именем, главу о
командных файлах), то команда

     name

     приведет  к  исполнению  командного  файла  name.@,  а не
задачи  с  кодофайлом  name.cod.  Как  обойти это препятствие?
Очень  просто:  запуская  задачу,  укажите  имя ее кодофайла с
расширителем:

     name.cod


     3.1.3. Как остановить задачу

     Исполнение текущей задачи можно прервать нажатием CTRL_C.
Разумеется,  есть  задачи,  которые  так  просто  не  прервешь
(например,  пользовательская  оболочка 'sh', которую запускает
администратор  системы). Случаям, когда CTRL_C "не действует",
посвящена специальная глава в книге "ОС Excelsior для всех".


     3.1.4. Стандартный ввод-вывод

     Запуская  какую-либо  задачу  (утилиту,  пользовательскую
программу),  вы  ожидаете  вывода  ее  результатов.  Некоторые
задачи  требуют ввода дополнительной информации. Многие задачи
пользуются  стандартным  вводом-выводом,  который по умолчанию
открыт на терминал, с которого была запущена задача.
     Вывод  может быть направлен в файл. Для этого при запуске
требуется  указать  имя файла, куда будут записаны результаты,
предварив его символом '>':

     <имя_задачи> '>'<файл_результатов>

- результат записывается в указанный файл.

     Если  в  файле  лежала  какая-то  информация,  она  будет
удалена. Чтобы этого не произошло, можно дописать результаты в
файл с помощью значка '>>':

     <имя_задачи> '>>'<файл_результатов>

- результат дописывается в указанный файл.


     Ввод тоже может осуществляться из файла с помощью '<':

     <имя_задачи> '<'<файл_ввода>


     3.1.5. Параллельное исполнение задач

     В  ОС  Excelsior  есть  возможность  запустить  несколько
(число  зависит  от  потребностей  задачи  в  ресурсах)  задач
одновременно.   С   точки   зрения  операционной  системы  они
совершенно  равноправны  с  задачей, запускаемой "явно". После
завершения "фоновая" задача освобождает выделенные ей ресурсы.
Для  обозначения  таких  задач  существуют  разные  термины  -
параллельная,  открепленная,  независимая  и  т.д..  Мы  будем
использовать, пожалуй, последний.


     3.1.5.1. Запуск независимой задачи

     Запуск выглядит так:

     <имя_задачи> &

     После  этого  вы  можете  запускать  следующую  задачу  в
"явном"  виде,  ее исполнение не будет мешать исполнению ранее
запущенной  задачи.
     Вам  следует лишь позаботиться о выводе результатов, если
результатом  является,  например, печать на экран, чтобы вывод
не мешал вашей работе с "явной" задачей.
     Открепить уже исполняющуюся задачу можно нажатием CTRL_X.


     3.1.5.2. Перечень задач

     Можно  ознакомиться  с  перечнем  всех задач, исполняемых
компьютером  в  данный  момент. Это делается с помощью команды
shell'а ps:

     ps

На экран будет выдано приблизительно следующее:

     0066    run  ex            shell.doc
     0043    run  shell

     В первой колонке указан номер задачи, в третьей - ее имя.
Полное  описание  команды  ps  дается  в  разделе, посвященном
пользовательской оболочке ОС, в книге "Кронос для всех".


     3.1.5.2. Прекращение исполнения независимой задачи

     Прекратить исполнение можно командой shell'а kill :

     kill [<номер задачи>]

, например:

     kill 1031
или
     kill

Если  номер  задачи не указывать, то вам предложат на удаление
все ваши (запущенные на текущем терминале) задачи.
.PAGE
.HEAD 1 '@UЗАДАЧИ ДЛЯ КРОНОСА                                     УТИЛИТЫ@u'
.HEAD 0 '@UЗАДАЧИ ДЛЯ КРОНОСА                                     УТИЛИТЫ@u'
.HEAD 2 ''
.HEAD 3 ''


                                            Глава 3.2. Утилиты


     Выше  нам  уже  пришлось  употребить  слово "утилита", не
поясняя его значения. Утилита - это программа, предназначенная
для  выполнения какого-нибудь действия (или последовательности
действий).  Точным  переводом этого слова было бы "пользилка".
Утилиты  могут  иметь  самые разные назначения: бывают утилиты
для работы с файлами, для работы с устройствами, и редактор, с
помощью  которого  редактируются тексты, и Модула-компилятор -
тоже утилиты. Попросту говоря, утилиты - это приспособления, с
помощью  которых  программист  имеет  доступ  к операционной и
файловой  системам и т.д..


     3.2.1. Ключи

     Обычно  утилита  выполняет  не  одно, а несколько сходных
между собой действий. Выполняемое действие зависит от ключа, с
которым   запущены   утилита.  Так,  например,  утилита  'ls',
запущенная  без  ключей,  выдает  на  экран  имена  файлов  на
указанной  путем  директории,  кроме скрытых файлов (например,
с расширителями .sym, .ref и .cod).

     Будучи запущена с ключом -a

     ls -a

ls выдает имена ВСЕХ файлов, в том числе скрытых.

     ls -l

выдает имена файлов в "длинном формате", то есть с указанием
обширной информации о каждом файле, например:

--rwxr-x---  1        968  Jan 18  13:08   a.m

Это значит, что на текущей директории находится только один файл
a.m  c  указанными  битами  защиты,  привязанный к одному имени,
длиной 968 байт, последнее изменение внесено 18 января в 13.08.
     И так далее.

     Кроме  символьных,  существуют  еще  числовые ключи. С их
помощью  утилите  можно  передавать числовые параметры. Пример
числового ключа:

     where *.cod a=161288
-   утилита   находит   все   кодофайлы,   запись   в  которые
производилась после 16.12.1988.


     3.2.2. Запуск утилиты

     Таким образом, запуск утилиты выглядит так:

запуск ::=
<имя_утилиты> {<параметр>} {<числовой_ключ>} ['-'/'+'{<ключ>}]

<параметр>      ::= <строка>
<числовой_ключ> ::= <строка>'='<число>
<ключ>          ::= <строка>

     Заметим,   что   все   параметры  и  ключи  утилит  могут
располагаться в командной строке в произвольном порядке.


     3.2.3. Подсказка

     Набор  утилит относительно стабилен, но может пополняться
за  счет  ваших  собственных полезных программ, если они будут
соответствовать стандарту, принятому в ОС Excelsior.
     В  частности, этот стандарт требует, чтобы каждая утилита
имела  ключ  'h',  по  которому она выдает краткую подсказку о
себе самой (назначение и ключи).
     Подробнее  об  этом и об утилитах вообще рассказывается в
томе "Утилиты ОС Excelsior", который здесь тоже упоминался.

     Помимо того, что каждая утилита выдает краткую информацию
о  себе по ключу 'h', существует еще утилита, ведающая службой
подсказки  в  ОС  Excelsior.  Эта  утилита оказывает на первых
порах  большую  помощь, она  так и называется - help. Запустив
help,  вы  попадаете в меню, состоящее из названий всех утилит
системы  (а также команд shell - пользовательской оболочки). О
каждой  утилите  вы  можете  получить  полную  информацию - от
порядка  запуска и этимологии названия до ключей и примеров ее
употребления.  О  том,  как  пользоваться  help, подскажет она
сама.
.PAGE
.HEAD 1 '@UЗАДАЧИ ДЛЯ КРОНОСА                              КОМАНДНЫЙ ФАЙЛ@u'
.HEAD 0 '@UЗАДАЧИ ДЛЯ КРОНОСА                              КОМАНДНЫЙ ФАЙЛ@u'
.HEAD 2 ''
.HEAD 3 ''


                                     Глава 3.3. Командный файл

     Несколько   командных   строк  могут  быть  объединены  в
командный  файл,  который  создается с помощью редактора и при
запуске  выполняется,  как  если  бы  его  строки были набраны
последовательно   с  терминала.  Имя  командного  файла  имеет
расширитель @:

     <имя_файла>.@


     3.3.1. Запуск командного файла

     Запуск  командного  файла  осуществляется  набором  имени
файла:

     <имя_файла>

     Если  на  одной директории находятся кодофайл и командный
файл  с  одним  и  тем  же  именем,  то при наборе имени файла
запустится кодофайл. Избежать путаницы можно, набрав имя
файла с расширителем:

      my_file.@

- будет исполняться командный файл;

      my_file.cod

- исполнится кодофайл.


     3.3.2. Прекращение командных файлов

     Исполнение командного файла прекращается нажатием CTRL_C.
При этом прекращаются все запущенные в нем задачи.

     3.3.3. Соглашения для командных файлов

     Для командных файлов приняты следующие соглашения:

     1) строка комментария предваряется символом % ;

     2) параметры, передаваемые командному файлу, обозначаются
$1, $2, ..., $9. Например, если командный файл user.@ выглядит
так:

     cd /users
     cd $1

, то $1 при исполнении командного файла заменяется на переданный
ему параметр:

     user ВАСЯ

, что равносильно последовательности команд

     cd /users
     cd ВАСЯ


     3.3.4. Пример командного файла

     Приведем пример командного файла:

% Командный файл архивирования

% Смонтировать диск fd0 на директорию /mnt:
mou /mnt /dev/fd0

% Скопировать все изменившиеся и недостающие файлы на всех
% поддиректориях текущей директории на архивную директорию
% с сохранением имен файлов и созданием недостающих
% директорий

cp .//$1 /mnt/$@/$1 -qdb

% Демонтировать диск с директории /mnt:
mou /mnt -r

% Конец архивирования


     3.3.5. Командный файла пользователя

     На  вашей  приватной  директории  хранится командный файл
profile.@.  Такой  файл  предназначается  для перехода на вашу
рабочую  директорию,  установку  удобных  для  вас  параметров
командной   строки.   Выглядит   он  приблизительно  так:
% Установить путь поиска кодофайлов:
BIN=". /usr/flm/bin /bin /usr/bin"

% Установить путь поиска  командных файлов:
ETC=". /usr/flm/bin /etc /usr/etc"

% Установить приглашение:
PROMPT="%t %/> "

% Перейти на директорию wrk:
cd wrk

%                   Mы гостям хорошим рады,
%                   Смело в дом входите,
%                   Вытирайте ноги, гады,
%                   Чистоту блюдите.

     Запуск   командного   файла  пользователя  осуществляется
системой после входа в систему.
     Если  вы  меняли  обстановку  работы,  и  вам после этого
захотелось  домой, в свою родную обстановку, наберите команду,
которая так и называется: home - домой, указав, где именно ваш
дом:

     home /usr/ВАСЯ

Если  на  указанной  вами  директории  обнаружится  ваш личный
"profile",  он  будет  исполнен,  и  вы  окажетесь  у  себя на
директории в привычной обстановке.
.PAGE
.HEAD 1 '@UСОЗДАНИЕ ПРОГРАММ                             О ЯЗЫКЕ МОДУЛА-2@u'
.HEAD 0 '@UСОЗДАНИЕ ПРОГРАММ                             О ЯЗЫКЕ МОДУЛА-2@u'
.HEAD 2 ''
.HEAD 3 ''
                  Часть 4. СОЗДАНИЕ ПРОГРАММ

                         Программирование    -   это   процесс
                    исправления  старых  ошибок  и  насаждения
                    новых.

                                                  А.Борковский
                                             Из частной беседы


                                   Глава 4.1. О языке Модула-2


     Автором  языка  Модула-2 является Никлаус Вирт, профессор
Высшей  Технической  Школы  (Цюрих), который реализовал его на
своей  машине  Лилит.  Унаследовав лучшие черты языка Паскаль,
Модула-2  имеет ряд отличительных особенностей, которые делают
ее незаменимой при разработке программного обеспечения. Прежде
всего  это,  конечно,  модульность  (и  возможность  разбиения
модуля   на   определяющую   и  реализующую  части),  развитые
структуры данных и управления, строгий контроль типов, наличие
процедурных  типов,  что позволяет динамически параметризовать
процедуры   внешними   действиями,  а  также  наличие  средств
программирования  низкого уровня, позволяющих ослабить жесткий
контроль типов и отображать структурные данные на память.
     Знание  Модулы-2  на  уровне  языковых конструкций еще не
дает  возможности  существенно  использовать  ее преимущества,
поэтому,   прежде   чем   писать  тексты  программ,  тщательно
ознакомьтесь  с  описанием  языка.  Лучше всего это сделать по
книжке "Программирование на языке Модула-2" Н.Вирта в переводе
В.А.Серебрякова    и    В.М.Ходукина,   выпущенной   в   серии
"Математическое обеспечение ЭВМ" издательством "Мир" в 1987 г.
     Все дальнейшее изложение будем вести в предположении, что
вы знакомы с языком.
.PAGE
.HEAD 0 '@UСОЗДАНИЕ ПРОГРАММ                                   БИБЛИОТЕКИ@u'
.HEAD 1 '@UСОЗДАНИЕ ПРОГРАММ                                   БИБЛИОТЕКИ@u'
.HEAD 2 ''
.HEAD 3 ''


                      Глава 4.2. Как пользоваться библиотеками


     4.2.1. Модульность и библиотеки

     Коль  скоро  вы  собираетесь работать на Кроносе и писать
свои  программы  на Модуле-2, нет смысла убеждать вас в пользе
модульности.  И  все  же  скажем  несколько  слов  о  том, как
отразилось  это свойство на системе программирования, а именно
ее части, именуемой библиотеками стандартных процедур.
     Возможно,   модульность   не  имела  бы  такого  большого
значения  для  системы программирования, если бы на Кроносе не
было  динамической  загрузки кодов модулей, из которых состоит
программа.   При   динамической   загрузке,   в   отличие   от
статической,  отсутствует этап сборки (линкования), то есть не
требуется   создание   на   диске  образа  задачи,  в  котором
содержатся коды всех модулей, составляющих эту задачу. Поэтому
оказалось   удобным  некоторые  наиболее  часто  употребляемые
процедуры  объединить  в  модули,  при  инициализации  которых
"ничего   не  происходит",  то  есть  не  исполняются  никакие
действия.  Такие  модули  служат  только  для  импорта  из них
процедур  и называются библиотеками. Коды библиотечных модулей
хранятся  на диске в единственном экземпляре и, следовательно,
многочисленные   копии   процедур   не  загромождают  дисковое
пространство.    Кроме    того,    этими   процедурами   можно
пользоваться,   как   строительными  блоками,  не  заботясь  о
внутреннем  устройстве блоков. А вновь создаваемое программное
обеспечение   автоматически   пополняет  арсенал  строительных
средств.
     Итак,  библиотеки
     а) экономят дисковое пространство;
     б) ускоряют написание программы  в  сотни  раз;
     в) позволяют не изобретать велосипед;
     г) дают возможность писать свои программы чужими руками.


     4.2.2. Назначение и название

     За  время существования ОС Excelsior написано, упразднено
и  переписано  заново множество библиотек. Чтобы овладеть всем
этим   богатством,  необходимо  знать  его.  Лучший  способ  -
изучение   определяющих   модулей   библиотек   с   подробными
комментариями.   Все   это   можно  найти  в  справочном  томе
"Библиотеки  ОС  Excelsior".  Там  же  приводится  список всех
библиотечных  модулей  с  указанием  их назначения.
     Для начала рекомендуем ознакомиться с библиотеками StdIO,
Strings,  Image,  Args, Streams. В этих библиотеках содержатся
все   процедуры,  которые  могут  понадобиться  для  написания
простых программ.


     4.2.3. StdIO - стандартный вывод

     Наиболее  необходимая  библиотека  (во всяком случае, для
начинающих)  - библиотека стандартного вывода StdIO. С помощью
ее  процедуры  print  можно  вывести  информацию  в  указанном
формате   в   так  называемый  файл  стандартного  вывода.  По
умолчанию   это  экран,  но  вывод  может  быть  перенаправлен
стандартным способом (см. в главе 7 раздел 3).
     Остановимся на этой процедуре подробно.

PROCEDURE print(format: ARRAY OF CHAR; SEQ args: WORD);

     Первый  аргумент  этой  процедуры  -  формат,  в  котором
требуется   вывести   перечисленную  далее  последовательность
аргументов. Конструкция SEQ (о реализованных расширениях языка
Модула-2  см. выше п.10.3) означает перечисление произвольного
числа аргументов (возможно, ни одного).

     Например,
     print("Hello, hacker!")
напечатает строчку
     Hello, hacker!
Последовательность аргументов у процедуры опущена.

        -format-  задается  строкой  ASCII-8 символов (и тогда
   заключается, естественно, в кавычки " или '), или строковой
   переменной (и тогда байт 0с означает конец строки).
        Все  символы  строки  выдаются в стандартный вывод без
   изменения,   за  исключением  некоторых  символов,  которые
   процедура   print  интерпретирует  специальным  образом.

   1. Символ \ интерпретируется следующим образом:
        \n отрабатывается как CR+LF.
        \r отрабатывается как CR.
        \l отрабатывается как LF.
        Если  в  строке  требуется  символ '\', предварите его
   '\': '\\' преобразуется в просто '\'.
        ВНИМАНИЕ!  \n,  \r,  \l обрабатываются ТОЛЬКО в строке
   -format-, но не в строках-аргументах!!!

   2.  Символ % и следующие за ним интерпретируются процедурой
   как  формат,  в  котором  требуется вывести соответствующий
   аргумент процедуры из последовательности аргументов.
        Если  требуется  символ  '%', предварите его '%': '%%'
   преобразуется в просто '%'.
        Таким  образом,  формат  начинается  символом %, далее
   идут модификаторы, а завершается формат базой. Формат может
   встречаться  в  строке -format- несколько раз (возможно, ни
   разу).

   формат         ::= %{ модификатор }база.

   модификатор    ::= ( space | "$" | "-" | "+" | "#" | ширина
                        | точность } .
   ширина         ::= цифра { цифра } | "*".
                    - задает  общую(!)  ширину  поля (с учетом
                      возможных  символов  основания,  знака и
                      т.п.);     если     указанной     ширины
                      недостаточно      для      представления
                      выводимого      значения,     происходит
                      автоматическое    расширение   поля   до
                      минимально   необходимого.
   точность       ::= "." цифра { цифра } | ".*" .
                    - задает   число  значащих  цифр  после(!)
                      запятой в форматах 'f','e','g' или число
                      символов строки в формате 's';

        Замечание.   Если  вместо  спецификации  ширины  и/или
   точности  указаны  '*', то значения ширины и точности нужно
   указать  в соответствующих аргументах, при этом соблюдается
   следующий   порядок:   сначала   аргумент-строка,   которую
   требуется вывести, а затем аргументы-модификаторы.
        Замечание.  Значения  точности и ширины должны быть из
   диапазона  [0..255];  в  противном  случае  они принимаются
   равными значению по умолчанию.

   #                - показывает  число  с указанием основания
                      (например:   image(s,"%$10#h",12abcdefH)
                      эквивалентно image(s,"012ABCDEFh") );
   -                - число пишется слева в поле установленной
                      ширины;
   +                - показывает  число  со знаком, независимо
                      от знака числа;
   $   (zero)       - дополнить до нужного количества разрядов
                      ведущими нулями;
   space            - выставляется     знак,     если    число
                      отрицательное, иначе пробел;

   база           ::= ("d"|"h"|"x"|"b"|"o"|"s"|"c"|"{}"|"i"
                       |"f"|"e"|"g").
   d   (Decimal)       - десятичное;
   h,H (Hexidecimal)   - шестнадцатеричное
                         (h,x -- "A".."F" прописные);
   x,X (Hexidecimal)   - эквивалентно 'h'
                         (H,X -- "a".."f"  строчные);
   b,B (Octal)         - восьмеричное;
   o,O (Octal)         - эквивалентно 'b';
   s,S (String)        - строка;
   c,C (Char  )        - одиночный символ;
   {}  (set)           - битсет;
   i,I (bIn)           - двоичное;
   f,F (Float)         - вещественное число в формате:
                           [+|-]dddddddd.ddddd
                             |__  n1  __|_ t _|
                      Число  цифр  до  запятой n1 - минимально
                      необходимое   для  представления  числа.
                      Число  цифр  после  запятой t - задается
                      точностью (по умолчанию 6).
   e,E (Exponent)   - вещественное число в формате:
                        [+|-]d.ddddddE(+|-)dd    или
                        [+|-]D.DDDDDDe(+|-)DD
                      Число цифр до запятой 1.
                      Число цифр после  запятой - t - задается
                      точностью (по умолчанию 6).
                      (формат 'e' - 'E' в результате;
                      формат 'E' - 'e' в результате);
   g,G (General)    - вещественное   число   в  формате:  если
                      FLOAT(TRUNC(число))=число,  то в формате
                      dddddd;  иначе  в  формате 'f' или 'e' -
                      какой короче.

   ЗАМЕЧАНИЕ.
   Модификаторы  '$' и '-',   естественно, не совместимы.
   Модификаторы  '+' и space, естественно, не совместимы.
   Модификатор точность может быть использован только с базами
   's','f','e','g'.
   Модификаторы  '+'  и space могут быть использованы только с
   базами 'i','f','e','g'.
   Модификаторы  '$', '+' и space НЕ могут быть использованы с
   базами  's','{}','c'.


     11.3.1. Примеры употребления процедуры print


     Изложение примеров будем вести в следующей форме:

--------------------------------------------------------------
                               |
        Текст программы        |       Будет выведено
                               |
--------------------------------------------------------------
                               |


     1) Примеры без аргументов


print("Hello, hacker!\n");     |  Hello, hacker!
                               |
print("Hello, "0c"hacker!");   |  Hello,
                               |
print("Hello,\nhacker!");      |  Hello,
                               |  hacker!
                               |
print("Hello,\lhacker!");      |  Hello,
                               |        hacker!
                               |
VAR h: ARRAY [0..79] OF CHAR;  |
  h:= "Hello!"                 |
  print(h);                    |  Hello!
                               |
                               |

     2) Примеры с аргументами


VAR n1,n2                      |
    : ARRAY [0..79] OF CHAR;   |
BEGIN                          |
  n1:="Вася!"                  |
  n2:="Петя!"                  |
  print("Hello, %s\n",n1);     |  Hello, Вася!
  print("Hello, %s\n",n2);     |  Hello, Петя!
                               |

     3) C использованием модификатора "ширина"

                               |
VAR str: ARRAY [0..79] OF CHAR;|
BEGIN                          |
  str:="Вася!"                 |
  print("Hello, %10s\n",str);  |  Hello,      Вася!
                               |
                               |
VAR str: ARRAY [0..79] OF CHAR;|
    i : INTEGER;               |
BEGIN                          |
  str:="Вася!"                 |
  i:= 10;                      |
  print("Hello, %*s\n",str,i); |  Hello,      Вася!
                               |
                               |
.PAGE
.HEAD 0 '@UСОЗДАНИЕ ПРОГРАММ                                   КОМПИЛЯЦИЯ@u'
.HEAD 1 '@UСОЗДАНИЕ ПРОГРАММ                                   КОМПИЛЯЦИЯ@u'
.HEAD 2 ''
.HEAD 3 ''


                                         Глава 4.3. Компиляция


     Наконец   текст   вашей  программы  готов.  Чтобы  Кронос
исполнил    программу,    нужно    представить   ее   в   виде
последовательности машинных команд (каких именно - см. в книге
"Архитектура  семейства  процессоров  КРОНОС" описание системы
команд). Функцию перевода текста программы на языке Модула-2 в
последовательность команд осуществляет Модула-2 компилятор.
     Кроме этой основной задачи, компилятор выполняет еще одну
важную  функцию  - он проверяет правильность текста программы,
сообщая о синтаксических и семантических ошибках (какие именно
ошибки "отлавливает" компилятор, видно из п.12.3).
     В  этой  главе  мы  изложим  только  начальные сведения о
компиляции.     Более     подробно     мы    остановимся    на
Модула-компиляторе в книге "ОС Excelsior для всех".


     4.3.1. Запуск  компилятора

     Запуск  компилятора  осуществляется с помощью утилиты mx,
либо   с   помощью  компилирующего  редактора  ex,  который  в
дальнейшем  мы будем называть по аналогии с TURBO-PASCAL фирмы
Borland турбо-компилятором, или просто турбиной. Он отличается
от    текстового    редактора   возможностью   откомпилировать
программу,  текст  которой вы редактируете в данный момент, не
записывая  его  на  диск и не покидая редактора. В этом случае
компиляция  запускается последовательным нажатием клавиш F10 и
m.
     Модула-компилятору     передается     текст    программы,
оформленный в соответствии с описанием языка. В системе принят
стандартный   расширитель   для   имени   файла,   содержащего
определяющий  модуль - .d ; реализующий или программный модуль
-  .m  .  Если  расширитель  отсутствует, компилятор добавляет
расширитель .m : program.m.
     Сначала  компилируют  определяющий  модуль, если он есть,
затем - реализующий и только потом программный.
     Если   программа   состоит   из  нескольких  модулей,  то
компилируют   сначала   все   определяющие   модули,  а  затем
реализующие.


     4.3.2. Что получается в результате компиляции

     В  результате компиляции определяющего модуля (DEFINITION
MODULE)  получается  символьный  файл  (симфайл) и файл ссылок
(реффайл);   реализующего  модуля  (IMPLEMENTATION  MODULE)  -
реффайл   и   кодовый  файл  (кодофайл);  программного  модуля
(MODULE) - реффайл и кодофайл.
     В  симфайле  содержится  информация  для  компилятора;  в
реффайле  -  для  отладочных  утилит (например, для утилиты hi
(history),  выдающей историю последнего неудавшегося процесса.
Кодофайл содержит собственно исполняемый код программы.
     Имена  симфайлов,  реффайлов  и  кодофайлов получаются из
имени  модуля  (не  из  имени  файла) добавлением расширителей
'.sym',  '.ref'  и  '.cod'  соответственно.
     Обратите  внимание,  что  обнаружить симфайлы, реффайлы и
кодофайлы  на  директории  с  помощью  утилиты  ls  можно лишь
запустив  ее  с  ключом  -a  (all).


     4.3.3. Сообщения компилятора

     Компилятор  выдает на русском языке сообщение о характере
ошибки,  приводится  номер  строки  и  сама  строка, в которой
допущена  ошибка,  а также помечается предположительно место в
строке,  где  надо  искать  ошибку (в случае турбо-компилятора
происходит  последовательное позиционирование курсора на место
ошибки), например:

     Ожидался символ ';'
       104:   PROCEDURE Next(i,j: INTEGER$, A: ARRAY OF CHAR);
     Число ошибок: 1

     Если в процессе компиляции не обнаружено ошибок, на экран
выдается сообщение:

     lines 247  time 09cp + 11io   help.cod  326 words

,  что  означает,  что  был  скомпилирован модуль размером 247
строк,  время  компиляции  9 секунд, время записи - 11 секунд,
кодофайл записан в файл help.cod и объем кода 326 слов.
     В  результате  компиляции  на текущей директории появятся
файлы help.ref и help.cod.


     4.3.3.1. Для турбо-компилятора

     Если  вы  запустили  компиляцию  из  турбины,  компилятор
сообщит   количество   ошибок  и  спозиционируется  на  первой
встреченной  ошибке,  указав ее характер. После ее исправления
перейти  к  следующей  ошибке  можно последовательным нажатием
клавиш F10 и +.
     После того, как все ошибки исправлены и компиляция прошла
успешно, не забудьте записать текст программы (F10 w).
