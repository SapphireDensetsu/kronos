.TAIL 0 '@U%62x@u'
.TAIL 1 '@U%62x@u'
.TAIL 2 '%62d'
.TAIL 3 '%62d'
.HEAD 0 ''
.HEAD 1 ''































                         Книга вторая

                    ОС Excelsior ДЛЯ ВСЕХ

.PAGE
.HEAD 0 '@U                                   ПЕРВОЕ ПРЕДИСЛОВИЕ СОАВТОРА@u'
.HEAD 1 '@U                                   ПЕРВОЕ ПРЕДИСЛОВИЕ СОАВТОРА@u'
.HEAD 2 ''
.HEAD 3 ''
.TAIL 0 '@U%62x@u'
.TAIL 1 '@U%62x@u'
.TAIL 2 'ОС Excelsior ДЛЯ ВСЕХ%35d'
.TAIL 3 'ОС Excelsior ДЛЯ ВСЕХ%35d'


                 ПЕРВОЕ ПРЕДИСЛОВИЕ СОАВТОРА


                         Разумеется,  книга  эта  не  могла бы
                    появиться  на  свет без поддержки и помощи
                    некоторых  людей.  Говорю  я  об  этом для
                    того,   чтобы   ответственность   за   нее
                    разделить на всех поровну.

                           Д.Даррелл. Моя семья и другие звери


     Известно,   что   авторство   отличается  от  соавторства
приблизительно  тем же, чем пение от сопения. Тем не менее мне
пришлось  взять  на  себя  неблагодарную миссию быть соавтором
сразу  целой  группы  авторов  -  разработчиков  software  для
процессоров  Кронос.  Никто  не может лучше рассказать о своем
детище, чем его родитель. К сожалению, рядовому читателю редко
бывает  нужно  "лучше",  он  хочет  -  понятнее. Насколько мне
удалась скромная роль переводчика - судить читателю.
     Говорю  все это прежде всего для того, чтобы снять с себя
всякую  ответственность  за  написанное  здесь  (или  хотя  бы
частично   взвалить   ее   на   авторов).   Далее  в  подобных
предисловиях  будет  указано,  с кого именно спрашивать за тот
или иной раздел.

                                                       Соавтор

.PAGE
.HEAD 0 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ                     МОДУЛА-КОМПИЛЯТОР@u'
.HEAD 1 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ                     МОДУЛА-КОМПИЛЯТОР@u'
.HEAD 2 ''
.HEAD 3 ''

          Часть 5. СИСТЕМА ПРОГРАММИРОВАНИЯ МОДУЛА-2


                                          Предисловие соавтора


     За  эту часть надо спрашивать с А.Недори, который, к тому
же, является создателем Модула-компилятора для Кроноса.

                                                       Соавтор


     Система   программирования  Модула-2  представляет  собой
систему из четырех относительно независимых компонент:
     1) компилятора с языка Модула-2;
     2) универсального редактора текстов;
     3) средств отладки программ;
     4) набора библиотек стандартных процедур.

     Универсальному  редактору  текстов  посвящен  специальный
раздел.
     Набор  библиотек стандартных процедур, а также способы их
использования описаны в справочнике "Библиотеки ОС Excelsior".
     В  этом  разделе  описывается  то, что касается создания,
компиляции  и  отладки Модула-программ: версия языка Модула-2,
реализуемая   компилятором   "mx"  для  процессоров  семейства
Кронос,  ограничения  и  расширения  языка,  способы запуска и
структура   компилятора,  необходимое  компилятору  окружение,
визуализатор программ и посмертный историк.
.PAGE
.HEAD 0 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ              ВХОДНОЙ ЯЗЫК КОМПИЛЯТОРА@u'
.HEAD 1 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ              ВХОДНОЙ ЯЗЫК КОМПИЛЯТОРА@u'
.HEAD 2 ''
.HEAD 3 ''




                           Глава 5.1. Входной язык компилятора


     Язык  Модула-2  реализуется компилятором в соответствии с
сообщением о языке [5] и изменениями, внесенными Н.Виртом [2].
     Кроме того, реализованы некоторые расширения языка. Часть
изменений  была  внесена  в язык под влиянием дальнейших работ
Н.Вирта  [3]  и  Проекта  стандарта  языка  [4]. Компилятор не
соответствует  ISO-стандарту языка Модула-2, поскольку таковой
стандарт в данное время отстутствует.


     5.1.1. Ограничения компилятора

     Список  требований  к  компилятору  взят  из проекта [4].
Символом  '*'  помечены пункты, не соответствующие требованиям
проекта. В скобках () приведены рекомендации проекта.

*    - размер множеств не более 32 бита    (256, SET OF CHAR);
     - число параметров процедуры не более 256            (8);
     - число импортируемых модулей не ограничено         (32);
     - вложенность процедур и модулей не ограничена       (8);
     - вложенность описания записей   не ограничена     (256);
     - вложенность описания массивов  не ограничена     (256);
     - вложенность вызовов процедур   не ограничена     (256);
     - число альтернатив в операторе выбора не более 256(256);
     - длина идентификатора не ограничена               (256);
     - число экспортируемых объектов  не ограничено      (16);
     - длина строкового литерала не более 256            (80);
     - вложенность операторов не ограничена               (8);
     - размер перечислимого типа не ограничен           (128).

Примечание: параметры   типа  открытый  массив  (ARRAY  OF)  и
            параметры-последовательности       (SEQ-параметры)
            считаются за два параметра.

Дополнительные ограничения:

        - число параметров у кодовой процедуры не более 7.


     5.1.2. Изменения, внесенные в язык

     В  5.1.2.1 содержится краткий список изменений. В 5.1.2.2
приводится  описание изменений, внесенных в язык, базирующееся
на  Сообщении  [5]. Описание выдержано в стиле Сообщения [5] с
точностью до порядка нумерации разделов.
     Полный  синтаксис входного языка приведен в 5.1.2.3.
     Примеры  программ, демонстирующие расширения, приведены в
 5.1.6.

.HEAD 0 '@UВХОДНОЙ ЯЗЫК КОМПИЛЯТОРА                      СПИСОК ИЗМЕНЕНИЙ@u'
.HEAD 1 '@UВХОДНОЙ ЯЗЫК КОМПИЛЯТОРА                      СПИСОК ИЗМЕНЕНИЙ@u'
.HEAD 2 ''
.HEAD 3 ''

     5.1.2.1. Список изменений

     1) Неявная конкатенация строк.
     2) Дополнительный синтаксис комментария.
     3)   Отсутствуют   стандартные  типы  CARDINAL,  LONGINT,
LONGREAL.
     4)  Стандартный тип STRING.
     5)  Тип динамический массив.
     6)  Новые операции для целых "/" и REM.
     7)  Операция инвертирования множества.
     8)  Операции циклического сдвига.
     9)  Конструктор массивов.
     10) Передача параметров по доступу.
     11) Параметры-последовательности.
     12) Кодовые процедуры.
     13) Новые стандартные процедуры ASSERT, BITS, BYTES, LEN,
REF, NEW, DISPOSE, RESIZE.
     14) Переименование при импорте.
     15) Все, что касается процессов и сопрограмм, реализуется
средствами ОС, а не компилятора.
     16) Настраиваемая динамическая поддержка.

.HEAD 0 '@UВХОДНОЙ ЯЗЫК КОМПИЛЯТОРА                ДОПОЛНЕНИЯ К СООБЩЕНИЮ@u'
.HEAD 1 '@UВХОДНОЙ ЯЗЫК КОМПИЛЯТОРА                ДОПОЛНЕНИЯ К СООБЩЕНИЮ@u'
.HEAD 2 ''
.HEAD 3 ''

     5.1.2.2. Дополнения к Сообщению о языке Модула-2

Данный  пункт  содержит  описание  изменений  входного  языка,
базирующееся   на   Сообщении   [5].  При  описании  изменений
указывается   пункт   сообщения,  к  которому  оно  относится,
например,   <8.2.4>.  Если  описание  расширения  должно  быть
выделено  в  новый  пункт  по  логике построения сообщения, то
такой пункт помечается символом "*".


<3> Словарь и изображение

     2.  Внесены изменения в синтакис Целого (см. 5.1.2.3) для
того, чтобы описать изменения в следующем пункте.

     3.    Расширен    синтаксис    цепочки.    Цепочка   есть
последовательность  строк  и представлений литер, начинающаяся
со строки.

$   Цепочка = Строка  { Строка | ПредставлениеЛитеры }.
$   Строка  =    "'" { Литера } "'" | '"' { Литера } '"'.

Примеры:

    "Привет" 12c 15c 'читателю'
    '' 33c 'H' 33c 'J'

     4. Дополнительные зарезервированные слова:

     CODE
     DYNARR
     FORWARD
     REM
     SEQ
     VAL

     5.  Дополнительные  синтакисис  комментария:  от  "--" до
конца  строки.  Внутри  комментария  одного  вида  комментарий
другого вида не рассматривается.

Примеры:

1)
        -- (*
           i:=0; -- этот оператор не в комментарии;
        -- *)

2)
        (* -- *) i:=0;  -- и этот оператор не в комментарии.


<4> Описания и правила видимости

Отсутствуют стандартные идентификаторы:

     CARDINAL
     LONGINT
     LONGREAL
     VAL

Добавлены стандартные идентификаторы:

     ASSERT  (10.2.1*)
     BITS    (10.2.1*)
     BYTES   (10.2.1*)
     DISPOSE (10.2.2*)
     LEN     (10.2.1*)
     NEW     (10.2.2*)
     REF     (10.2.1*)
     RESIZE  (10.2.2*)
     STORAGE (14.2*)
     STRING  (6.9)


<6> Описание типов

Добавлен тип динамический массив (динмассив).


<6.1> Основные типы

Отсутствует типы CARDINAL, LONGINT, LONGREAL.


<6.8> Тип процедура

$    ТипПроцедура ╫ PROCEDURE [ СписокФормТипов ].
$    СписокФормТипов = "(" [[VAR] ФормТип
$        { "," [VAR] ФормТип } ] [ SEQ [VAR] КвалИдент ] ")"
$        [ ":" КвалИдент ].

Последний  параметр  в списке формальных параметров может быть
последовательностью параметров (см. <10.1>).


<6.9*> Тип динмассив

     Тип  динмассив  является  обобщением  типа  указателя  на
случай указателя на открытый массив.

$  ТипДинМассив = DYNARR OF Тип.

DYNARR OF T следует рассматривать как POINTER TO ARRAY OF T.

     Значение  типа  динмассив  состоит из дескриптора и тела.
Дескриптор   динмассива   содержит   два  поля   ADR  и  HIGH,
описывающие соотственно адрес начала массива и верхнюю границу
массива.  Динмассив  почти  всегда  ведет  себя  как  открытый
массив.  Значениями индекса могут быть целые числа (INTEGER) в
диапазоне от 0 до верхней границы.

     Стандартный тип STRING определяется следующим образом:

     STRING = DYNARR OF CHAR

Примеры:

     DYNARR OF CHAR
     DYNARR OF STRING

Примеры  использования  динмассивов  рассматриваются в 5.1.3 и
5.1.6. См. также пункты <8.1>, <10.2>.


<8> Выражения

В  <8.1>  рассматриваются изменения, касающиеся динмассивов, в
<8.2>   -   новые   операции.   Новый  пункт  <8.3*>  посвящен
конструкторам массивов.


<8.1> Операнды

     Если  структура  - динмассив D, то запись D[E] обозначает
элемент  D,  индекс  которого  - текущее выражение значения E.
Обозначение   вида   D[E1,E2,...En]  означает  то  же,  что  и
D[E1][E2]...[En]. Запись D^ означает дескриптор динмассива, то
есть  запись  с  двумя полями ADR и HIGH. Запись D^.f означает
поле f дескриптора D (f должно быть ADR или HIGH).

Примеры:

     str : STRING
     text: DYNARR OF STRING

     str[i]       (CHAR)
     text[i]      (STRING)
     text[i,j]    (CHAR)
     str^         (см. примечание)
     str^.ADR     (ADDRESS)
     str^.HIGH    (INTEGER)

Примечание: Каждому  типу  динмассива  соответсвует уникальный
            анонимный тип дескриптора вида:

            RECORD
              ADR : SYSTEM.ADDRESS;
              HIGH: INTEGER;
            END;


<8.2> Операции

     Введены  дополнительные операции типа умножения и унарная
операция  инвертирования  множества  (<8.2.3>). Операции REM и
"/"  для  целых  рассматривается  в <8.2.1>, а операции "<<" и
">>" в <8.2.5*>.

$ ОперацияТипаУмножения = "*" | "/" | DIV
                 | MOD | AND | REM | "<<" | ">>".

<8.2.1> Арифметические операции

     В соответствии с Проектом стандарта [4]  (см.  п.6.6.1.2
Проекта) введены целые операции "/" и REM  для целого деления
и взятия остатка соответственно.

Выполняются соотношения:

     (-x/y)=(-x/y)=-(x/y)            (для y#0)
     x=(x  /  y)*y+(x REM y)         (для y#0)
     x=(x DIV y)*y+(x MOD y)         (для y>0)

Результат  операции  x REM y определен при y#0 и является либо
нулем,  либо  целым числом, совпадающим по знаку с x и меньшим
по абсолютной величине, чем y.

Результат  операции  x  MOD  y  определен  при  y>0 и является
неотрицательным целым числом, меньшим y.

Примечание. Для  процессоров  Кронос  2.2  операции  DIV и MOD
            реализованы  некорректно  и эквивалентны операциям
            /, REM. Подробнее см. 5.1.4.2.


<8.2.3> Операции над множествами

     Унарная   операция   "-"  обозначает  побитовую  инверсию
множества. Результат операции имеет тип операнда.


<8.2.5*> Операции циклического сдвига

     Операции циклического сдвига ">>" и "<<". Левый операнд -
любого типа длиной 1 слово, правый  должен  быть типа INTEGER.
Тип результата операции ясен из таблицы:

        Тип левого операнда | Тип результата
        --------------------+---------------
            INTEGER         |  INTEGER
            BITSET          |  BITSET
            все остальные   |  WORD


<8.3*> Конструктор массивов

     Расширен  синтаксис множителя. В качестве множителя можно
использовать конструктор массива.

$   Множитель = .... | Конструктор.
$   Конструктор = ARRAY OF КвалИдент
$      "{" КонстВыражение { "," КонстВыражение } "}".

Конструктор  ARRAY  OF  T{E1,E2,...En}  обозначает константное
значение  массива  типа  ARRAY  [0..n-1]  OF  T, где n - число
выражений.  Тип  элемента  должен  быть  основным типом, типом
перечисления, диапазона или множества.

Пример:

     CONST
       array   = ARRAY OF INTEGER{ 1,2,3 }
       element = array[1];


<9.2>. Вызовы процедур

     Последним  формальным  параметром  процедуры  может  быть
параметр-последовательность  (SEQ-параметр). При вызове вместо
такого  параметра  может  быть  подставлена последовательность
фактических  параметров  любой  длины  (в том числе и пустая).
Каждый из этих фактических параметров должен быть обозначением
переменной  для случая последовательности переменных (SEQ VAR)
и  выражением  в  случае  последовательности  значений  (SEQ).
Совместимость как в случае обычных параметров.
     Вместо  последовательности  параметров  в качестве такого
SEQ-параметра     может     быть     подставлен     формальный
параметр-последовательность. При этом их типы должны совпадать
и признак VAR должен быть у обоих или у обоих отсутствовать.
     В  случае,  если  тип  параметра-последовательности  есть
WORD,  в  качестве  фактических  параметров можно использовать
параметры  любого  типа.  При  передаче структурных параметров
передается  их  адрес, а если параметр имеет тип динмассив, то
передается адрес массива (а не адрес дескриптора).


<9.2.1*> Вызов кодовых процедур

     При   вызове   кодовой  процедуры  фактические  параметры
вычисляются   в   соответствии   с   заголовком   процедуры  и
загружаются   на   стек.  Далее  выполняется  код,  полученный
текстуальной  вставкой  тела кодовой процедуры в место вызова.
Компилятор   не   контролирует   корректность  работы  кодовых
процедур со стеком.


<10>. Описание процедур

$    ОписаниеПроцедуры = ЗаголовокПроцедуры ";"
$          ( Блок | Код ) Идентификатор.
$    Код = CODE { КонстВыражение } END.
$    ЗаголовокПроцедуры = PROCEDURE Идентификатор
$          [ ФормальныеПараметры ].
$    Блок = { Описание } [ BEGIN ПослОператоров ] END.
$    Описание = CONST { ОписаниеКонстанты ";" } |
$               TYPE  { ОписаниеТипа ";" } |
$               VAR   { ОписаниеПеременной ";" } |
$               ОписаниеПроцедуры ";" | ОписаниеМодуля ";"
$               ЗаголовокПроцедуры ";" FORWARD ";".

     В соответствии с [2,4] разрешены предварительные описания
процедур.    Предварительное   описание   представляет   собой
заголовок  процедуры,  за  которым  следует  зарезервированный
идентификатор  FORWARD.  Полное описание процедуры, включающее
тело  процедуры,  должно  появиться в той же области действия,
что  и предварительное описание, и на том же уровне видимости.
Типы   формальных  параметров  у  предварительного  и  полного
описания процедуры должны быть совместимы, а в случае открытых
массивов совместимы должны быть базовые типы массивов.
     Введены   кодовые   процедуры.   Тело  кодовой  процедуры
представляет  собой  последовательность  байтов.  Каждый  байт
задается целым выражением в диапазоне 0..255. (см. <9.2>).
число параметров у кодовых процедур ограничено (см. 5.1.1).
     Запрещается  предварительное  описание кодовых процедур и
экспорт из определяющего модуля.


<10.2> Формальные параметры

$    ФормальныеПараметры =
$         "(" [ ФПСекция { ";" ФПСекция } ]
$          [ SEQ [ VAR ] Идентификатор ":" КвалИдент ] ")"
$          [ ":" КвалИдент ].
$    ФПСекция = [ VAR | VAL ] СписИдент ":" ФормТип.
$    ФормТип = [ ARRAY OF ] Квалидент.

     Введен  новый  способ  передачи  параметра  - передача по
доступу.  Этот  способ  передачи указывается только при полном
описании процедуры (нельзя использовать в процедурном типе и в
предварительном  описании  процедуры).  С  точки зрения вызова
передача  параметра по доступу эквивалентна передаче параметра
по  значению.  Формальный  параметр, переданый таким способом,
нельзя  модифицировать.  Присваивание  такому  параметру  (или
компоненте  параметра)  и  передача  его  по сслыке запрещены.
Структурный  параметр,  переданный  по доступу, не копируется,
что  позволяет  повысить  эффективность  процедуры и уменьшить
требования к памяти.

     Последний      параметр      процедуры     может     быть
параметром-последовательностью.   Такой  параметр  может  быть
передан   по  сслылке  (SEQ  VAR)  или  по  доступу, если  VAR
отсутствует.   Такой   формальный  параметр  внутри  процедуры
аналогичен  гибкому массиву.

     Параметр-последовательность  типа  T  может  быть передан
целиком  процедуре с формальным параметром-последовательностью
типа  T1,  если тип T совместим с типом T1 и способ передачи у
обоих  параметров  одинаковый  (оба  по  доступу  или  оба  по
ссылке).

     Снято  ограничение  на  поэлементное использование гибких
массивов.    Разрешены   присваивания   гибких   массивов   (и
параметра-последовательности)  целиком.  Компилятор  вставляет
динамические  проверки  того,  что длина массива в левой части
равна длине массива в правой части оператора присваивания. Для
литерных  массивов  размеры сравниваются не на равенство, а на
больше или равно.


<10.2> Стандартные процедуры

     В  <10.2.1*> описываются введенные стандартные процедуры,
в  <10.2.2*> - настраиваиваемые стандартные процедуры работы с
памятью,  в данном пункте описываются изменения в существующих
стандартных процедурах.

1.  У  процедуры  HALT  разрешен  необязательный параметр типа
INTEGER,  значение которого системно-зависимо. Вызов процедуры
HALT с параметром означает аварийное завершение задачи и может
приводить  к  действиям,  облегчающим отладку. Вызов процедуры
HALT  без  параметра  означает  нормальное  завершение задачи,
неотличимое   от  выполнения  возврата  из  нулевой  процедуры
головного модуля.

2.   Процедура  HIGH  может  применяться  к  массивам,  гибким
массивам и динмассивам. Результат имеет тип INTEGER и является
константой, если операнд имеет тип массив.

3. Процедура ORD возвращает результат типа INTEGER.

4.   Параметр   процедуры   SIZE   может   быть   произвольным
обозначением.   Результат   имеет   тип   INTEGER  и  является
константой,  если  операнд  не  является  гибким  массивом или
динмассивом.   Размер   выдается  в  единицах  адресации  (для
процессоров Кронос - в словах).

5. Отсутствует процедура VAL.


<10.2.1*> Дополнительные стандартные процедуры

1. ASSERT(BOOLEAN [ "," INTEGER]);

     Если   значение  первого  операнда  -  истина,  то  вызов
эквивалентен  пустому  оператору,  иначе  исполнение программы
завершается.  Второй  параметр  может отсутствовать, а если он
есть,  то  это  некоторая  дополнительная информация о причине
завершения. Например:
      ASSERT(adr=NIL,НетПамяти);
где НетПамяти - это константа ОС.

2. BITS( Обозначение | Тип )

     Аналогична  процедуре  SIZE, но выдает размер объекта или
типа в битах.

3. BYTES( Обозначение | Тип )

     Аналогична  процедуре  SIZE, но выдает размер объекта или
типа в байтах.

4. LEN(VAR x: ЛюбойМассив)

     Выдает  число  элементов  массива,  гибкого  массива  или
динмассива. Результат имеет тип INTEGER и является константой,
если операнд имеет тип массив.

5. REF(VAR x: T , T2 )

     T  -  произвольный тип, T2 должен быть типом указателя на
тип T (T2 = POINTER TO T). Выдает значение типа T2, являющееся
адресом объекта x.


<10.2.2*> Настраиваемые стандартные процедуры

     Стандартные процедуры работы с памятью выполняют операции
размещения,  освобождения указателей и динмассивов и изменения
размера   динмассивов.   В   описании  процедуры  используются
обозначения   P   -  для  произвольного  указателя,  D  -  для
произвольного    динмассива.    Перед    использованием   этих
стандартных   процедур   необходимо  настроить  их  с  помощью
описателя  динамической поддержки (см. <14.1*>). При настройке
задается   соответствие   между   стандартной   процедурой   и
процедурой,   определенной   пользователем,  которая  и  будет
вызываться при вызове стандартной процедуры.

1.   NEW(P)

     Выделение  памяти  для указателя размером SIZE(P). Должна
быть настроена процедура NEW.

     NEW(D [,N])

     Размещение  памяти  для  динмассива с числом элементов N.
После  вызова  верхняя  граница  динмассива  равна  N-1. Вызов
NEW(D)  эквивалентен  вызову NEW(D,0). При этом вызов NEW(D,N)
является   сокращением   следующего   действия:
     D^.HIGH:=-1; RESIZE(D,N).
Должна быть настроена процедура RESIZE.

2.   DISPOSE(P)

     Освобождение  памяти,  занятой  указателем.  Должна  быть
настроена процедура DISPOSE.

     DISPOSE(D)

     Освобождение  памяти, занятой динмассивом. При этом вызов
DISPOSE(D)  является  сокращением  вызова  RESIZE(D,0). Должна
быть настроена процедура RESIZE.

3.   RESIZE(D,N)

     Изменение размера динмассива. При N=0 эквивалентна вызову
процедуры  DISPOSE.  После  вызова  верхняя граница динмассива
равна   N-1.   Сохраняет  значения  элементов  динмассива  для
индексов  0..min(H0,N-1),  где H0 - верхняя граница динмассива
до  вызова  процедуры  RESIZE. Должна быть настроена процедура
RESIZE.


<11> Модули

     Приоритет для локальных модулей не реализован.

$    Импорт = [ FROM Идентификатор ] IMPORT СписИмпорта.
$    СписИмпорта = ИмпортСекция { "," ИмпортСекция }.
$    ИмпортСекция = [ Идентификатор ":" ] Идентификатор.

В   списке   импорта  разрешено  переименование  импортируемых
идентификаторов  (аналогично  [3]), что позволяет использовать
внутри   модуля   короткие   (удобные)   названия   для   этих
идентификаторов. Запись

  IMPORT  in: OUT;

означает,  что  объект,  видимый  вне  модуля  под именем OUT,
должен использоваться внутри модуля по имени in.

Пример:

    IMPORT  io: StdIO;

    io.Write('A'); -- обозначает StdIO.Write('A')


<12> Системно-зависимые возможности

     Модуль  SYSTEM  содержит типы WORD, ADDRESS и стандартную
процедуру   ADR.


<13> Процессы

     Операции   создания  процессов,  обработки  прерываний  и
переключения  процессов  реализованы  в  библиотечных модулях.
Поэтому  средства,  описываемые  в данном пункте Сообщения, не
реализованы.


<14> Единицы компиляции

$    Определение = CONST { ОписаниеКонстанты ";" } |
$               TYPE  { Идентификатор [ "=" Тип ] ";" } |
$               VAR   { ОписаниеПеременной ";" } |
$               VAL   { ОписаниеПеременной ";" } |
$               ЗаголовокПроцедуры ";".

     В определяющем модуле можно описывать переменные, которые
в  других модулях можно только читать (нельзя модифицировать).
Такие  переменные  называются  переменными  только  для чтения
(read only, или VAL-переменные). В реализующем модуле, который
соответствует   данному   определяющему,  использование  такой
переменной не отличается от использования обычных переменных.

     В заголовке программого и реализующего модуля допускается
указание  "приоритета".  Приоритет  модуля  - это целое число,
которое  записывается  в  порожденный  компилятором кодофайл и
используется исполняющей системой в соответствии со стандартом
ОС (см. 5.1.4).

$    ПрограммныйМодуль = MODULE Идентификатор
$        [ Приоритет ] ";" { Импорт }
$        { Описание | ДинПоддержка }
$        [ BEGIN ПослОператоров ] END Идентификатор ".".

Среди описаний в программном и реализующем модулях разрешается
использование    определения   динамической   поддержки   (см.
<14.1*>).


<14.1*> Динамическая поддержка

$   ДинПоддержка = WITH Идентификатор
$        ( ":" КвалИдент |  "(" СписСоответствий ")" ).
$   СписСоответствий = Соответствие { ";" Соответствие }.
$   Соответствие = Идентификатор ":" КвалИдент.

     Понятие  динамической поддержки определяет набор процедур
(и,  может  быть,  других  объектов), которые компилятор будет
использовать  при  генерации  некоторых конструкций языка. При
этом  указывается  стандартный  идентификатор - имя раздела, а
затем   следует   указание   соответствий   или   имя  модуля,
содержащего необходимые объекты со стандартными именами.
     В  текущей  версии  языка  (и компилятора) определен один
раздел    динамической   поддержки   -   STORAGE,   содержащий
настраиваемые операции работы с памятью.


<14.1*> Динамическая поддержка работы с памятью

     Три   стандартные   процедуры   (см.  <10.2.2*>)  требуют
определения динамической поддержки для раздела STORAGE.

NEW: Настраивается процедурой типа
     PROCEDURE (VAR ADDRESS, INTEGER);
,где  второй  параметр  определяет  размер  требуемой памяти в
словах.

DISPOSE: Настраивается процедурой типа
     PROCEDURE (VAR ADDRESS, INTEGER);
После вызова первый параметр равен NIL.

RESIZE: Настраивается процедурой типа
           PROCEDURE (VAR ADDRESS,
                      VAR INTEGER,
                          INTEGER,
                          INTEGER);
Первый параметр - адрес массива, второй - его верхняя граница,
третий  - требуемая длина, четвертый - размер элемента массива
в байтах.

     При сокращенной настройке указывается имя модуля, который
содержит   процедуры   с   именами:   ALLOCATE,  DEALLOCATE  и
REALLOCATE.  Эти  процедуры должны иметь типы, описанные выше.
Часть  процедур  может отсутствовать, при этом соответствующая
стандартная  процедура  будет  не определена. Все операции над
динмассивами  реализуются  компилятором  посредством процедуры
REALLOCATE.     Соответственно,     программа,    использующая
динмассивы, должна содержать настройку для процедуры RESIZE.

Пример:

     WITH STORAGE (NEW: Storage.ALLOCATE; DISPOSE: dealloc);
     WITH STORAGE: Heap;


.HEAD 0 '@UВХОДНОЙ ЯЗЫК КОМПИЛЯТОРА                             СИНТАКСИС@u'
.HEAD 1 '@UВХОДНОЙ ЯЗЫК КОМПИЛЯТОРА                             СИНТАКСИС@u'
.HEAD 2 ''
.HEAD 3 ''
     5.1.2.3. Синтаксис входного языка

     Приведен синтакис Модулы-2 из [5] дополненый расширениями
языка. Символом '*' помечены измененные и добавленные правила.

   1    Идентификатор = Буква {Буква | Цифра}.
   2    Число = Целое | Действительное.
   3    Целое = Цифра { Цифра } | ВосьмеричнаяЦифра
   4            { ВосмеричнаяЦифра } "B" |
   5            Цифра { ШестнадцатеричнаяЦифра } "H" |
*  5.1          ПредставлениеЛитеры.
*  5.2  ПредставлениеЛитеры =
*  5.3       ВосьмеричнаяЦифра { ВосмеричнаяЦифра } "C".
   6    Действительное = Цифра { Цифра }
   7                     "." { Цифра } [Порядок].
   8    Порядок = "E" [ "+" | "-" ] Цифра { Цифра }.
   9    ШестандатиричнаяЦифра =
  10                         Цифра |"A"|"B"|"C"|"D"|"E"|"F".
  11    Цифра = ВосьмеричнаяЦифра |"8"|"9".
  12    ВосьмеричнаяЦифра =
  13                        "0"|"1"|"2"|"3"|"4"|"5"|"6"|"7".
* 14    Цепочка = Строка  { Строка | ПредставлениеЛитеры }.
* 14.1  Строка  =    "'" { Литера } "'" | '"' { Литера } '"'.
  15    КвалИдент = Идентификатор { "." Идентификатор }.
  16    ОписаниеКонстанты =
  17              Идентификатор "=" КонстВыражение.
  18    КонстВыражение = Выражение.
  19    ОписаниеТипа = Идентификатор "=" Тип.
  20    Тип = ПростойТип | ТипМассив | ТипЗапись
  21          | ТипМножество | ТипУказатель | ТипПроцедура
* 21.1        | ТипДинМассив.
  22    ПростойТип = КвалИдент | Перечисление
  23                 | ТипДиапазон.
  24    Перечисление = "(" СписИдент ")".
  25    СписИдент = Идентификатор { "," Идентификатор }.
* 26    ТипДиапазон =
  27      "[" КонстВыражение ".." КонстВыражение "]".
  28    ТипМассив = ARRAY ПростойТип { "," ПростойТип }
  29                OF Тип.
  30    ТипЗапись = RECORD ПослСписковКомпонент END.
  31    ПослСписковКомпонент = СписокКомпонент
  32                     { ";" СписокКомпонент }.
  33    СписокКомпонент ╫  [ СписИдент ":" Тип |
  34      CASE [Идентификатор] ":" КвалИдент OF Вариант
  35              { "|" Вариант}
  36      [ ELSE ПослСписковКомпонент ] END ].
  37    Вариант = [ СписокМетокВарианта ":" ]
  38              ПослСписковКомпонент.
  39    СписокМетокВарианта = МеткиВарианта
  40              { "," МеткиВарианта }.
  41    МеткиВарианта = КонстВыражение [ ".." КонстВыражение ].
  42    ТипМножество = SET OF ПростойТип.
  43    ТипУказатель = POINTER TO Тип.
  44    ТипПроцедура ╫ PROCEDURE [ СписокФормТипов ].
  45    СписокФормТипов = "(" [[VAR] ФормТип
* 46       { "," [VAR] ФормТип } ] [ SEQ [VAR] КвалИдент ] ")"
* 46.1     [ ":" КвалИдент ].
* 46.2  ТипДинМассив = DYNARR OF Тип.
  47    ОписаниеПеременной = СписИдент ":" Тип.
  48    Обозначение = КвалИдент { "." Идентификатор |
  49                  "[" СписВыражений "]" | "^" }.
  50    СписВыражений = Выражение { "," Выражение }.
  51    Выражение = ПростоеВыражение
  52                [ Отношение ПростоеВыражение ].
  53    Отношение = "=" | "#" | "<" | "<="
  54              | ">" | ">=" | IN.
  55    ПростоеВыражение = [ "+" | "-" ] Слагаемое
  56             { ОперацияТипаСложения Слагаемое}.
  57    ОперацияТипаСложения = "+" | "-" | OR.
  58    Слагаемое = Множитель
  59             { ОперацияТипаУмножения Множитель}.
  60    ОперацияТипаУмножения = "*" | "/" | DIV
  61             | MOD | AND
* 61.1           | REM | "<<" | ">>".
  62    Множитель = Число | Цепочка | Множество |
  63             Обозначение [ ФактическиеПараметры ] |
  64             "(" Выражение ")" | NOT Множитель |
* 64.1           Конструктор.
  65    Множество = [ КвалИдент ]
  66                "{" [ Элемент { "," Элемент } ] "}".
  67    Элемент = Выражение [ ".." Выражение ].
* 67.1  Конструктор = ARRAY OF КвалИдент
* 67.2      "{" КонстВыражение { "," КонстВыражение } "}".
  68    ФактическиеПараметры = "(" [ СписВыражений ] ")".
  69    Оператор = [ Присваивание | ВызовПроцедуры |
  70               УсловныйОператор | ОператорВыбора  |
  71               ЦиклПока | ЦиклДо | БезусловныйЦикл |
  72               ЦиклСШагом | ОператорПрисоединения |
  73               EXIT | RETURN [ Выражение ]].
  74    Присваивание = Обозначение ":=" Выражение.
  75    ВызовПроцедуры =
  76              Обозначение [ ФактическиеПараметры ].
  77    ПослОператоров = Оператор { ";" Оператор }.
  78    УсловныйОператор = IF Выражение THEN ПослОператоров
  79                  { ELSIF Выражение THEN ПослОператоров }
  80                  [ ELSE ПослОператоров ] END.
  81    ОператорВыбора = CASE Выражение OF Альтернатива
  82       { "|" Альтернатива } [ ELSE ПослОператоров ] END.
  83    Альтернатива = [ СписокМетокВырианта ":"
  84                     ПослОператоров ].
  85    ЦиклПока = WHILE Выражение DO ПослОператоров END.
  86    ЦиклДо = REPEAT ПослОператоров UNTIL Выражение.
  87    ЦиклСШагом = FOR Идентификатор ":="
  88             Выражение TO Выражение
  89             [ BY КонстВыражение ] DO ПослОператоров END.
  90    БезусловныйЦикл = LOOP ПослОператоров END.
  91    ОператорПрисоединения = WITH Обозначение
  92                            DO ПослОператоров END.
  93    ОписаниеПроцедуры = ЗаголовокПроцедуры ";"
* 94          ( Блок | Код ) Идентификатор.
* 94.1  Код = CODE { КонстВыражение } END.
  95    ЗаголовокПроцедуры = PROCEDURE Идентификатор
  96          [ ФормальныеПараметры ].
  97    Блок = { Описание } [ BEGIN ПослОператоров ] END.
  98    Описание = CONST { ОписаниеКонстанты ";" } |
  99               TYPE  { ОписаниеТипа ";" } |
 100               VAR   { ОписаниеПеременной ";" } |
 101               ОписаниеПроцедуры ";" | ОписаниеМодуля ";"
*101.1             ЗаголовокПроцедуры ";" FORWARD ";".
 102    ФормальныеПараметры =
 103         "(" [ ФПСекция { ";" ФПСекция } ]
*103.1        [ SEQ [ VAR ] Идентификатор ":" КвалИдент ] ")"
 103.2        [ ":" КвалИдент ].
*104    ФПСекция = [ VAR | VAL ] СписИдент ":" ФормТип.
 105    ФормТип = [ ARRAY OF ] Квалидент.
*106    ОписаниеМодуля = MODULE Идентификатор
 107         ";" { Импорт } [ Экспорт ] Блок Идентификатор.
 108    Приоритет = "[" КонстВыражение "]".
 109    Экспорт = EXPORT [ QUALIFIED ] СписИдент ";".
*110    Импорт = [ FROM Идентификатор ] IMPORT СписИмпорта.
*110.1  СписИмпорта = ИмпортСекция { "," ИмпортСекция }.
*110.2  ИмпортСекция = [ Идентификатор ":" Идентификатор ].
 111    МодульОпределений = DEFINITION MODULE Идентификатор
 112                  ";" { Импорт } { Определение } END
 113                  Идентификатор ".".
 114    Определение = CONST { ОписаниеКонстанты ";" } |
 115               TYPE  { Идентификатор [ "=" Тип ] ";" } |
 116               VAR   { ОписаниеПеременной ";" } |
*116.1             VAL   { ОписаниеПеременной ";" } |
 117               ЗаголовокПроцедуры ";".
 118    ПрограммныйМодуль = MODULE Идентификатор
 119      [ Приоритет ] ";" { Импорт }
*119.1    { Описание | ДинПоддержка }
 119.2    [ BEGIN ПослОператоров ] END Идентификатор ".".
*119.3  ДинПоддержка = WITH Идентификатор
*119.4      ( ":" КвалИдент |  "(" СписСоответствий ")" ).
*119.5  СписСоответствий = Соответствие { ";" Соответствие }.
*119.5  Соответствие = Идентификатор ":" КвалИдент.
 120    ЕдиницаКомпиляции = МодульОпределения |
 121      [ IMPLEMENTATION ] ПрограммныйМодуль.


     5.1.3. Еще раз о расширениях

     В  этом  пункте  делается  попытка  заранее  ответить  на
следующие вопросы читателя касательно расширений:

        - Зачем нужны расщирения?
        - Кому это выгодно?
        - А как этим пользоваться?

Примеры использования расширений приводятся в 5.1.6.


     5.1.3.1. Динмассивы

     Динмассивы  удобно  использовать для хранения информации,
размеры  которой  статически  не известны. Необходимо понимать
двойственность структуры динмассива (или тройственность?).

     Динмассив  представляет  собой  пару дескриптор + массив.
Значение типа  динмассив  занимает  два слова под деcкриптор и
сколько  надо  слов  под тело массива. Если динмассив является
компонентой некоторой структуры (записи, массива, динмассива),
то   при   копировании   структуры   будет  скопирован  только
дескриптор, например:

VAR a,b: RECORD
           dyn: DYNARR OF INTEGER;
           ptr: POINTER TO INTEGER;
         END;

   a:=b;

После этого присваивания поля a.dyn и b.dyn будут ссылаться на
одно  и то же  тело  массива. Ситуация аналогична ситуации для
указателей: поля a.ptr и b.ptr указывают в одно место памяти.

     Дескриптор  динмассива  (или  паспорт) представляет собой
запись из двух полей:

      RECORD
        ADR : SYSTEM.ADDRESS;
        HIGH: INTEGER;
      END;

Поле  ADR  содержит  адрес массива, а поле HIGH - значение его
верхней  границы.
     Запись  d^  (где  d  -  динмассив)  обозначает  доступ  к
дескриптору,  d^.ADR и d^.HIGH обозначает соответствующие поля
дескриптора.

     Динмассив  ведет  себя  как  гибкий  массив  в  следующих
случаях:
     - в индексации d[i];
     - в  вызовах стандартных процедур HIGH, LEN, SIZE, BYTES,
       BITS;
     - при   передаче   параметра,  если  формальный  параметр
       является гибким массивом;
     - при  передаче параметра, если тип формального параметра
       - последовательность слов.

В  следующем примере приводятся почти все случаи использования
динмассивов:

   PROCEDURE p1(    s: ARRAY OF CHAR); END p1;
   PROCEDURE p2(VAR s: ARRAY OF CHAR); END p2;
   PROCEDURE p3(    s: STRING);        END p3;
   PROCEDURE p4(VAR s: STRING);        END p4;
   PROCEDURE p5(SEQ x: SYSTEM.WORD);   END p5;

   VAR a,b: STRING;
       adr: ADDRESS;
         n: INTEGER;

      a:=b;          -- копирование строк;
      a^:=b^;        -- копирование дескрипторов;
      a^.HIGH:=1;    -- изменение верхней границы;
      a^.ADR:=NIL;   -- изменение адреса массива;
      n:=SIZE(a^);   -- n = 2;
      n:=SIZE(a);    -- n = размер массива;
      adr:=ADR(a);   -- adr = a^.ADR;
      adr:=ADR(a^);  -- adr = адрес дескриптора;
      p1(a);         -- передача массива по значению;
      p2(a);         -- передача массива по ссылке;
      p3(a);         -- передача дескриптора по значению;
      p4(a);         -- передача дескриптора по ссылке;
      p5(a);         -- передача адреса массива;
      p5(a^);        -- передача адреса дескриптора.

     Стандартные  процедуры  NEW,  DISPOSE, RESIZE (см. 5.1.2)
реализуют  операции  выделения  памяти динмассиву, возвращения
памяти  и  изменения  размера динмассива. При этом практически
никогда  не  появляется необходимость обращаться к дескриптору
динмассива.


     5.1.3.2. Процедуры с переменным числом параметров

     Последним    параметром    у    процедуры    может   быть
параметp-последовательность.   При   вызове  процедуры  вместо
такого    формального   параметра   может   быть   подставлена
последовательность  фактических  параметров  (в  том  числе  и
пустая).  Внутри процедуры такой параметр аналогичен параметру
типа  ARRAY  OF  T.  Если параметр передается не по ссылке, то
присваивание  элементам  массива-параметра  запрещено, то есть
подразумевается передача по доступу.

Пример:

     PROCEDURE Min(SEQ x: INTEGER): INTEGER;
       VAR min,i: INTEGER;
     BEGIN
       ASSERT(HIGH(x)>=0);
       min:=x[0];
       FOR i:=1 TO HIGH(x) DO
         IF x[i]<min THEN min:=x[i] END
       END;
       RETURN min
     END Min;

     ........

     i:=Min(1,2,3,4);

     Параметр-последовательность  типа  T  может  быть передан
целиком  процедуре с формальным параметром-последовательностью
типа  T1,  если тип T совместим с типом T1 и способ передачи у
обоих  параметров  одинаковый  (оба  по  значению  или  оба по
ссылке).

     PROCEDURE p(SEQ x: INTEGER);
     .......
       i:=Min(x);
     .......

     Замечание:   если   тип   последовательности   WORD,   то
фактическими  параметрами  могут  быть  не  только однословные
объекты,  но  и  структуры. В этом случае передается только их
адрес и копирования не происходит.

     Введение  в  язык процедур с переменным числом параметров
оказало  большое  влияние  на  библиотеки ввода/вывода. Вместо
большого  количества  процедур  вывода,  таких, как WriteChar,
WriteInteger,  WriteReal  и  т.д.,  что  характерно для других
реализаций   Модулы-2,   наши  библиотеки  содержат  процедуры
форматного  вывода,  которые  позволяют  формировать  выходной
поток существенно удобней.

PROCEDURE print(format: ARRAY OF CHAR; SEQ x: SYSTEM.WORD);

Строка  format  содержит  описание формата вывода (в стандарте
Unix SYSTEM V).

Пример:

   print('factorial(%d)=%d\n',n,factorial(n));

Если   n=5  (и  процедура  с  именем  factorial  действительно
реализует факториал), то результатом будет:

factorial(5)=120


     5.1.3.3.     Динамическая     поддержка,     определяемая
пользователем

     Одним  из преимуществ Модулы-2 как языка программирования
систем  (в  том  числе ОС и систем реального времени) является
отсутсвие  необходимости  в  динамической  поддержке (Run Time
Support  -  RTS).  Отсутствие  RTS  отвязывает  компилятор  от
реальной системы, в которой будет работать полученный им код.
     В  то же время есть много полезных вещей, которые хочется
включить  в  язык,  но  реализовать в компиляторе их по разным
причинам трудно (или нежелательно). К таким вещам относятся:

     - исключительные ситуации;
     - аккуратные операции над кучей (NEW, DISPOSE, RESIZE);
     - операторы параллельности;
     - и так далее...

     Реализация  всего  этого  в компиляторе требует некоторых
знаний  о  системе,  а  в  качестве  библиотеки  их невозможно
реализовать  без  потери  надежности  (или  вообще  невозможно
реализовать, например RESIZE(любой_динмассив,новая_длина)).
     Рассуждая   таким   образом,  можно  прийти  к  выводу  о
необходимости  совместной реализации таких вещей в компиляторе
и   бибилиотеке.   Компиляторная   часть   должна   обеспечить
надежность   и   контроль,   библиотечная   же   часть   может
использовать  конкретную  систему.  Существенным требованием к
такой  реализации  должно  оставаться отсутствие обязательного
RTS,   то  есть:  те  модули,  которые  не  пользуются  новыми
языковыми  конструкциями,  не  должны  изменяться  от введения
таковых.
     В   текущей   версии  с  помощью  динамической  поддержки
реализованы операции работы с памятью.


     5.1.4. Режимы компиляции

     5.1.4.1. Прагматы

     Текст   Модула-программы   может   содержать  управляющие
последовательности,  которые  мы  будем  называть  прагматами.
Прагматы  служат для изменения режима компиляции внутри текста
программы.

прагмат   = "(*$" директива "*)".
директива = { опция "+" | "-"  | "!" | "<" | ">" }
опция     = 'A'|'F'|'I'|'N'|'R'|'T'

     Каждая   опция  означает  действие,  которое  может  быть
включено  (отключено)  управляющей  последовательностью. Смысл
опций и их начальное состояние приводится в таблице.

--------------------------------------------------------------
N    Опция             Значение                   По умолчанию
--------------------------------------------------------------
1  |   A    | показ всех ошибок                         |  off
   |        |                                           |
2  |   F    | аварийное окончание компиляции при первой |
   |        | встреченной ошибке                        |  off
   |        |                                           |
3  |   I    | инициализация переменных типа указатель   |
   |        | значением NIL; типа динмассив - парой     |   on
   |        | (NIL,-1)                                  |
   |        |                                           |
4  |   N    | проверка на NIL для указателей и          |  off
   |        | динмассивов. При включении автоматически  |
   |        | включает опцию I                          |
   |        |                                           |
5  |   R    | контроль выхода за границы отрезка        |   on
   |        |                                           |
6  |   T    | контроль индексов массивов                |   on
--------------------------------------------------------------

Остальные  директивы  определяют  операции  над стеком режимов
трансляции.

     1) < - запомнить текущее состояние опций в стеке;
     2) > - восстановить последнее состояние опций из стека;
     3) ! - счеркнуть  весь стек режимов и перейти в исходное
состояние.

     Начальное  состояние режимов компиляции может быть задано
при  запуске  компилятора  средствами системы программирования
(см. 5.2).


     5.1.4.2. Версия системы команд

     Компилятор  может  порождать  код  модуля,  используя три
версии системы команд:

     - базовая  версия  (версия  0).  Код базовой версии может
       выполняться   на  всех  моделях  процессоров  семейства
       Кронос;

     - расширенная  версия  (версия  1). Компилятор использует
       набор    дополнительных    команд,   реализованных   на
       процессорах 2.5 и 2.6WS.

     - версия   рабочей   станции   (версия   2).   Компилятор
       использует  набор  дополнительных команд, реализованных
       на процессоре 2.6WS.

     Номер  версии системы команд может быть задан при запуске
компилятора  (см.  5.1.2).  Если  номер  версии  не указан, то
компилятор  порождает  код  для  того  процессора,  на котором
работает.
     За  более  подробными сведениями о версиях системы команд
отсылаем  читателя  к книге "Архитектура процессоров семейства
КРОНОС".


     5.1.4.3. Приоритет модуля

     В  заголовке  модуля может быть указан приоритет модуля -
целое  число,  интерпретация которого зависит от ОС. В текущей
версии определены следующие приоритеты:
     0 - обычный модуль;
     1 - уникальный модуль.

     Данные  уникального  модуля  не  дублируются,  если  этот
модуль  используется  несколькими  задачами  (подробнее  см. в
документации по ОС).


     5.1.5. Стиль программирования

     Этот   пункт   содержит  необязательные  рекомендации  по
разработке  программ  на  языке  Модула-2.  Набор рекомендаций
включает   в   себя   правила   расположения   текста,  способ
комментирования,     правила    выбора    идентификаторов    и
использования   языковых   конструкций.   Эти   правила   были
выработаны   группой  Кронос  для  внутреннего  использования.
Совокупность   правил   определяет  "стиль"  программирования.
Использование  единого  стиля  упрощает  совместную работу над
проектами и является простым способом увеличения читабельности
программ.
    Особенно важно придерживаться единого стиля при оформлении
общеполезных библиотек.


     5.1.5.1. Расположение текста

     Отступы  используются  для выделения структуры программы.
Ширина  каждого  отступа 2 символа (пробела). Следующий пример
иллюстрируют   рекомендуемую   форму   некоторых   конструкций
Модулы-2:

MODULE Example; (* 29-Mar-90. (c) KRONOS *)

CONST
  one = 1;
  two = 2;

TYPE
  Mode     = (root,path,leaf);
  node_ptr = POINTER TO node_rec;
  node_rec = RECORD
               mode : Mode;
               info : INTEGER;
               left : node_ptr;
               right: node_ptr;
             END;

VAR
  info: INTEGER;
  root: node_ptr;

PROCEDURE p(VAR n: node_ptr);
  VAR i: INTEGER;
BEGIN
  i:=0;
  n^.info:=info; INC(info);
  IF    node^.left =NIL THEN node^.left :=n
  ELSIF node^.right=NIL THEN node^.right:=n
  ELSE DEC(info);
  END;
END p;

BEGIN
  CASE node^.mode OF
    |root:
    |path:
  ELSE ASSERT(FALSE);
  END;
END Example;

     Если    языковая    конструкция   достаточно   мала,   то
рекомендуется размещать ее на одной строке текста.

  IF a>b THEN min:=b ELSE min:=a END;
  FOR i:=0 TO HIGH(a) DO a[i]:=0 END;

     Несколько  простых  операторов  могут  быть  размещены на
одной   строке.   Рекомендуется   размещать  на  одной  строке
несколько    "сильно"   связанных   операторов   присваивания.
Например, операторы, ввязывающие элемент в односвязный список:

   n^.next:=head; head:=n;


     5.1.5.2. Комментарии

     Используются   традиционные  комментарии  для  оформления
больших  текстов.  Комментарии  в  стиле  Ады  употребляются в
следующих случаях:
     - комментирование данной строки;
     - пометка об изменении строки;
     - указание ключевого места в тексте;
     - выделение заголовка раздела.

Примеры:

TYPE
  node_rec = RECORD
               mode : Mode;      -- вид узла
               left : node_ptr;  -- левый  сын
               right: node_ptr;  -- правый сын
             END;

-----------------------  NEW SECTION  -------------------------
                       ---------------

PROCEDURE joke(a,b: INTEGER): BOOLEAN;
  VAR min: INTEGER;
BEGIN
  IF a>b THEN min:=a ELSE min:=b END;  -- modified 29-Mar-90
  IF min<0 THEN RETURN TRUE END;
                       ----
  RETURN FALSE
END joke;


     5.1.5.3. Именование

     Как  правило,  все  имена  записываются  только строчными
буквами.  Если  имя  состоит  из  нескольких  слов, могут быть
использованы два способа именования:

    local_var      localVar
    node_ptr       nodePtr

Рекомендуется использование подчерка.

     Основные требования предъявляются к именам в определяющих
модулях. Рекомендуется следующий стиль:

     - процедуры в разных библиотеках, реализующие аналогичные
       операции,    называются    одинаково   (Terminal.print,
       StdIO.print);

     - существуют  устойчивые  пары  имен,  не  надо смешивать
       имена из разных пар; например:
                put      get
                read     write
                new      dispose
                insert   delete
                install  remove

     - имена скрытых типов состоят только из заглавных букв;
     - имена  типов указателей и записей оканчиваются добавкой
       _ptr и _rec соответственно;


     5.1.5.4. Использование языковых конструкций

     В  определяющих  модулях  не  рекомендуется использование
типа  диапазона и типа перечисления, если набор констант может
измениться. Так, не стоит заводить перечислимый тип OS_errors,
но нет ничего плохого в том, чтобы определить тип
   Week =(Monday,...,Sunday),
так как это от Бога.

     В  реализующих  модулях  не  рекомендуется  использование
локальных   модулей   (от   себя   все  равно  не  скроешь)  и
расквалифицирующего  импорта  (FROM  IMPORT).  Напротив, очень
рекомендуется  использование  переименования  при импорте. Это
существенно  увеличивает  читабельность  текста  (всегда видно
Что, Где и Почем).

     В  процедурах  типа  "open", "new", которые создают новый
объект,   рекомендуется   делать  возвращаемый  объект  первым
параметром.   Желательно   воздерживаться   от  подряд  идущих
параметров  одного типа, особенно - основного типа. Так, лучше
писать:
    PROCEDURE (INTEGER,BOOLEAN,INTEGER)

вместо

    PROCEDURE (INTEGER,INTEGER,BOOLEAN).


     5.1.5.5. Оформление определяющего модуля библиотек

     Рекомендуется следующий вид библиотеки:

DEFINITION MODULE имя; (* <автор> <время написания> *)

ТЕКСТ НА МОДУЛЕ-2

(*************************************************************

     Развернутый  комментарий, состоящий из описания принципов
использования  библиотеки  и  пояснения  к  каждой  процедуре,
содержащий  описания параметров процедуры, диапазон допустимых
значений и реакцию на исключительные ситуации.

*************************************************************)

END имя.


     5.1.6. Примеры программ

     5.1.6.1.  Рассмотрим  простой  модуль  работы с текстом для
текстового  редактора.  Модуль  реализует  операции сохранения
строки  текста, возвращения строки основному модуля редактора,
удаления  строк и так далее. В примере используется библиотека
работы со строками.


DEFINITION MODULE edText; (* Ned 29-Mar-90. (c) KRONOS *)

PROCEDURE get(lineno: INTEGER; VAR s: ARRAY OF CHAR);
(* Выдает сожержимое строки по ее номеру. *)

PROCEDURE put(lineno: INTEGER;     s: ARRAY OF CHAR);
(* Запоминает содержимое строки *)

PROCEDURE delete(lineno,lines: INTEGER);
(* Удаляет lines строк, начиная с lineno *)

PROCEDURE insert(lineno,lines: INTEGER);
(* Вставляет lines пустых строк перед строкой lineno *)

END edText.

IMPLEMENTATION MODULE edText; (* Ned 29-Mar-90. (c) KRONOS *)

IMPORT  str: Strings;                                   (*0*)
IMPORT       Heap;

WITH STORAGE: Heap;                                     (*1*)

TYPE TEXT = DYNARR OF STRING;

VAR text: TEXT;

PROCEDURE get(lineno: INTEGER; VAR s: ARRAY OF CHAR);
BEGIN
  IF lineno>HIGH(text) THEN s:=''
  ELSE
    str.copy(s,text[lineno]);                            (*2*)
  END;
END get;

PROCEDURE put(lineno: INTEGER; VAL s: ARRAY OF CHAR);
  VAR x: STRING;
BEGIN
  IF lineno>HIGH(text) THEN RESIZE(text,lineno+16) END;  (*3*)
  NEW(x,str.len(s)+1);                                   (*4*)
  str.copy(x,s);
END put;

PROCEDURE delete(lineno,lines: INTEGER);
  VAR i,n: INTEGER;
BEGIN
  IF lineno+lines>=LEN(text) THEN
    FOR i:=lineno TO HIGH(text) DO DISPOSE(text[i]) END;
  ELSE
    FOR i:=lineno TO lineno+lines-1 DO DISPOSE(text[i]) END;
    n:=lineno+lines;
    FOR i:=lineno TO HIGH(text) DO
      IF n<=HIGH(text) THEN text[i]^:=text[n]^;          (*5*)
      ELSE NEW(text[i]);
      END;
      INC(n);
    END;
  END;
END delete;

BEGIN
  NEW(text);
END edText.

Примечания:

(*0*) Импорт модуля Strings с переименованием.
(*1*) Определение настраиваемых стандартных процедур
      работы с памятью.
(*2*) Копирование строк.
(*3*) Увеличение числа элементов в динмассиве text.
(*4*) Выделение памяти для строки. Число элементов в строке
      вычисляется как число элементов параметра плюс один
      (для хранения символа конца строки - 0c).
(*5*) Копирование дескриптора строки.
.PAGE
.HEAD 0 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ             ИСПОЛЬЗОВАНИЕ КОМПИЛЯТОРА@u'
.HEAD 1 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ             ИСПОЛЬЗОВАНИЕ КОМПИЛЯТОРА@u'
.HEAD 2 ''
.HEAD 3 ''




                          Глава 5.2. Использование компилятора

     Компилятор  "mx"  состоит  из  ядра и набора утилит. Ядро
является  конструтором для создания конечного продукта, каждая
утилита  реализует некоторый способ использования компилятора.
В  базовый  набор  постановки  системы  входит несколько таких
утилит: пакетный компилятор "mx", турбо-компилятор "turbo2x" и
утилита поддержки разработки "pm" (project manager).
     Использование  пакетного компилятора описывается в 5.2.2,
турбо-компилятора  -  в  5.2.3.  Все  эти  утилиты  одинаковым
образом   настраиваются  на  окружение  задачи  (environment).
Описание  окружения  приводится  в  5.2.7. В 5.2.1 описываются
соглашения  об  именовании  файлов.  Способы  разработки новых
компилирующих утилит описываются в 5.3.2.
     Содержание   этого   раздела   существенно   зависит   от
операционной  системы,  в  которой  работает  компилятор  (см.
описание утилит ОС Excelsior).


     5.2.1. Имена модулей и файлов

     При работе на Модуле-2 программисту приходится иметь дело
с пятью сущностями:
        - определяющие модули;
        - реализующие (и программные) модули;
        - симфайлы;
        - реффайлы;
        - кодофайлы.

     Определяющий   модуль   содержит   информацию  о  способе
использования   некоторых  объектов  (интерфейс),  реализующий
модуль  определяет  реализацию операций (функций). Программный
модуль  удобно  рассматривать  как реализующий модуль с пустым
интерфейсом.
     Для  модуля  с именем M рекомендуется текст определяющего
модуля  хранить  в  файле  с  именем M.d, а текст реализующего
модуля в файле с именем M.m.
     При  компиляции определяющего модуля компилятор порождает
так  называемый  симфайл,  который  содержит  (в сжатой форме)
информацию, необходимую  клиентам модуля (то есть тем модулям,
которые импортируют данный). Компилятор записывает симфайл для
модуля с именем M в файл с именем M.sym.
     При  компиляции  реализующего модуля компилятор порождает
кодофайл   (исполняемый   образ  модуля)  и  реффайл,  который
содержит  информацию, необходимую  отладчикам.  Для  модуля  с
именем M компилятор записывает кодофайл в файл с именем M.cod,
а реффайл в файл с именем M.ref.
     По  умолчанию  все  файлы,  которые порождает компилятор,
записываются  на  текущую  директорию  (см.  5.2.7,  если есть
желание записывать файлы в другие места).


     5.2.2. Пакетный режим

     Использование утилиты "mx":

     mx { имя_файла } [ дополнительные_аргументы ]

     Компилятор   последовательно   транслирует  файлы,  имена
которых  заданы в списке параметров утилиты. Если имя файла не
содержит расширителя, то к имени добавляется постфикс ".m".
     В   начале   компиляции   на  терминал  выдается  строка,
содержащая  имя  и  версию  компилятора  и  имя компилируемого
файла:

Modula X  v0.7 /21-Mar-90/ [2] "a.m"

В квадратных скобках указана модель процессора.

     При  обнаружении  ошибок  компиляции на стандартный вывод
выводится  сообщение  об  ошибке,  состоящее из пояснения типа
ошибки  и  строки текста, в которой обнаружена ошибка. Позиция
ошибки  в  строке помечается символом "$". Заметим, что символ
"$" выставлен после ошибочной лексемы. Например:

Невидимый объект  -- "aaaa"
   5:   i:=aaaa$;

Компиляция   модуля  прекращается, если  число  ошибок  больше
некоторого предела (см. 5.1.4).

     После  завершения  компиляции модуля на терминал выдается
сообщение, содержащее информацию о числе строк, числе ошибок и
времени, затраченном на компиляцию:

errors: 1  lines 7  time  01cpu + 01io

     Если   ошибки   не   обнаружены,  то  сообщение  содержит
информацию  о  числе  строк,  времени  компиляции, а также имя
порожденного  файла  и  размер  кода  (только  при  компиляции
реализующих модулей).

lines 7  time  01cpu + 01io  "a.cod"  1 words

     Если  компилятору  задано  несколько  имен  файлов, то по
завершении  компиляции компилятор выдает сообщение, содержащее
суммарную   статистику:   число  файлов,  число  строк,  время
компиляции,  скорость  компиляции  (строк  в  минуту)  и общий
размер  порожденного кода. Информация о неправильных модулях в
статистику не включается.

files 2 lines 14 time cpu00:01 io00:01 speed 840 l/m  2 words

     Если   компилятор   запущен   открепленно,   то   строки,
содержащие   имя   компилятора  и  информацию  о  модулях,  не
выдаются.


     5.2.3. Турбо-компилятор

     Турбо-компилятор   представляет  собой  утилиту,  которая
компилирует текст модуля, находящегося в буфере редактора. При
этом  полученные  в  результате компиляции симфайл, кодофайл и
реффайл записываются на диск.
     Турбо-компилятор  запускается  из редактора (см. "Утилиты
ОС Excelsior", раздел 'ex') нажатием клавиш F0 и 'm'.
     Если   в   тексте   при   компиляции  обнаружены  ошибки,
компилятор   сообщает   о  них  последовательно.  Сообщение  о
характере    ошибки    при   этом   появляется   в   служебной
(информационной)  строке, а курсор позиционируется в том месте
текста модуля (после той лексемы), где произошла ошибка.
     Переход к следующей ошибке осуществляется нажатием клавиш
F0 и '+'.
     После  того,  как  исправлены все ошибки, можно запустить
отлаживаемую программу и, убедившись в правильности ее работы,
записать  текст  на  диск.  Таким образом, время на исполнение
стандартного  отладочного   цикла   редактирование-компиляция-
запуск может быть заметно сокращено.


     5.2.4. Перечень сообщений компилятора

     Приводим  сообщения  компилятора с комментариями там, где
они требуются.


     5.2.4.1. Сообщения типа "Слишком много"

1) Переполнена хеш-таблица (слишком много имен)
     Текущая  реализация не умеет работать с таким количеством
переменных, процедур и других именованных объектов.

2) Переполнение стека выражений!
     Выражение не удалось вычислить на стеке в 7 элементов.

3) Слишком сложное условное выражение
     Много  написано  между  условными операторами. Аппаратное
ограничение. Не бывает.

4) Слишком большой размер типа
     Размер типа превышает maxInt.

5) Слишком много параметров
     Параметров  у  процедуры  больше,  чем  позволяет текущая
реализация (>256).

6) Ограничение транслятора: слишком много
     Процедур  или  переменных  больше,  чем допускает текущая
версия.

7) Размах меток оператора выбора > 256


     5.2.4.2. Сообщения типа "Ожидалось"

1) Неожиданный конец исходного текста!
     Ожидалось "END имя_модуля".

2) Ожидался идентификатор

3) Должно быть имя блока
     Должно быть имя процедуры или модуля.

4) Отсутствует 'h' после шестнадцатеричного

5) Незакрытая или слишком длинная строка!
     В конце строки текста не стоит ".

6) Ожидался символ
     Например, ";" или ")".

7) Ожидалось константное выражение
     Например, границы массива.

8) Ожидался оператор
     Как правило, вызвано мусором в тексте модуля.

9) Код записывается байтами! [0..0FFh]
     Ошибка в кодовой процедуре.

10) Некорректная информация в симфайле
     Начало было похоже на симфайл, а дальше...

11) Ошибка в заголовке симфайла
     Мусор в содержимом симфайла.

12) Ошибка в конструкторе типа

13) Ошибка в заголовке модуля
     Ошибка в самой первой строке программы.

14) Незакрытый комментарий, начавшийся в строке


     5.2.4.3. Семантические ошибки

1) Невидимый объект
     Объект не описан или не проимпортирован.

2) Повторно объявлен
     Такой объект уже был описан.

3) Рекурсивное определение объекта
     Например, CONST A=A+1.


     5.2.4.4. Ошибки при работе с типами

1) Недопустимое преобразование типа
     Можно преобразовывать только в тип той же длины.

2) Типы несовместимы

3) Должен быть тип указателя

4) Скрытый тип должен быть однословным и не литерным

5) Должен быть тип
     Идентификатор не является типом.

6) Должен быть скалярный тип

7) Должен быть простой (1 слово) тип


     5.2.4.5. Ошибки в выражениях

1) Неправильное константное выражение
     Выражение правильное, но не константное.

2) Неправильное выражение

3) Переполнение (исчерпание) в константном выражении
     Выдается, например, при делении на 0.

     5.2.4.6. Вызовы процедур и функций

1) Вызов процедуры в выражении
     Вместо функции вызвана процедура.

2) Вызов функции в позиции оператора

3) Неправильное число параметров
     Лишние или недостающие параметры в процедуре.

4) Это не процедура


     5.2.4.7. Ошибки в версиях

1) Некорректная версия симфайла
     Что-то устарело.

2) Конфликт версий (по времени компиляции)
     См. раздел о конфликте версий.


     5.2.4.8. Встретилось неожиданно (не на месте)

1) Непонятный знак игнорируется
     Например, $ или %, @.

2) Должен быть массив
     Попытка    проиндексировать    не    массив    ([   после
идентификатора).

3) Должна быть запись
     Встретилась ".".

4) Ошибка в описаниях
    Мусор до BEGIN или отсутствует BEGIN.

5) Недопустимо в определяющем модуле
    Например, VAL-параметр или  BEGIN.

6) EXIT вне LOOP'а
     Скорее всего, лишний END внутри LOOP-цикла.

7) Такая метка уже была
     Одинаковые метки в CASE-операторе.

8) Должен быть тип множества
     Использование { не по делу.

9) RETURN можно писать только в процедуре
     В теле модуля нельзя.


     5.2.4.9. Прочие ошибки

1) Неправильный (неконстантный) или вырожденный отрезок
     Отрезок  в описании типа должен быть константным и правая
граница больше левой.

2) Не реализовано
     Не реализовано в компиляторе.

3) Должна быть переменная
     Объект существует, но не является переменной.

4) Не обладает адресом
     Выдается,   например,   при  попытке  присвоить  значение
константе.

5) Не обладает значением
     Например, вложенная процедура.

6) Недопустимое использование формального типа
     ARRAY OF можно использовать только при описании заголовка
процедуры.

7) Переменная цикла должна быть локальной
     Должна быть описана в минимальном объемлющем блоке.

8) Это не модуль
     Попытка  проимпортировать  что-то  другое (или из чего-то
другого).

9) Выход за границы диапазона
     Выход за границы массива или битсета.

10) Экспорт невозможен. Объект уже объявлен

11) Доступ к дескриптору только с ключом $U+ (unsafe)

12) Нереализованная процедура
     Ошибка в FORWARD-описании.

13) Попытка подсунуть чужой симфайл
    Симфайл не модуловский. Не бывает.

14) Повторный FORWARD

15) Недопустимое использование идентификатора модуля
     Попытка проиндексировать имя модуля.

16) Неправильный синтаксис строки
     Ошибка между "".

17) Разрешено только на уровне единицы компиляции

18) Недоступная RTS процедура
     NEW, DISPOSE, RESIZE не определены.

19) Спецификатор VAL недопустим в описании процедурного типа

20) В CASE нужна хоть одна альтернатива

21) Переменная цикла не может быть VAR-параметром

22) Присваивание VAL-переменной (Только Для Чтения)

23) Разрешено только в определяющем модуле
     Попытка описать скрытый тип или VAL-переменную.

24) Копирование динмассивов только с ключом $X+
    Временно.


     5.2.5. Порядок компиляции

     Сначала  компилируют  определяющий  модуль, если он есть,
затем - реализующий и только потом программный.
     Если   программа   состоит   из  нескольких  модулей,  то
компилируют   сначала   все   определяющие   модули,  а  затем
реализующие.
     При  компиляции необходимо следить за порядком импорта, а
именно:   чтобы   скомпилировался   модуль   М,  импортирующий
какой-нибудь  объект  из модуля N, требуется симфайл N.sym. Из
этого  следует  вывод,  что  определяющий модуль N должен быть
скомпилирован  раньше,  чем определяющий модуль M. Кроме того,
этот  симфайл  должен  быть  видим, т.е. лежать на директории,
указанной  в  пути.  Например, симфайлы всех библиотек принято
хранить на директории /$v/sym, где $v - имя носителя.
     Порядок  компиляции  реализующих  модулей после того, как
скомпилированы  определяющие,  значения  не  имеет.  Это имеет
важное  методологическое  значение. Так, скажем, один и тот же
модуль,  задействованный  в  большом  количестве  задач, может
иметь   разные   реализации,   которые   можно   заменять  без
последующей перекомпиляции этих задач.


     5.2.6. О конфликте версий

     При  несоблюдении  правильного  порядка  компиляции может
произойти  конфликт  версий, возникающий в процессе компиляции
или при запуске задачи.
     Первое   происходит  в  случаях,  которые  можно  описать
схемой:

     A.d ---------> B.d
      \             /
       \           /
        \         /
         \       /
          \     /
           \   /
            V V
            C.%

     Здесь  стрелки изображают порядок импорта объектов, C.% -
определяющий (C.d) либо реализующий (C.m) модуль.
     Если  сначала  был скомпилирован модуль A.d, затем B.d, а
потом  по какой-то причине снова A.d, то при компиляции модуля
C возникает конфликт версий симфайлов A.sym и B.sym.
     Ситуация,  в  которой  возникает конфликт версий кода при
запуске  задачи,  такова: если модуль C импортирует объекты из
модуля A, а порядок компиляции оказался следующим:

A.d C.m A.d A.m

,  то  при запуске задачи возникает конфликт версий кодофайлов
C.cod и A.cod.


     5.2.7. Среда компиляции

     Среда  компиляции  состоит  из набора строк, определяющих
поиск   симфайлов   и   файлов,   содержащих  исходный  текст,
директории  на  которые  будут  записаны  симфайлы, реффайлы и
кодофайлы   и   режимы   компиляции.  Компилятор  при  запуске
настраивается  на  окружение:

     "SYM"     - определяет  пути поиска симфайлов; состоит из
                 имен директорий, разделенных пробелами;

     "mxTEXT"  - определяет   пути   поиска   файлов  исходных
                 текстов;    состоит   из   имен   директорий,
                 разделенных пробелами;

     "mxOUT"   - определяет имена директорий, на которые будут
                 записываться   выходные   файлы  компилятора;
                 состоит  из пар равенств вида образец = путь,
                 разделенных  символом ":". Если имя выходного
                 файла   не   сопоставляется  ни  с  одним  из
                 образцов,  то  файл  будет записан на текущую
                 директорию.


     "mxERRLIM"- определяет    макисмальное    число    ошибок
                 компиляции;

     "mxCPU"   - определяет   версию   системы   команд.  Если
                 окружение  задачи не содержит строки "mxCPU",
                 то  компилятор  порождает  код для той модели
                 процессора, на которой работает.

     "mxFLAGS" - определяет    режимы   компиляции.   Содержит
                 последовательность пар символов, состоящих из
                 литеры,  определяющей  режим  компиляции,  за
                 которым  следует  символ  "+" или "-". Символ
                 "+"   обозначает   включение  режима,  "-"  -
                 выключение.


     Строки с указанными именами могут быть заданы в окружении
задачи    (об    окружении    см.   в   разделе,   посвященном
пользовательской   оболочке):   или  параметрами  при  запуске
компилятора.

Примеры:

SYM       ". /sym /usr/sym"
mxTEXT    ". new_project"
mxOUT     "*.cod=my_bin: mx*.sym=/usr/sym"
mxFLAGS   "N+T-"
mxERRLIM  "8"
mxCPU     "2"
.PAGE
.HEAD 0 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ                РЕАЛИЗАЦИЯ КОМПИЛЯТОРА@u'
.HEAD 1 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ                РЕАЛИЗАЦИЯ КОМПИЛЯТОРА@u'
.HEAD 2 ''
.HEAD 3 ''




                             Глава 5.3. Реализация компилятора


     5.3.1. Детали реализации

     Рассматриваются  тонкие  места входного языка, которые не
определены  Сообщением  [5].  Речь  будет идти о совместимости
типов.

     5.3.1.1.  Тип  T1 совместим с типом T0, если истинно одно
из следующих утверждений:

1) T1 описан, как T1=T0 (т.е. они идентичны);
2) T1 описан как диапазон T0;
3) T0 описан как диапазон T1;
4) T0 и T1 описаны как диапазоны одного и того же типа;
5) один  из  типов  есть  ADDRESS, а другой - тип INTEGER (или
   диапазон типа INTEGER) или тип указателя.

Заметим, что отношение совместимости симметрично.

     5.3.1.2.  Тип  T1  обобщенно  совместим  с типом T0, если
истинно одно из следующих утверждений:

1) типы T1 и T0 совместимы;
2) один из типов есть WORD, а другой - любой однословный тип;
3) T1 и T0 есть процедурный типы и они процедурно совместимы.

Отношение обобщенной совместимости симметрично.

     5.3.1.3.  Тип  T1  совместим  по присваиванию с типом T0,
если истинно одно из следующих утверждений:

1) типы T1 и T0 обобщенно совместимы;
2) T1 и T0 есть типы массивов литер и длина  (число элементов)
   массива T1 не меньше длины массива T2;
3) T1 есть массивов  литер, а T2 константа типа CHAR;
4) T1 и T0 есть типы массивов, гибких массивов или динмассивов
   и  хотя  бы  один из них является типов гибкого массива или
   динмассива и их базовые типы совместимы;

Отношение совместимости по присваиванию несимметрично.

Отличия от Cообщения [5]:

     -  в  утверждении  2  по сообщению правым операндом может
быть только цепочка (т.е. строковая константа);
     -  разрешены  присваивания гибких массивов  целиком;  при
исполнении  проверяется,  что  размеры  массивов  равны, а для
массивов  литер, что число элементов левого операнды не меньше
числа элементов правого операнда.

     5.3.1.4.  Тип  T1  процедурно  совместим с типом T0, если
истинны ВСЕ следующие утверждения:

1)   если   T1   есть   процедура-функция,  то  T2  тоже  есть
процедура-функция и типы результатов обобщенно совместимы;
2) число параметров у процедур одинаково;
3) соответствующие параметры имеют одинаковый способ передачи;
4)  у  параметров  типа гибкий массив типы элементов обобщенно
совместимы, типы остальных параметров обобщенно совместимы.


     5.3.1.5. Передача параметров

Основное правило:

     Тип параметра-переменной должен быть обобщенно совместимы
с  типом фактического параметра. Тип параметра-значения должен
быть совместим по присваиванию с типом фактического параметра.
Если  тип  формального  параметра - гибкий массив слов, то тип
фактического  параметра  должен  быть массивом (любым), а типы
элементов  формального  и  фактического параметров должны быть
совместимы.

Параметры-последовательности:

     Вместо   формального  параметра-последовательности  может
быть  подставлена  последовательность  параметров  любой длины
(возможно  пустая)  или  один фактический параметр, являющийся
формальным параметром-последовательностью.
     В первом случае тип каждого фактического параметра должен
быть обобщенно совместим или совместим по присваиванию с типом
последовательности  (в  зависимости  от  способа передачи). Во
втором   случае  способ  передачи  последовательностей  должен
совпадать, а типы быть обобщенно своместимы.

Исключения:

     1)  Если  тип  формального  параметра  -  массив слов, то
фактическим  параметром  может быть объект любого структурного
типа  той же длины.
     2)  Если  тип формального параметра - гибкий массив слов,
то   фактическим   параметром   может   быть   объект   любого
структурного  типа.
     3)   Если  тип  последовательности  есть  WORD,  то  типы
фактических  параметров  могут  быть любыми. При этом если тип
фактического  параметра  есть  тип  записи,  массива,  гибкого
массива  или динмассива, то в качестве параметра будет передан
адрес структуры.


     5.3.2. Структура компилятора

     5.3.2.1. Интерфейс компилятора

     Тексты  модулей  приводятся в качестве примера и могут не
полностью   совпадать  с  библиотеками  текущей  версии  ОС  и
компилятора.

     Модуль   coolDefs   определяет   представление   операций
ввода/вывода.

DEFINITION MODULE coolDefs; (* Ned 06-Jan-90. (c) KRONOS *)

IMPORT  SYSTEM;

CONST -- виды модуля/файла
  def    = 0;   -- определяющий модуль
  imp    = 1;   -- реализующий модуль
  main   = 2;   -- программный модуль
  text   = 3;   -- текст
  sym_in = 4;   -- входной симфайл
  sym_ou = 5;   -- выходной симфайл
  ref    = 6;   -- реффайл
  code   = 7;   -- кодофайл

TYPE
  PRINT  = PROCEDURE (ARRAY OF CHAR, SEQ SYSTEM.WORD);
  io_ptr = POINTER TO io_rec;
  io_rec = RECORD
             kind : INTEGER;            -- вид модуля/файла
             doio : PROCEDURE (io_ptr); -- операция в/в
             done : BOOLEAN;            -- результат операции
             print: PRINT;              -- для сообщений
             buf  : STRING;             -- буфер в/в
             len  : INTEGER;            -- длина в/в
             exts : SYSTEM.ADDRESS;     -- расширение
           END;

TYPE
  INI    = PROCEDURE (VAR    io_ptr,    -- дескриптор в/в
                      ARRAY OF CHAR,    -- имя модуля/файла
                      INTEGER,          -- вид модуля/файла
                      PRINT             -- для сообщений
                     );
  EXI    = PROCEDURE (VAR io_ptr);
  ERROR  = PROCEDURE (
                       INTEGER,         -- номер строки
                       INTEGER,         -- позиция в строке
                       ARRAY OF CHAR,   -- строка текста
                       ARRAY OF CHAR,   -- формат
                       SEQ SYSTEM.WORD  -- аргументы
                       );

END coolDefs.

     Модуль  определяет  тип  дескриптора  ввода/вывода,  виды
модулей/файлов,  вид  операций открытия/закрытия дескриптора и
сообщения об ошибках.
     В  процедуре  сообщения  об  ошибках первые два параметра
определяют  позицию  ошибки  в тексте, а последние два - текст
поясняющего сообщения.

Модуль coolIO реализует операции файлового ввода/вывода.

DEFINITION MODULE coolIO; (* Ned 04-Mar-90. (c) KRONOS *)

IMPORT  comp: coolDefs;

PROCEDURE ini(VAR io: comp.io_ptr;
                name: ARRAY OF CHAR;
                unit: INTEGER;
               print: comp.PRINT);

PROCEDURE exi(VAR io: comp.io_ptr);

PROCEDURE set(text_path,sym_path,out: ARRAY OF CHAR; print: comp.PRINT);

PROCEDURE dispose;

END coolIO.

     Модуль   mxPars   реализует   операцию  compile,  которая
параметризована операциями ввода/вывода.

DEFINITION MODULE mxPars; (* Ned 06-Dec-87. (c) KRONOS *)

IMPORT SYSTEM;

IMPORT  comp: defCompiler;

PROCEDURE compile(text : comp.io_ptr;
                  ini  : comp.INI;
                  exi  : comp.EXI;
                  error: comp.ERROR;
                  print: comp.PRINT;
                  opts : BITSET;
                  cpu  : INTEGER;
                  );

PROCEDURE fault(format: ARRAY OF CHAR; SEQ args: SYSTEM.WORD);

END mxPars.

     Процедура compile в качестве параметров получает открытый
дескриптор  файла входного текста, процедуры открытия/закрытия
дескриптора,  процедуры  вывода  ошибок и сообщений, множество
режимов компилятора и номер версии системы команд.
.PAGE
.HEAD 0 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ       СРЕДСТВА ОТЛАДКИ И ВИЗУАЛИЗАЦИИ@u'
.HEAD 1 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ       СРЕДСТВА ОТЛАДКИ И ВИЗУАЛИЗАЦИИ@u'
.HEAD 2 ''
.HEAD 3 ''



                    Глава 5.4. Средства отладки и визуализации


     К  средствам отладки программ относятся историк, выдающий
историю  неудавшегося  процесса в терминах текста программы, и
визуализатор кода и других атрибутов программы.


     5.4.1. Визуализация М-кода

     Визуализацию  кода  осуществляет  утилита  vx.
     Для  работы утилиты необходим, как минимум, кодофайл. При
этом можно узнать следующее:
     - коды процедур (имена процедур недоступны);
     - строковый пул;
     - список  внешних  и,  при  необходимости, прогуляться по
       дереву импорта;
     - мультиглобалы;
     - общую  информацию  о  модуле (версия компилятора, время
       компиляции и т.д.).

     Кроме   того,   при   наличии   реффайла  утилита  выдает
информацию "по полной программе":
     - описание процедуры: имя, параметры, локалы;
     - типы;
     - глобалы: имя, тип;
     - структурные константы.

     Подробное  описание  утилиты  vx читайте в справочнике по
утилитам.

     5.4.2. Посмертный историк

     Историю неудавшегося процесса выдает утилита hi.
     Подробное  описание  утилиты  hi читайте в справочнике по
утилитам.

     5.4.3. Симфайлы, кодофайлы и реффайлы

     Этот  пункт  пока  не  написан.  Возможно, он появится не
скоро,   или  даже  вовсе  никогда  не  появится,  потому  что
информация,  которую  ему  следовало  бы  содержать, по мнению
разработчика,  является  делом  текущей  версии  компилятора и
подвержена   периодическим   изменениям.  Как  следствие,  эта
информация  уже  изложена  в соответствующих "холодных" (cool)
библиотеках.

     Читайте о cимфайлах в комментарии к библиотеке coolSym.
     Читайте о кодофайлах в комментарии к библиотеке visCode.
     Читайте о реффайлах в комментарии к библиотеке xRef.
.PAGE
.HEAD 0 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ            ЕЩЕ О МОДУЛА-X КОМПИЛЯТОРЕ@u'
.HEAD 1 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ            ЕЩЕ О МОДУЛА-X КОМПИЛЯТОРЕ@u'
.HEAD 2 ''
.HEAD 3 ''



                         Глава 5.5. Еще о Модула-X компиляторе

                                          Предисловие соавтора

     Этот   раздел   написан  А.Недорей  (Ned),  автором  ныне
здравствующего  Модула-компилятора  (mx) вскоре после создания
последнего.  Первоначально  это  задумывалось  как  статья, не
предназначающаяся   для  публикации  в  официальных  изданиях.
Поэтому я рада, что изложенная в ней информация впервые увидит
свет  на  страницах  нашей  книги.  Этот  материал  адресуется
разработчикам компиляторов, отладчиков и комплексаторов (?), а
также посмертным историкам.


                           ВВЕДЕНИЕ
              В  котором автор попробует понять,
            зачем ему понадобилось писать еще один
                     Модула-2 компилятор

     Причины  (как  обычно) бывают субъективные и объективные,
причем важными являются только субъективные (в данном случае -
ровно  одна субъективная причина), а объективные предназначены
для  того,  чтобы убедить себя и других в необходимости делать
то,  что  хочется.  Так  вот,  субъективная причина была очень
проста: хотелось написать компилятор, который можно развивать,
который послужит основой для других разработок.

     Теперь  перечислим  те  объективные  соображения, которые
послужили   толчком   к  началу  разработки  компилятора.  Они
приводятся в некотором случайном порядке (не по важности).

     1.  Любое  программное  обеспечение  морально устаревает,
принципы его построения, интерфейсы с ОС, СП и пользователем с
какого-то   момента  не  соответствует  изменившимся  взглядам
разработчиков и пользователей.

     2.  Если два года назад (когда был написан наш предыдущий
компилятор,   далее   -  m2)  проблемы  переносимости  нас  не
волновали  (хоть  бы  для  Кроносов  что-нибудь  написать), то
теперь  мы  собираемся  переносить свое ПО на все 32-разрядные
микропроцессоры,  и  в  том числе на разные Кроносы (а система
команд  для  кристалла (4.X) достаточно существенно отличается
от системы команд семейства 2.X).

     3.  При  разработке и эксплуатации компилятора m2 входной
язык  был  расширен,  часть этих изменений стали стандартными,
часть   в  процессе  использования  были  признаны  ненужными.
Разработка  нового  компилятора позволяет реализовать принятые
расширения   естественно  (без  ограничений),  так  как  набор
расширений известен с начала разработки.

     4. И так далее.

КОНЕЦ Введения.

ПРИМЕЧАНИЕ:

     Далее  в  тексте  используется  терминология, введенная в
[5,6], например, иннерфейс, экстерфейс [5], фильтр [6].


                         ГЛАВА ПЕРВАЯ
        В которой изложены особенности входного языка

     Особенности входного языка изложены в документации (см).


                         ГЛАВА ВТОРАЯ
                      (Из трех взглядов).
      В которой автор показывает mx со всех трех сторон.

ВЗГЛЯД 1. mx со стороны пользователя

     Вид  с  этой  стороны  не должен вызвать интереса у людей,
знакомых с m2. Как и m2, mx един в нескольких лицах:
     - пакетная версия  (утилита mx);
     - турбо-компилятор (фильтр  turbo2x);
     - турбо-тестер     (фильтр  tester2x);
     - и так далее.

     Пакетная  версия  читает  исходный текст из файла и пишет
результаты компиляции (кодофайл и симфайл) на диск.
     Фильтр  turbo2x  читает  текст  из  буфера  редактора,  а
результаты пишет в файлы.
     Турбо-тестер  (см.  главу  3)  используется  для  отладки
компилятора.  Он читает текст (множество единиц компиляции) из
буфера   редактора,   пытается  выполнить  те  тесты,  которые
скомпилировались, сравнивает результаты компиляции и запуска с
тем,   что  должно  было  быть,  и  сообщает  о  расхождениях.
Кодофайлы   и   симфайлы   хранятся  в  оперативной  памяти  и
уничтожаются после выполнения теста.


ВЗГЛЯД 2. mx со стороны разработчика системы программирования

     Все  утилиты,  описанные  в  первом  взгляде,  пользуются
некоторой  библиотекой, которая позволяет просто писать разные
(с  точки  зрения  пользователя)  версии  Модула-компиляторов.
Собственно  говоря,  эта  библиотека  и есть mx, а все утилиты
реализуют  методы ее использования. Внутри данного взгляда под
словом  "пользователь"  мы  будем  понимать  пользователя этой
"библиотеки" (т.е. разработчика очередного "пускача").
     Библиотека mx - это  слоеный пирог (терминология из [5]):

                 +---------------------------+
                 |   Интерфейс с системой    |
                 |       (иннерфейс)         |
                 +---------------------------+

                 +---------------------------+
                 |       ЧЕРНЫЙ ЯШИК         |
                 +---------------------------+

                 +---------------------------+
                 | Интерфейс с пользователем |
                 |       (экстерфейс)        |
                 +---------------------------+

     Интерфейс  с  системой  определяет  модуль mxSystem. Этот
модуль  предоставляет  остальному компилятору все возможности,
которые  нужны  от  системы,  кроме  операций чтения исходного
текста,  записи выходных файлов и выдачи сообщений об ошибках.
Операции   ввода/вывода   определяются   каждой  компилирующей
утилитой.
     Интерфейс  с пользователем определяют модули defCompiler,
mxPars  и  mxIO.  Модуль  defCompiler определяет представление
операций   ввода/вывода.   Модуль  mxPars  реализует  операцию
compile,   которая  параметризована  операциями  ввода/вывода.
Модуль  mxIO  предоставляет  стандартные  реализации  операций
ввода/вывода.

     Продемонстрируем использование этих модулей при написании
пакетного компилятора:

MODULE компилятор;

IMPORT  comp: defCompiler;
IMPORT    mx: mxPars;
IMPORT    io: mxIO;

VAR
  text: io.io_ptr;
  name: ARRAY [0..255] OF CHAR;

BEGIN
  инициализация;
  WHILE есть_что_компилировать DO
    следующее_имя_файла(name);                  (*0*)
    io.ini(text,name,comp.text,mx.fault);       (*1*)
    IF text^.done THEN                          (*2*)
      mx.compile(text,io.ini,io.exi,....);      (*3*)
    END;
    io.exi(text);                               (*4*)
  END;
END компилятор.

(*0*)  Выбор следующего имени файла;
(*1*)  Начало работы с текстом из файла с именем name;
(*2*)  Если файл успешно открылся;
(*3*)  Компиляция;
(*4*)  Конец работы с текстом.


ВЗГЛЯД 3. mx изнутри

     Теперь  рассмотрим  то,  что находится в черном ящике для
взгляда 2. Компилятор состоит из 5 модулей:

     mxScan  -- лексический анализ;
     mxObj   -- таблица объектов, видимость, импорт/экспорт;
     mxSym   -- чтение/запись симфайлов;
     mxCmd   -- примитивы генерация кода;
     mxGen   -- генерация кода;
     mxPars  -- синтаксический анализ.

     ----------------------------------------------------
      Модуль    |        Число строк       | размер кода
                | определение | реализация | (в байтах)
     -----------+-------------+------------+-------------
      mxScan    |     115     |     646    |     3624
      mxObj     |     279     |     679    |     2988
      mxSym     |      13     |     602    |     3468
      mxCmd     |     215     |    1780    |     7184
      mxGen     |     254     |    2177    |    11084
      mxPars    |      39     |    1486    |     7732
     -----------+-------------+------------+-------------
      ИТОГО     |     915     |    7370    |    36080
     ----------------------------------------------------

     Все  генерация  сосредоточена  в  модулях  mxGen и mxCmd.
Модуль       mxCmd      содержит      примитивы      генерации
(аппаратно-зависимые),   а   модуль   mxGen  языково-зависимую
генерацию.   При   генерации   делается   щелевая  оптимизация
(аналогично  m2)  и оптимизация структур управления. На тестах
со  сложными  управляющими  структурами оптимизация управления
может   дать   существенное  ускорение.  Так,  известный  тест
"dhrystone",  скомпилированный  mx, работает на 10% быстрее по
сравнению с m2.
     Интерфейс  с модулем mxGen выдержан в машинно-независимых
терминах,   что   позволяет  надеяться  на  простоту  переноса
компилятора на другие архитектуры.


                         ГЛАВА ТРЕТЬЯ
      В которой описывается процесс отладки компилятора

     Для   отладки   компилятора   использовался  турбо-тестер
(упомянутый   в   предыдущей   главе)   и  набор  тестов  [7],
дополненный  автором. Набор тестов содержит тесты, проверяющие
корректность  реализации различных конструкций языка, тесты на
граничные   условия,   тесты   на  исключительные  ситуации  и
диагностику ошибок.

Примеры:

     Следующие  два  теста  проверяют  корректность реализации
следующего правила из описания языка:
     "Тип Т1 может использоваться в описании типа указателя Т,
тесктуально предшествующего описанию Т1, если Т и Т1 описаны в
одном блоке."

     Первый   тест  проверяет  то,  что  такое  описание  типа
указателей  разрешено;  второй  - то, что компилятор проверяет
ограничение  правила, то есть что оба типа должны быть описаны
в одном блоке.

$x
MODULE T6P7D4;  (* Conformance *)

FROM InOut IMPORT WriteString;

TYPE T  = POINTER TO T1;

TYPE T1 = RECORD
            X: INTEGER;
            Y: BOOLEAN
          END;

BEGIN
   WriteString('PASS...6.7-4',12)
END T6P7D4.

$
MODULE T6P7D5;  (* Deviance *)

FROM InOut IMPORT WriteString;

TYPE P = POINTER TO T;

PROCEDURE p;
  TYPE T = BOOLEAN;
BEGIN
   WriteString('DEVIATES...6.7-5',16)
END p;

BEGIN
  p;
END T6P7D5.

Специальные   строки  в  тексте,  начинающиеся  символом  '$',
указывают  турбо-тестеру,  что  должна  дать  проверка  данным
тестом.

УправляющаяСтрока = "$" [ "c" | "x" ]

Символ  "x"  указывает,  что  тест должен быть скомпилирован и
удачно   исполнен;   символ   "c"   -  что  тест  должен  быть
скомпилирован и неудачно исполнен (исключительная ситуация при
исполнении);   отсутствие   символов   указывает  на  то,  что
компилятор  должен  обнаружить  ошибки  в  тесте. Турбо-тестер
выдает  список  имен тестов, при проверке которых результат не
соответстввует требуемому.

     Следующий  тест  проверяет,  ведется  ли  контроль границ
индексов при исполнении программы.

$c
MODULE T8P1D5;

FROM InOut IMPORT WriteString;

VAR a: ARRAY [2..5] OF INTEGER;
    i: INTEGER;

BEGIN
  i:=1;
  A[i]:=1;
  WriteString('ERROR IS NOT DETECTED...8.1-5',30)
END T8P1D5.

     Турбо-тестер  позволяет исполнить полный (около 250 штук)
или частичный набор тестов после каждого изменения компилятора
и  проверить  корректность этого изменения и то, что изменение
не  повлияло на реализацию других конструкций языка. Благодаря
наличию системы тестов и мощной поддержки тестирования удалось
очень быстро получить надежный и стабильный компилятор.

                       ГЛАВА ЧЕТВЕРТАЯ
                В которой автор говорит всем,
              кто поддерживал его в этой работе
               и отдельно Д.Г.Фон-Дер-Флаассу,
    принимавшему активное участие в разработке алгоритмов
               оптимизации структур управления,

                       БОЛЬШОЕ СПАСИБО
.PAGE
.HEAD 0 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ                            ЛИТЕРАТУРА@u'
.HEAD 1 '@UСИСТЕМА ПРОГРАММИРОВАНИЯ                            ЛИТЕРАТУРА@u'
.HEAD 2 ''
.HEAD 3 ''














                     Л И Т Е Р А Т У Р А


     1.  N.Wirth  Programming  in  Modula-2.  Third, Corrected
Edition. Springer-Verlag. Berlin, Heidelberg, New-York, 1985.
     2.  N.Wirth.  A  fast  and compact compiler for Modula-2.
ETH, Zurich, July 1985, 64, pp. 1-22.
     3. N.Wirth. The Programming Language Oberon.
     4. Second Working Draft Modula-2 Standard. Document D103.
BSI Modula-2 Standartisation Working Group (IST/5/13).
     5.  Н.Вирт  Программирование  на  языке Модула-2. Москва,
Мир, 1987.
     6. Кузнецов Д.Н., Недоря А.Е., Тарасов Е.В., Филиппов В.Э.
КРОНОС  -  автоматизированное  рабочее место профессионального
программиста.   В   сб.:   Автоматизированное   рабочее  место
программиста. Новосибирск, 1988.
     7.  Кузнецов  Д.Н.,  Недоря  А.Е.  Турбо-компиляция.  Что
дальше? (рукопись).
.PAGE
.HEAD 1 "@USHELL                                ОКРУЖЕНИЕ И ЕГО ПАРАМЕТРЫ@u"
.HEAD 0 "@USHELL                                ОКРУЖЕНИЕ И ЕГО ПАРАМЕТРЫ@u"
.HEAD 2 ''
.HEAD 3 ''
         Часть 7. SHELL: ПОЛЬЗОВАТЕЛЬСКАЯ ОБОЛОЧКА ОС

                                          Предисловие соавтора

     Эта  часть  написана  в соавторстве с А.Хапугиным (Hady),
реализовавшим  ныне здравствующую пользовательскую оболочку, а
также интерпретатор командныхх файлов mshell.

                                                       Cоавтор


     Пользовательская   оболочка   системы  shell  -  основнoe
средство  общения  с  операционной  системой.  С помощью shell
можно  изменить  обстановку работы как себе, так и окружающим,
запустить  или  прекратить  задачу,  а  также узнать кое-что о
состоянии ОС.
     Для  работы с пользовательской оболочкой достаточно этого
описания.  Но  если читатель хочет продвинуться дальше, понять
смысл   средств   и   ограничений  shell,  мы  посоветуем  ему
ознакомиться с комментариями к библиотекам Shell и exeCut.


                          Глава 7.1. Окружение и его параметры


                         Не  имея достаточно  средств и будучи
                    отфутболенным  различными бюрократами, она
                    у меня пока не полностью автоматизирована.
                    Вопросы  задаются  устным  образом, и я их
                    печатаю  и  ввожу к ей внутрь, довожу, так
                    сказать,  до  ейного  сведения.  Отвечание
                    ейное,    опять    же    через    неполную
                    автоматизацию, печатаю снова я.

                           А. и Б. Стругацкие. Сказка о Тройке


     7.1.1. Приглашение к вводу команды

     Большую часть времени, занимаемого утилитой у компьютера,
она тратит на ввод команд с клавиатуры и попытку их исполнить.
Выдавая   на  экран  строчку-приглашение,  утилита  приглашает
пользователя ввести строку-команду.
     Стандартное  приглашение  состоит  из  текущего времени и
текущей директории и выглядит приблизительно так:

     12:35 dir $

     Если  оно  не  подходит  вам,  его легко поменять, набрав
PROMPT="приятная_глазу_строка". Теперь в качестве приглашениея
будет выдаваться

     приятная_глазу_строка

В  нее могут быть включены последовательности из двух символов
%/  и  %t,  которые  перед выводом строки-приглашения на экран
заменяются  на  имя  текущей  директории  и  на  текущее время
соответственно.
     Например, было указано приглашение

     PROMPT="Время: %t Директория: %/ >> "

     Eсли  сейчас  12  часов  35 минут, а текущая директория -
"/usr/John/games",   то   строка-приглашение  будет  выглядеть
теперь следующим образом:

     Время: 12:35 директория: games >>

     Впрочем,  такое  длинное  приглашения  не  очень  удобно,
поэтому  будем  считать,  что  установлено  приглашение "]", и
именно   им  будем  предварять  изображаемые  далее  командные
строки.

     Конец 7.1.1.

     Установив  новое  приглашение,  вы,  сами  того  не зная,
изменили  значение  одного  из  параметров своего окружения, а
именно параметра PROMPT.
     Каждая   задача   запускается   в   некотором  окружении,
содержащем  необходимую  (по  крайней мере, не вредную) для ее
исполнения  информацию.  Окружение  задачи  (а  shell  -  тоже
задача)  состоит  из  набора  ПАРАМЕТРОВ,  у  которых есть имя
("PROMPT")  и  значение (теперь "]").
     Откуда  берется  окружение  вновь запускаемой задачи? Его
создает запускающая задача (в нашем случае shell) при запуске.
Получает  она его простым копированием почти всех (подробности
см. в п.7.3.6) параметров своего собственного окружения.


     7.1.2. Изменение параметров окружения

     С  клавиатуры можно задать или изменить (если уже задано)
значение  любого  параметра,  набрав  строку  "ИМЯ=тело",  и в
окружении вашей shell параметр ИМЯ примет значение "тело".
     Обратите  внимание:  если "тело" не содержит пробелов, то
брать его в кавычки необязательно.
     Удалить  параметр  из  окружения  еще  проще:  достаточно
сказать "ИМЯ=", и параметр с именем "ИМЯ" исчезнет.


     7.1.3. Изменение параметров чужого окружения

     Можно сменить окружение не только вашей shell, но и любой
другой задачи. Для этого перед именем параметра надо поставить
номер задачи, у которой требуется сменить параметр, и отделить
этот  номер  от  имени точкой, например:
     ]69.PROMPT="ex.shell>>"

     Вместо  номера годится и имя уже существующего параметра,
если  его  значение  - запись какого-нибудь целого числа, как,
например,  у параметров FATHER, TASK или BASE. Для этого нужно
поставить  имя этого параметра вместо номера и предпослать ему
символ "$, например:

     ]$FATHER.INFO="кафолик недорезанный"

     Такая  возможность  дает,  естественно, почву для мелкого
хулиганства, но есть у нее и серьезные применения, о которых -
в главе про командные файлы.
     Следует   при   этом   помнить,  что  если  номер  указан
неправильно,  или задачи с таким номером не существует, то вся
конструкция  "НОМЕР.ИМЯ"  будет  проинтерпретирована  как  имя
нового параметра.


     7.1.4. О приватных параметрах

     Есть  еще одна маленькая тонкость: если перед именем (или
номером  задачи  и  именем,  если речь идет о чужом окружении)
параметра  поставить  ".",  то  эта  точка  не  войдет  в  имя
получившегося   параметра,   а  станет  признаком  приватности
параметра:  такой  параметр  не будет копироваться в окружения
задач,  запущенных  вашей  shell.  А если вам все-таки хочется
начать  имя  параметра  с точки, то поставьте перед ней символ
"\".

     7.1.5. Имя параметра вместо его значения

     Если  требуется  передать  значение  параметра в качестве
аргумента  какой-либо  команде, вместо значения можно написать
имя параметра, предварив его символом "$".
     При  выполнении  любых  действий  shell заменяет в строке
аргументов  действия  все  комбинации  вида "$ИМЯ" на значения
параметров с именем "ИМЯ", если они есть в окружении, и только
потом исполняет действие.
.PAGE
.HEAD 1 "@USHELL                                            КОМАНДЫ SHELL@u"
.HEAD 0 "@USHELL                                            КОМАНДЫ SHELL@u"
.HEAD 2 ''
.HEAD 3 ''


                                      Глава 7.2. Команды shell

     Кроме  параметра  "PROMPT", в окружении вашей shell может
быть  (и  обычно бывает) много других параметров. Некоторые из
них  заметным  образом  влияют на поведение shell, а некоторые
отражают  ее  состояние.  Значения  основной  части параметров
демонстрирует команда "set".


     7.2.1. Как узнать текущие значения параметров (set)

     По  команде  "set" shell печатает на экране состояния тех
параметров, которые считает существенными. Команда

     ]set

вызовет появление на экране следующей информации:

      USER       "Iam"
      HOME       "/usr/Iam"
      NAME       "shell"
      TASK       "155"
      FATHER     "66"
      BASE       "155"
      SHELL      "shell"
      STK        "8"
      CEMETRY    "1"
      CD         "/usr/Iam/my_dir"
      BIN        ". /bin /usr/bin"
      SYM        ". /sym /usr/sym"
      ETC        ". /etc /usr/etc"
      REF        ". /ref /usr/ref"
      TTY        "/dev/tty2"
      KEY        "/dev/key2"
      PROMPT     "%t %/ $ "
      INSERT     "1"
      ECHO       "0"
      BELL       "1"


     Еще   раз  заметим,  что  это  не  все  параметры  вашего
окружения,  наверняка  есть  еще  и  другие. Можно узнать и их
значения. Наберите

     ]set S*

      SYM        ". /sym /usr/sym"
      SCR        "/dev/bmap"
      STK        "4"
      SHELL      "mshell"

     Можно заметить, что кроме того, что напечатаны параметры,
имена  которых начинаются на "S", появился еще один параметр с
именем "SCR".
     Аргумент  команды  set  "S*"  использован  как регулярный
образец,   и  команда  напечатала  все  параметры,  чьи  имена
сопоставились с этим образцом. Если учесть, что с образцом "*"
сопоставляются  все строки, то ясно, что посмотреть совсем все
параметры можно, набрав

     ]set *

      FATHER     "66"
      BASE       "48"
      TASK       "48"
      ARGS       ">t"
      NAME       "t"
      HOME       "/usr/hady"
      USER       "hady"
      REF        ". /ref /usr/ref"
      SYM        ". /sym /usr/sym"
      PROMPT     "%t %/ $ "
      BELL       "1"
      LP         "/dev/lp0"
      CPD        "/dev/mou0"
      MSG        "/dev/LATIN"
      SCR        "/dev/bmap"
      ETC        ". /etc /usr/etc"
      BIN        ". /bin /usr/bin"
      STK        "4"
      ECHO       "0"
      SHELL      "mshell"
      KEY        "/dev/key0"
      TTY        "/dev/tty0"
      CD         "/usr/hady/sh/doc"

     Конец 7.2.1.

     Ни  команда "set", ни модификации окружения не приводят к
запуску  каких-либо задач, эти команды - внутреннее дело самой
shell.  Есть  еще  несколько  команд, чье исполнение полностью
находится в компетенции shell. Остановимся на них подробнее.


     7.2.2. Информация о задачах (ps)

     По команде "ps" shell выдает на экран некоторую информацию
о  запущенных  в настоящий момент задачах, например:

     ] ps

     0153    run  ex            shell.doc
     0066    run  shell

     Первая  колонка - номера задач. Номер, в отличие от имени
задачи,  уникален,  и потому более удобен для работы с задачей
(прекращение, удаление, история завершения).
     Вторая колонка - состояние задачи. Кроме "run" (запущена)
задача  может  находиться  в  состояниях "stop" (остановлена),
"load" (загружена) или еще каком-нибудь.
     Третья колонка - имена задач.
     Четвертая    -   некая   дополнительная   информация.   В
приведенном  примере  видно,  что  редактор  "ex" сейчас занят
файлом  "shell.doc",  содержимое которого у вас перед глазами.
Заметим,  что  эта  дополнительная  информация  -  всего  лишь
строчка окружения задач с именем "INFO". Попробуйте набрать

     ] .INFO="кафолик недорезанный"

а потом спросить "ps":

     ] ps

и вы убедитесь в том, что программы тоже могут грубить:

     0153    run  ex            shell.doc
     0066    run  shell         кафолик недорезанный


     У  команды  "ps"  могут быть модификаторы "-tty", "-usr",
"-mem", "-l", "-all".

     7.2.2.1. Модификатор usr

     Наберите

     ]ps -usr

     0153    run  Iam   soft   ex            shell.doc
     0066    run  Iam   soft   shell

Появились  две новые колонки: имена пользователя и его группы.

     7.2.2.2. Модификатор tty

     ]ps -tty

     Модификатор   "tty"   добавит  колонку  с  информацией  о
терминале, с которого запущена задача.


     7.2.2.3. Модификатор mem

     ]ps -mem

     Модификатор  mem  добавит  информацию  о  памяти, занятой
задачей.

     7.2.2.4. Модификатор l

     Модификатор    "l"   заменяет   все   три   перечисленных
модификатора:

     ] ps -l

   0153  run  Iam  soft  62K+0624  /dev/tty2  ex     shell.doc
   0066  run  Iam  soft  22K+0316  /dev/tty2  shell


     7.2.2.5. Модификатор all

     Обратите внимание: все  показанные  задачи запущены одним
пользователем  -  вами, как будто других на машине нет. Может,
это  и так, но не всегда. Просто вам показывают НЕ ВСЕ задачи,
а  только  запущенные  с  вашим  пользовательским кодом. Чтобы
увидеть ВСЕ задачи, используйте модификатор "all":

     ] ps -all

  ...TASKS...
  0153    run  ex            shell.doc
  0066    run  shell
  0015  + run  login
  0012  + run  DK6fd4110
  0010  + run  TT6FCT
  0009  + run  SIq6
  0008  + run  CCDqMOUSE
  0007  + run  DK6qSCSI
  0006  + run  tmspo
  0005  + run  LEXICON
  0002  + run  TT6FCT
  0001  + run  DK6dq615

     Задач  стало больше! Теперь это действительно все задачи.
Модификатор  "-all" можно применять в комбинации с другими для
получения расширенной информации. Например,

     ] ps -all -mem
  ...TASKS...
  0153    run   62K+0624  ex            shell.doc
  0066    run   22K+0316  shell
  0015  + run   13K+0976  login
  0012  + run    7K+0476  DK6fd4110
  0010  + run    9K+0936  TT6FCT
  0009  + run    9K+0936  SIq6
  0008  + run   11K+0496  CCDqMOUSE
  0007  + run    7K+0936  DK6qSCSI
  0006  + run   13K+0976  tmspo
  0005  + run   15K+0352  LEXICON
  0002  + run    8K+0920  TT6FCT
  0001  + run    5K+0132  DK6dq615

ясно  показывает,  что  больше  всех  памяти  отъел редактор с
файлом "shell.doc", а что поделаешь?

     В  конце  строки можно указать номера задач, информацию о
которых  вы хотите получить. Если модификатор all отсутствует,
вы получите информацию только об указанных задачах.

     Символ  "+" сразу после номера задачи обозначает, что эта
задача  сейчас  находится в режиме привилегированного доступа.
Этот  режим  позволяет  иногда обойти ограничения, связанные с
защитой файлов. Перейти в него можно с помощью команды "su".


     7.2.3. Привилегированный доступ (su и us)

     Команда  "su" используется для переведения вашего shell'а
в   режим   привилегированного  доступа.  Чтобы  добраться  до
защищенных от вас файлов, наберите "su":

     ] su

     Вот  незадача! Требуют  пароль:

     password:

     Если  вы  знаете  его  - введите, и тогда вы, работая под
своим   именем,   сможете   попользоваться   привилегированным
доступом. Если не знаете - не сможете. А если вы администратор
системы,    никто    не   помешает   вам   сделать   в   своем
пользовательском коде специальную пометку, которая избавит вас
от  необходимости  знать  и набирать пароль: у вас его даже не
спросят.
     Поработав в привилегированном режиме, не забудьте от него
отказаться - так спокойнее. Это делается командой "us".


     7.2.4. Как гулять по директориям (cd)


                         Через  несколько  поколений картофелю
                    наскучил    оседлый    образ   жизни,   он
                    самостоятельно   выкопался   и  перешел  к
                    кочевому состоянию.

                         С.Лем. Звездные дневники Ийона Тихого


     Иногда  возникает желание (или даже необходимость) сменить
текущую директорию. Сделать это просто:

     my_dir] cd my_another_dir

     my_another_dir]

     Этот  номер  пройдет  гладко,  если  на  директории my_dir
действительно  имеется  директория my_another_dir. Если ее нет,
то вам намекнут на ошибку:

     my_dir] cd my_another_dir
     #no such entry: change_dir("my_another_dir")

     С  помощью  этой  команды  можно  узнать  и  имя  текущей
директории. Достаточно набрать просто "cd":

     my_dir] cd
     #current directory: /usr/Iam/my_dir

     Здесь  нелишне  упомянуть,  что  имя  текущей  директории
хранится в окружении под именем "CD" (этот параметр показывает
команда  "set").  Более  того: команда "cd any_name" полностью
эквивалентна команде "CD=any_name".


     7.2.5. Показ распределения памяти (mem)

     Команда  "mem"  демонстрирует  распределение  оперативной
памяти компьютера:

     ] mem

  ...MEMORY TOTAL...
     available  1024K+0000
     core        216K+0472
     free        356K+0068
     busy        451K+0484

Строчка  "available" обозначает полный объем памяти, доступной
системе,  "core"  -  объем  памяти, занятой системой, "free" -
объем свободной памяти, а "busy" - объем памяти, занятой всеми
задачами.


     7.2.6. История задачи (his)

                         Откинув  уши  на  плечи, он рассказал
                    мне историю своих соотечественников.

                         С.Лем. Звездные дневники Ийона Тихого


     Команда   "his"  печатает  на  экране  историю  последней
неудачно  закончившейся  задачи.  Если таковых еще не было, на
экран выдается

     #no history

     С  помощью команды his можно узнать историю любой задачи,
еще  находящейся  в  памяти,  даже  если она не завершена. Для
этого достаточно указать этой команде номер нужной задачи.

Замечание. Параметр окружения HISTORY хранит историю последней
           неудачно  завершившейся  задачи  или  строчку  "#no
           history",  если  задачи  не  было.  При  вызове без
           указания номера задачи команда просто распечатывает
           содержимое параметра.


     7.2.7. Задержка на несколько секунд (delay)

     Команда

    ] delay N

,  где  N  -  целое  число,  приведет к тому, что shell просто
ничего  не  делает  N  секунд. Такое действие может показаться
странным,  но оно бывает полезным в некоторых "хитрых" случаях
администратору системы.

     Администратору  системы  будут  полезны  и  следующие две
команды: "mount" и "unmount".


     7.2.8. Монтирование дисков (mount,unmount)

     Команда   "mount"   позволяет  изменить  файловое  дерево
методом   монтирования   нового   диска   вместо  какой-нибудь
директории. Например,

     ] mount /mnt /dev/fd0

приводит  к  тому,  что если устройство /dev/fd0 существует, и
если  оно  -  диск  с  нормальной  файловой  системой, а также
существует директория /mnt (и если она доступна пользователю),
то после исполнения вышеозначенного действия вместо директории
/mnt  в  файловом  дереве  будет корневая директория носителя,
находящегося на устройстве /dev/fd0.
     Правда,  при  таком  способе  монтирования  на  этот диск
записать ничего не удастся: он защищен системой от записи. При
желании  писать  на  него  после  монтирования нужно  добавить
модификатор "-ro":

     ] mount /mnt /dev/fd0 -ro

     Демонтировать  диск  и  получить, таким образом, доступ к
содержимому директории /mnt можно командой "unmount":

     ] unmount /mnt

Замечание. Вообще-то  в  системе  есть специальная утилита mou
           для    монтирования    и   демонтирования   дисков.
           Программисты  обычно  пользуются ею, потому что она
           удобней и много чего умеет.


     7.2.9. Управление задачами (stop, kill, wait)


                         -  ...  И  я,  старший здесь, нарушая
                    законы и правила, первый говорю: смерть!
                         Рядовые  члены  Тройки  вздрогнули  и
                    разом заговорили.
                         -  Которого?  - с готовностью спросил
                    Хлебовводов, понявший, по-видимому, только
                    последнее слово.

                           А. и Б. Стругацкие. Сказка о Тройке

     Команды   управления   могут   быть  названы  таковыми  с
некоторой   натяжкой,  поскольку  все  управление  сводится  к
прекращению  (stop),  удалению  (kill)  или ожиданию окончания
(wait) задачи. Команды запускаются одинаково:

     ] wait   <номера_задач>

дождаться окончания задач с указанными номерами. Это ожидание,
если  оно  стало  слишком  тягостным, может быть в большинстве
случаев прервано с клавиатуры нажатием CTRL_C.

     ] stop   <номера_задач>

-  прекратить  исполнение  задач  с  указанными  номерами,  не
выгружая  их  из  памяти.  После выполнения этой команды можно
посмотреть историю задачи.

     ] kill   <номера_задач>

-   прекратить   исполнение  задач  с  указанными  номерами  и
выгрузить  их  из памяти. Если задача уже была остановлена, то
команда  только  выгружает ее из памяти. После этого от задачи
не остается уже ничего, даже ее трупа.

     Номера задач в строке аргументов перебираются до тех пор,
пока не встретится конец строки или неправильный номер.

     Заметим, что отсутствующую задачу можно считать нормально
законченной,  следовательно,  все  три  команды  не считают ее
отсутствие ошибкой.


     7.2.10. Завершение работы с shell

     Команда   bye   заканчивает   работу  с  пользовательской
оболочкой. После набора команды shell исчезает.

     Конец 7.2.10.


     Итак,   мы   познакомились   с   окружением   shell,  его
параметрами,  которые можно изменять как явно, так и с помощью
команд. Перечислим еще раз все команды shell:

     set   - показ текущих значений параметров;
     cd    - смена текущей директории;
     ps    - показ информации о задачах;
     mount, unmount - монтирование и демонтирование носителя;
     his   - показ истории задачи;
     mem   - показ распределения памяти;
     kill  - удаление задачи;
     wait  - ожидание завершения задачи;
     stop  - остановка исполнения задачи;
     delay - задержка на несколько секунд;
     su,us - переход к привилегированному доступу и обратно;
     bye   - завершение работы с shell.
.PAGE
.HEAD 1 "@USHELL                                             ЗАПУСК ЗАДАЧ@u"
.HEAD 0 "@USHELL                                             ЗАПУСК ЗАДАЧ@u"
.HEAD 2 ''
.HEAD 3 ''


                                       Глава 7.3. Запуск задач


     Если  введенная  строка  не  является  командой shell, то
shell  интерпретирует ее как имя запускаемой задачи и пытается
запустить эту задачу.


     7.3.1. Простой случай

     Простейший способ запустить задачу - набрать ее имя:

     ] ls

запустится  задача  "ls",  которая  показывает  имена  файлов,
расположенных на текущей директории.

     Если   дополнить   имя   задачи  расширением  ".cod",  то
произойдет то же самое. При этом нужно помнить, что поиск кода
задачи будет происходить сначала по памяти - по прямым предкам
новой  задачи,  а  затем  по диску - по директориям, описанным
строкой  "BIN"  окружения  пользователя  (читайте  об  этом  в
разделе  о  задачах  в  ОС  Excelsior). Если код не найден, то
shell сообщит об этом.

     Можно указать полное имя кодофайла. Например,

      ] /bin/ls

заставит  shell  временно поменять текущую директорию на /bin,
загрузить  задачу,  а  затем вернуться на прежнюю директорию и
запустить загруженную задачу.

     Часто    возникает    необходимость    передать   задачам
какие-нибудь аргументы. Аргументы вводятся после имени задачи.
На них распространяется Замечание из п.1.10. Например:

      ]ls $HOME

печатает имена файлов собственной директории пользователя.

      ]echo $HISTORY

выдает  значение  параметра HISTORY, если он есть в окружении;
иначе строчку $HISTORY.


     7.3.2. Запуск независимых задач

     По  способу  исполнения  задачи в ОС Excelsior делятся на
независимые (открепленные) и зависимые. Завершения независимой
задачи   никто   не   ждет;   она  исполняется  параллельно  с
исполнением  других  задач.  Завершения зависимой задачи shell
ожидает  и  освобождает  по  завершении занимаемые ею ресурсы:
закрывает  открытые  задачей  файлы, освобождает память из-под
задачи.
     Для  того,  чтобы  задача  запустилась  как  независимая,
поместите  символ "&" в конец строки аргументов:

     ]<задача> <аргументы> &

     Например:

     ]ls -1 >listing &

позволит  записать  в  файл listing список всех файлов текущей
директории  в  одну  колонку, а программист тем временем может
заниматься редактированием какого-нибудь текста.
     Символ  "&"  из  строки  аргументов изымается и задаче не
передается.  При  необходимости передать именно его в качестве
последнего аргумента предварите его символом "\".


     7.3.3. После того, как задача запущена

     7.3.3.1. Прекращение зависимой задачи

     После  запуска  зависимой  (неоткрепленной)  задачи shell
дожидается  ее окончания, и только после этого принимает новые
команды.
     При  желании  почти всегда задачу можно прервать нажатием
CTRL_C  на  клавиатуре, или открепить нажатием CTRL_X (случаи,
когда это невозможно, будут описаны позднее).


     7.3.3.2. Параметр CHAIN

     При   нормальном  окончании  зависимой  задачи  перед  ее
удалением  из  памяти  shell  проверяет в ее окружении наличие
параметра  "CHAIN",  и  если  он  есть  -  интерпретирует  его
значение как следующую команду.

Замечание. Среди  значений  параметра  "CHAIN"  не исполняются
           команды, описанные в п.п.1.2.-1.8., а также команда
           "bye".   (Вдумчивый   читатель,   прочитавший   уже
           описания библиотек Shell и exeCut, наверняка понял,
           откуда это ограничение, и теперь имеет повод слегка
           повеселиться   над   нами.   Что   ж,  нет  в  мире
           совершенства ...)


     7.3.3.3. О трупах задач зависимых и независимых

     Если  зависимая  задача  завершилась нормально, ее "труп"
(коды, процедурный стек, глобалы, созданные задачей структуры)
удаляется системой из памяти автоматически.
     Если  же  она  завершилась аварийно, ее труп удаляется из
памяти  только  тогда, когда в окружении shell нет параметра с
именем  "CEMETRY", или его значение - ноль. В противном случае
несчастные  останки  остаются  в  памяти  до  явного  удаления
(например, командой "kill").
     Остаются  в  памяти  также  и  трупы аварийно законченных
независимых задач до явного их уничтожения командой kill.
     Кстати, пока труп не удален из памяти, можно ознакомиться
с  историей болезни с помощью команды his (программисты обычно
пользуются  утилитой  hi,  которая  предоставляет информацию в
более удобной форме, см. справочник по утилитам).

     Теперь  вы,  пожалуй,  знаете,  как  запустить задачу, но
некоторые тонкости этого действия заслуживают более подробного
разговора.


     7.3.4. Управление деревом задач


Замечание. При     возникновении     неясностей,    касающихся
           организации  дерева  задач,  советуем  обратиться к
           разделу, посвященному задачам в ОС Excelsior.

     Любая  задача  создается  на  базе  другой задачи. Термин
"создание   на   базе"  здесь  обозначает,  что  новая  задача
становится  потомком  другой,  на  чьей  базе  она  создана, а
задача-база, в свою очередь, - предком новой задачи.
     Что  означает отношение потомок-предок? Это означает, что
кодофайлы  для  новой задачи сначала будут разыскиваться по ее
прямым  предкам,  начиная от задачи-базы, а также задача может
разделять  глобалы  какого-либо модуля только с одним из своих
предков.  И  еще:  при  любом  окончании задачи все ее потомки
бессердечно уничтожаются.

     Номер  задачи-базы  shell  извлекает  из  параметра  BASE
своего  окружения.  Отсутствие  такого  параметра  приводит  к
невозможности запустить какую-либо задачу.

Замечание. По соглашениям ОС Excelsior iV, все задачи начинают
           нумероваться с единицы (1). Если значение параметра
           BASE  равно  0,  это  означает, что в качестве базы
           задачи   используется   ядро  ОС.  Это  может  быть
           полезным, например, при запуске драйверов.

     Ясно,  что  запускающая  задача  (в нашем случае shell) в
общем  случае  не имеет к базе никакого отношения - только то,
что  в  окружении  запускающей задачи указан номер задачи-базы
для всех запускаемых задач.


     7.3.5. Управление поиском кодофайлов

     Перед  именем  задачи  в  строке  может  находиться некая
информация, заключенная в фигурные скобки "{}". В частности, в
таких скобках можно указать способы поиска кодофайлов.

     Так,  комбинация  "-имя_модуля"  обозначает,  что  модуль
"имя_модуля" нужно обязательно загрузить с диска, даже если он
был  найден  у  одного  из  предков;  комбинация "+имя_модуля"
обозначает,  что модуль "имя_модуля" необходимо найти у одного
из   предков   и   не  копировать  его  глобалы  (считать  его
уникальным);  комбинация "=имя_модуля имя_файла" означает, что
модуль  "имя_модуля"  нужно взять с диска, причем искать его в
файле "имя_файла".
     Например:

     ]{+myEditor} turbo2x

запустит   в   редакторе   фильтр  turbo2x,  который  является
Модула-компилятором.    Так    простой    текстовый   редактор
превращается в турбину.

     Необходимо  учесть,  что  здесь  действует  Замечание  из
п.7.2.10 о копировании комбинаций типа "$NAME".

     Строчки    "+имя_модуля",   "-имя_модуля",   "=имя_модуля
имя_файла"  можно  занести в параметр окружения "ALIAS". После
этого  ВСЕ  запуски  задач  будут  осуществляться с указанными
изменениями.


     7.3.6. Управление окружением запускаемых задач

     Каждая   задача   запускается   с  некоторым  окружением.
Окружение   задачи   получается   простым   копированием  всех
параметров   окружения  запускающей  задачи  (в  нашем  случае
shell).  Надо учесть, что параметры, помеченные как приватные,
не копируются.
     При   этом   над  окружением  новой  задачи  производятся
следующие действия:
     - удаляется параметр "CHAIN";
     - создаются параметры "TASK", "FATHER", "NAME";
     -  если  отсутствует,  то  создается  параметр "BASE", со
значением, равным "TASK".
     И уже потом из части строки между скобками "{}", если она
есть,   выбираются   все   комбинации   вида  "NAME=string"  и
используются   как  указания  к  модификации  окружения  новой
задачи.

Замечание. Такие комбинации выбираются, начиная с символа "{",
           до  первой  неподходящей  комбинации; вся остальная
           строка   до   "}"   считается   изменением   поиска
           кодофайлов, о котором говорилось в п.7.3.5.


Таким образом, запуск  ls ../
эквивалентен           { CD=.. } ls
.PAGE
.HEAD 1 "@USHELL                                  ЗАПУСК КОМАНДНЫХ ФАЙЛОВ@u"
.HEAD 0 "@USHELL                                  ЗАПУСК КОМАНДНЫХ ФАЙЛОВ@u"
.HEAD 2 ''
.HEAD 3 ''



                            Глава 7.4. Запуск командных файлов


     Если   попытка   запустить   задачу   провалилась   из-за
отсутствия кодофайла (файла с расширением .cod), но в одной из
директорий,   перечисленных   в   параметре  "ETC"  окружения,
обнаружился     файл     с    именем    "имя_задачи.@"    (или
"имя_задачи.sh"),   то   shell   решит,  что  нужно  запустить
командный  файл  с  этим  именем. При желании запустить именно
командный  файл, даже если существует кодофайл с таким именем,
укажите имя с требуемым расширением.
     Иерархия   при   запуске   задачи   без  явно  указанного
расширения  будет  такая:  shell  сначала  разыскивает  файл с
расширением  ".@";  не найдя, ищет файл с расширителем ".cod";
если   же   и   такого  не  находит,  пытается  найти  файл  с
расширителем ".sh".
     Имеются  две  возможности  в зависимости от того, с каким
командным  файлом  мы  имеем  дело  - ".sh" или ".@".

     7.4.1. Запуск со специальным интерпретатором и без него

     Если  имя  командного  файла  имеет  расширение ".sh", то
происходит следующее.
     Для запуска командного файла shell ищет в своем окружении
параметр  с  именем  "SHELL",  считает  его  содержимое именем
установленного  интерпретатора  командных  файлов  и запускает
задачу  с  таким именем, поправив для нее строку параметров: в
ее  начало будет вписано имя командного файла с префиксом "<".
Например,  если  в вашем окружении "SHELL=mshell" и вы набрали
строку

     ] { CD=/usr/bin } /usr/games/comp.@ poker xonix

, то это эквивалентно запуску

     ] { CD=/usr/bin } mshell </usr/games/comp.@ poker xonix

     Отметим,  что  прелюдия в скобках "{}" относится к задаче
"mshell".
     Если   параметр   "SHELL"  в  окружении  отсутствует,  то
командный файл с расширением ".sh" не может быть запущен.


     Из  всего  сказанного можно сделать два тревожных вывода:
во-первых,  командный файл интерпретируется ОТДЕЛЬНОЙ ЗАДАЧЕЙ,
во-вторых - он интерпретируются не shell, а чем-то другим.
     Первое  замечание  очень важно, и мы его подробно обсудим
ниже  (7.4.3.),  а  по  поводу  второго скажем, что shell тоже
умеет  интерпретировать  командные  файлы,  и  имя shell можно
смело   указывать  в  строчке  окружения  SHELL.

Замечание. Более  того,  командный  файл  может быть запущен и
           проинтерпретирован  именно  тем  экземпляром задачи
           shell,   "под  которым"  вы  работаете.  Для  этого
           командный файл должен иметь расширение ".@".


     7.4.2. Как shell интерпретирует командный файл

     Командный файл полагается текстовым файлом с разделителем
между  строками  ASCII.NL  (код  036c).  Строки не должны быть
длиннее 255 символов (в противном случае выдается сообщение об
ошибке).  Если в прочитанной строке первый символ, отличный от
пробела,  равен  "%",  то  строка  считается комментарием и не
исполняется.
     В   строках,   прочитанных   из  файла,  комбинации  вида
"$1","$2".."$9"   заменяются   на   соответствующие  аргументы
командного   файла   с   номерами   соответственно  1,2..9  (в
приведенном  выше примере $1 обозначает "poker", $2 обозначает
"xonix",  а  остальные  обозначают  пустую строку). Комбинации
"\$" заменяются на "$", с отменой специального значения "$", а
комбинации  "\\" заменяются на "\". Результирующая (после всех
подстановок) строка тоже не должна быть длиннее 255 символов.
     Если  в  окружении shell'а-интерпретатора параметр "ECHO"
есть  и  не равен "0", то обработанная строка будет напечатана
на  экране  терминала.  В  тех же случаях печатаются на экране
строки-комментарии.
     После  всего  этого  строка будет исполнена, как будто ее
ввели с клавиатуры, кроме команды "bye".
     Учитывая,   что   утилита   shell   вполне  подходит  для
интерпретации  командных  файлов,  имеет  смысл  именно ее имя
хранить  в  окружении  под  именем  "SHELL"  (спросите  "set",
наверняка в вашем окружении так оно и есть).


     7.4.3. Кто исполняет командный файл?

     Тот   факт,  что  командный  файл  исполняется  отдельной
задачей, приводит к некоторым особенностям, которые необходимо
учитывать при его написании.
     Первая   особенность:   у   командного  файла  есть  СВОЙ
экземпляр  окружения.  Это  значит,  что  значения  параметров
окружения  командного  файла  могут  отличаться  от параметров
вашей   shell,   и  что  модификации  окружения  по  умолчанию
относятся к окружению именно командного файла, а не shell.
     Поясним это на примере. Набранные с клавиатуры команды

     ]echo $TASK
     ].INFO="кафолик недорезанный"

приведут  к  тому,  что  отпечатается  номер  вашей shell, и в
именно в окружении shell появится ругачая строчка.
     Эти  же  команды, помещенные в командный файл t.sh, после
исполнения последнего приведут к тому, что напечатается другой
номер  (а  именно - номер интерпретирующей shell), а окружение
вашей   shell   не   изменится   совсем  (изменится  окружение
shell-интерпретатора,  которое  пропадет  после завершения его
работы).
     Таким  образом, чтобы с помощью командного файла изменить
параметры  именно  вашего окружения, нужно предварить их имена
номером вашей shell. Если вы хотите, чтобы командный файл t.sh
исполнил  то,  что  от него ожидается, исправьте его следующим
образом:

     echo $FATHER
     .$FATHER.INFO="кафолик недорезанный"

     Вторая   особенность:  при  исполнении  командного  файла
клавиатурные  прерывания  (CTRL_X,  CTRL_C) действуют не на ту
задачу,  которая  запущена  из  командного  файла,  а  на весь
командный  файл  в  целом,  то есть CTRL_C прерывает, а CTRL_X
открепляет тот shell, который интерпретирует командный файл.
.PAGE
.HEAD 1 "@USHELL                                КОГДА CTRL_C НЕ ДЕЙСТВУЕТ@u"
.HEAD 0 "@USHELL                                КОГДА CTRL_C НЕ ДЕЙСТВУЕТ@u"
.HEAD 2 ''
.HEAD 3 ''


                          Глава 7.5. Когда CTRL_C не действует

                         Включив  тормоза,  я вдруг обнаружил,
                    что  они не действуют и что корабль камнем
                    падает  на  планету.  Выглянув  в  люк,  я
                    увидел, что тормозов вообще нет.

                         С.Лем. Звездные дневники Ийона Тихого


     Как   уже   говорилось,   по   соглашениям  ОС  Excelsior
существуют  два  символа, на которые установлена специфическая
реакция:   CTRL_X  и  CTRL_C.  Первый  обозначает  открепление
задачи,  второй - ее прекращение. Эти символы действуют на все
запущенные  вашим  shell задачи. Поскольку ваша shell запущена
не ей самой, она не прекращается по нажатии этих клавиш.
     Если вы запустили командный файл, то нажатием "CTRL_U" на
своей  клавиатуре  вы  прервете  исполнение  ВСЕГО  командного
файла,  а  не только той команды, которая исполнялась в момент
нажатия.
     Правда,   существует  исключительный  случай,  когда  эти
символы не действуют. Система предоставляет возможность задаче
иметь собственный обработчик символов, посланных с клавиатуры.
Перехватив  у  shell  посланный  CTRL_C, задача, имеющая такой
обработчик,  может  отреагировать  на  него  так,  как считает
нужным - например, никак не отреагировать.
.PAGE
.HEAD 1 "@USHELL                                   ОБЩЕЕ ОПИСАНИЕ УТИЛИТЫ@u"
.HEAD 0 "@USHELL                                   ОБЩЕЕ ОПИСАНИЕ УТИЛИТЫ@u"
.HEAD 2 ''
.HEAD 3 ''



                       Глава 7.6. Общее описание утилиты shell

                         -  Высочайшие  достижения  нейтронной
                    мегалоплазмы!  -  провозгласил он. - Ротор
                    поля наподобие дивергенции градуирует себя
                    вдоль   спина   и  там,  внутре,  обращает
                    материю     вопроса     в    спиритуальные
                    электрические  вихри,  из коих и возникает
                    синекдоха отвечания...

                           А. и Б. Стругацкие. Сказка о Тройке


     Shell  - универсальная утилита и имеет несколько функций,
которые зависят от ключа, с которым запускается утилита.


     7.6.1. Раскрутка системы после загрузки

     Способ запуска:

     shell root=<имя_директории>

используется в файле конфигурации системы при ее раскрутке.

     При раскрутке системы выполняются следующие действия:

     -   текущая   директория   устанавливается  на  указанную
директорию;
     -  на  текущей  директории ищется командный файл с именем
"profile.@" и исполняется;
     - shell заканчивается.


     7.6.2. Ведение диалога с пользователем

     Запуск:

     shell -home <имя_директории_пользователя>

осуществляется    утилитой   входа   в   систему   login   или
администратором непосредственно.

     При этом выполняются следующие действия:

     -   текущая   директория   устанавливается  на  указанную
директорию;
     - исполняется командный файл с именем $TTY_up.@;
     - исполняется   командный  файл  "profile.@"  с   текущей
директории;
     -  в окружение заносятся параметр HOME с именем указанной
директории и параметр USER с именем пользователя;
     - начинается диалог с пользователем.


     7.6.3. Интерпретация командных файлов

     shell "<"имя_командного_файла { аргументы }

     Может   быть   запущена   пользователем   для  исполнения
командного файла.
     По  пути,  указанному  в  ETC,  ищется  файл  с указанным
именем,   интерпретируется  как  командный  файл,  после  чего
утилита завершается.


     7.6.4. Запуск без аргументов

     shell

     Ведет  диалог, который заканчивается либо по команде bye,
либо  по  нажатии  клавиши  Esc.
.PAGE
.HEAD 1 "@USHELL                            ПЕРЕЧЕНЬ ПАРАМЕТРОВ ОКРУЖЕНИЯ@u"
.HEAD 0 "@USHELL                            ПЕРЕЧЕНЬ ПАРАМЕТРОВ ОКРУЖЕНИЯ@u"
.HEAD 2 ''
.HEAD 3 ''

          Глава 7.7. Приложение: перечень параметров окружения

     shell использует следующие параметры окружения:

   SHELL   имя  утилиты,  которая  вызывается  при обнаружении
           командного   файла.   Параметр  копируется  обычным
           образом;  его  отсутствие  приводит к невозможности
           исполнить командный файл.

   STK     размер  стека  для  запускаемых задач в килобайтах.
           Копируется   обычным   образом.  Если  в  окружении
           отсутсвует, то размер считается равным 4.

   ALIAS   строка управления поиском модулей.

   BIN     строка  имен  директорий,  на  которых производится
           поиск кодофайлов.

   ETC     строка  имен  директорий,  на  которых производится
           поиск командных файлов и файлов данных.

   CD      имя   текущей  директории.  shell  поддерживает  ее
           корректность.

   TTY     имя  устройства-экрана. Копируется обычным образом.
           При  модификации  этого параметра происходит захват
           специфицированного устройства.

   KEY     имя   устройства-клавиатуры.   Копируется   обычным
           образом. При модификации этого параметра происходит
           захват специфицированного устройства.

   HOME    имя собственной директории пользователя.

   TASK    номер задачи "shell".

   BASE    номер  задачи,  на  базе которой запускаются другие
           задачи. Если параметр отсутствует, то создается при
           запуске  shell  со  значением  "$TASK".  Отсутствие
           приводит к ошибке при запуске задач.

   FATHER  номер задачи-родителя. Для задач, запущенных shell,
           этот  номер  берется из параметра BASE запускающего
           shell'а.

   SON     номер последней запущеной shell'ом задачи.

   NAME    имя задачи.

   USER    имя пользователя.

   CEMETRY [0/1]  -
           хоронить  ли  трупы  неоткрепленных  задач  при  их
           аварийном   завершении.   При  отсутствии  параметр
           считается равным 1.

   CHAIN   post-mortem  команда.  Если  в  окружении нормально
           завершенной  неоткрепленной  задачи  будет  найдена
           строка с таким именем, то она будет исполнена.

   PROMPT  формат строчки-приглашения на ввод команды.

   INSERT  включение-выключение     режима     вставки     при
           редактировании строки.

   BELL    включение-выключение    звукового    сигнала    при
           редактировании строки.

   BIN     директории, на которых ищутся необходимые кодофайлы.

   ETC     директории, на которых ищутся командные файлы.

   ECHO    включение  эхо-режима:  показ   всех  команд  перед
           исполнением.
.PAGE
.HEAD 1 "@USHELL                                         СИНТАКСИС КОМАНД@u"
.HEAD 0 "@USHELL                                         СИНТАКСИС КОМАНД@u"
.HEAD 2 ''
.HEAD 3 ''


                 Глава 7.8. Приложение: синтаксис команд shell


command ::= shell_command
          | change_environment0
          | task_control
          | mount_unmount
          | run_task .

shell_command ::= set | mem | ps | his |
                  su  | us  | cd | bye |
                  home| delay .
su       ::= "su" .
us       ::= "us" .
set      ::= "set"  [ pattern ] .
mem      ::= "mem" .
bye      ::= "bye" .
his      ::= "his"  [ number ] .
cd       ::= "cd"   [ new_cd_name ] .
home     ::= "home" [ new_home_dir_name ] .
delay    ::= "delay" number .
ps       ::= "ps"   { modifyer } { number } .
modifyer ::= "-mem" | "-tty" | "-usr" | "-l" | "-all" .

change_environment0 ::=
               ["."] [ task_number "." ] var_name "=" string .

task_control ::=  "stop"     task_number { task_number }
               |  "kill"     task_number { task_number }
               |  "wait"     task_number { task_number } .

task_number ::= целое беззнаковое число | $name .

run_task ::=
         [ "{" {change_environment1} {alias} "}" ]
                              task_name { args } [ "&" ] .

change_environment1 ::= ["."] var_name "=" string .
alias     ::= interface|unload|rename .
interface ::= "+" module_name .
unload    ::= "-" module_name .
rename    ::= "=" module_name file_name .

mount_unmount ::= "mount"   directory device ["-ro"]
                | "unmount" directory .

string ::= name | '"' { char } '"' | "'" { char } "'" .
