.TAIL 1 '@w%D%21d%20x%K@W'
.TAIL 0 '@w%D%21d%20x%K@W'
.HEAD 1 '@wКРОНОС В КАРТИНКАХ                                    ВВЕДЕНИЕ@W'
.HEAD 0 '@wКРОНОС В КАРТИНКАХ                                    ВВЕДЕНИЕ@W'
           ИЛЛЮСТРАЦИИ  К  АРХИТЕКТУРЕ  ПРОЦЕССОРОВ


     Данный  раздел  может  быть  использован  как  пособие по
архитектуре   семейства  процессоров  КРОНОС,  системе  команд
(М-код) и работе Модула-2 компилятора.
     Будем вести изложение в следующей форме:

   _______________________________________________________
   |                          |                          |
   |    Текст    программы    |    Генерируемый код      |
   |                          |                          |
   |      на  Модуле - 2      |     с комментариями      |
   |__________________________|__________________________|
   |                          |                          |
   |                          |                          |


     Заметим,  что  приведенный  код является иллюстративным и
поэтому может отличаться от кода, порождаемого текущей версией
компилятора m2.5. Причины следующие:
     1)  в  примерах не отражены оптимизации, которые повышают
эффективность кода, но затрудняют восприятие примера;
     2)  в  некоторых  примерах  приведено несколько вариантов
генерации,   а   в   текущей  версии  компилятора  реализован,
естественно, какой-то один;
     3)  опущены  команды  динамического  контроля  (например,
контроля границ массивов).

     В   примерах   используются   мнемоники   команд  М-кода.
Формальное  описание команд приведено в интерпретаторе М-кода.
.PAGE
.HEAD 1 '@wКРОНОС В КАРТИНКАХ                                   ОПЕРАТОРЫ@W'
.HEAD 0 '@wКРОНОС В КАРТИНКАХ                                   ОПЕРАТОРЫ@W'
                         1. ОПЕРАТОРЫ

     1.1. Присваивание


 MODULE   M;

 VAR  G:INTEGER;
      B:BITSET;

 BEGIN

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 | G:=1;                            LI1 SGW2             |
 | G:=G+255;                        LGW2 LIB FF ADD SGW2 |
 - - - - - - - - - - - - - - - - - - |- - -\-/- -|- -|- --
                                     |      |    |   |
                                     G     255  '+'  G:=


 - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 | B:={0..31};                      LIW FFFFFFFF SGW3    |
 - - - - - - - - - - - - - - - - - - - \-/- - - - -|- - --
 END M.                                 |          |
                                      {0..31}       B:=


     1.2. Доступ к глобальным переменным


 MODULE  M;

 VAR  G2,G3,G4, ... ,G255:INTEGER;
      G256: INTEGER;


 BEGIN
 - - - - - - - - - - - - - - - - - - - - - - -
 | G2  :=  G2;                      LGW02  SGW02 |
 | G255:=G255;                      LGW FF SGW FF| (1.2.1)
 | G256:=G256;                           ---     | (1.2.2)
 - - - - - - - - - - - - - - - - - - - - - - -
 END M.

Примечание 1.2.1. К первым 14 глобалам с номерами 2..15 доступ
           однобайтовый,  к  глобалам  с  номерами  16..255  -
           двухбайтовый.

Примечание   1.2.2.   Это  не  компилируется  текущей  версией
           компилятора, но может порождаться так:

      LGA FF LSW1      LGA FF SSW1


     1.3. Доступ к внешним переменным

     Внешними  переменными  называются  глобальные  переменные
других модулей.

 DEFINITION MODULE M;
   VAR i: INTEGER;
 END M.
                       номер модуля М в локальной DFT модуля N
 MODULE N;                           | Номер
 FROM M IMPORT i;                    | переменной i в модуле М
 BEGIN                               |  |
 - - - - - - - - - - - - - - - - - - |- |- - - - - - --
 | i:=i;                         LEW 01 02  SEW 01 02 |
 - - - - - - - - - - - - - - - - - - - - - - - - - - --
 END N.

     Подробнее  о  локальной  DFT  можно  узнать  из примеров,
относящихся к процедурам (см. раздел 2).


     1.4. Условный оператор (IF)

 MODULE M;

 VAR bool :BOOLEAN;                  +--->      LGW2
     G3,G4:INTEGER;                  | (1.4.1) JSFC 04  --+
 BEGIN                               |                    |
  - - - - - - - - - - - - - - - - - -          LI3 SGW3   |
 |IF bool THEN G3:=3 ELSE G4:=4 END;                      |
  - - - - - - - - - - - - - - - - - -  (1.4.2) JSF 02   --|--+
 END M.                              |      ______________|  |
                                     |      |-->LI4 SGW4     |
                                     |      _________________|
                                     +--->  +-->

Примечание  1.4.1. Если на А-стеке 0, то PC увеличивается на 4
           байта,      пропуская      TRUE-альтернативу.     0
           интерпретируется как FALSE, #0 - TRUE.


Примечание    1.4.2.    Безусловный    переход    (если   есть
           FALSE-альтернатива).


     1.5. Оператор цикла (LOOP)

     Генерация LOOP-цикла переходом (как реализовано в текущей
версии):


MODULE M;


BEGIN                           -->      - - - - - - - - -
  - - - - - - - - - - - - - - --/         |--> JSF 02  --|--|
  | LOOP   EXIT END;                                     |  |
  - - - - - - - - - - - - - - --\              JSB 04  --|--|
END  M.                         -->      - - - - - - - - -
                                          |-->

     Если   тело   цикла   большое,   то  переход  может  быть
двухбайтовым.

 MODULE M;
 VAR G2:INTEGER;
 BEGIN
 - - - - - - - - - - -> |-->|---------------|
 | LOOP                 |   | код для CASE  |
 |   CASE G2 OF         |   | размером более|
 |   0..127: G2:=0      |   | 255 байтов    |   |- -> (1.5.1)
 |   END;               |   |_______________|   |
 | END;                 |---- JLB hiofs loofs   |
 - - - - - - - - - - ->          |_____|_____|--|
 END M.

Примечание 1.5.1.  Двухбайтовое смещение для переходов длиннее
           255 байт.

     Генерация LOOP-цикла с помощью команд ENTS и XIT:

 MODULE M;

 VAR G2:INTEGER;
                                     G2:=0
 BEGIN                                 |
 - - - - - - - - - - - - - - - - - - -/-\- - - -
 | G2:=0;                           LI0 SGW2    |
 | LOOP                            ENTS 000C    |  (1.5.2)
 - - - - - - - - - - - - - - - - - - - - - - - -
                            __________________________________
                            |     G2    1    +   G2:=        |
 - - - - - - - - - - - ->   |     |     |    |    |          |
 |   G2:=G2+1;              |--> LGW2  LI1  ADD  SGW2        |
 |                                                           |
 |   IF G2>5 THEN EXIT END;    LGW2 LI5 GTR JSFC 01 XIT JSB 0C
 - - - - - - - - - - - ->        |    |   |
   END;                          G2   5   >
 END M.

Примечание 1.5.2.  ENTS  кладет  на  вершину  П-стека  текущее
           значение  PC  + значение следующих за командой двух
           байтов. XIT берет с верхушки П-стека новое значение
           PC, совершая переход.

     1.6. Оператор цикла (REPEAT)

 MODULE M;
   VAR G2:INTEGER; bool: BOOLEAN;
 BEGIN
  - - - - - - - - - - - - - - - - ->     _____________________
  | REPEAT G2:=1 UNTIL bool;             |--> LI1  SGW2      |
  - - - - - - - - - - - - - - - - ->          LGW3 JSBC 05 --|
 END M.



     1.7. Оператор цикла (FOR)

 MODULE M;

  VAR i,G3:INTEGER;

 BEGIN



                                        i:=0
                                        / | \

                                   -->LGA 02  LI0
                                  /   LIB 127        -- 127
                                 /            - - - -
  -- - - - - - - - - - - - - - -      FOR1 00 |00 06|--(1.7.1)
  |FOR i:=0 TO 127 BY 2 DO G3:=i              |ofset|
  -- - - - - - - - - - - - - - -              - - - -
   END;                          \    LGW2 SGW3       -- G3:=i
 END M.                           \           - - - -
                                   -->FOR2 02 |00 06|--(1.7.2)
                                           |  |ofset|
                                           |  - - - -
                                      шаг цикла


Примечание  1.7.1.  FOR1  берет  со  стека  конечное значение,
           начальное  значение,  адрес  параметра цикла. Шаг -
           константа,  знак шага - следующий байт кода. Если в
           следующем  байте  0, шаг положительный, если не 0 -
           шаг    отрицательный.   Если   условия   цикла   не
           выполняются   сразу   (конечное   значение   меньше
           начального  при  положительном  шаге или наоборот),
           тело  цикла  обходится с помощью указанного размера
           тела     (ofset);    иначе    начальное    значение
           присваивается  по  указанному адресу, и выполняется
           тело  цикла. Параметры (адрес,  конечное  значение)
           остаются на П-стеке для команды FOR2.

Примечание 1.7.2. FOR2 по параметрам, взятым с П-стека, и шагу
           цикла  определяет  возможность  еще одной итерации,
           если она возможна, увеличивает значения, лежащие по
           указанному  адресу  на  'шаг' и осуществляет прыжок
           назад на указанное число байтов (offset).


     1.8. Оператор выбора (CASE)


 MODULE M;

   VAR G2,G3:  INTEGER;

 BEGIN


 - - - - - - - - - ->                  LGW2
 | CASE G2 OF                          ENTC 0009 - - |
 |  |1..2: G3:=2            |- - - - ->LI2 SGW3  XIT |
 |  |5   : G3:=3        |---|--------->LI3 SGW3  XIT | (1.8.1)
 | ELSE    G3:=4        |   |   |----->LI4 SGW3  XIT |
 | END;                 |   |   |   _ _ _ _ _ _ _ _ _|
 - - - - - - - - - ->   |   |   |   |
                        |   |   |   |->0001 0005       (1.8.2)
 END M.                 |   |   |
                        |   |   |   смещение  альтернатива
                        |   |   |       |        |
                        |   |   |------0009 -- ELSE
                        |   |- -|- - - 0011 -- 1
                        |   |- -|- - - 0013 -- 2
                        |       |------000F -- ELSE
                        |       |------0011 -- ELSE
                        -------------- 0016 -- 5


Примечание 1.8.1.  ENTC выбирает двухбайтовое смещение из кода
           и переходит в таблицу выбора.


Примечание 1.8.2.  Из  кода  выбираются  минимальное  (lo=1) и
           максимальное  (hi=5)  значения  альтернатив.  Затем
           вычисляется  PC  точки  выхода PC'=PC+2*(hi-lo)+4 и
           записывается  на П-стек. Затем с А-стека выбирается
           значение  параметра  i и подготавливается переход к
           нужной  альтернативе:  PC:=PC+2*(i-lo+1).  В случае
           i>hi  или  i<lo  PC остается неизменным. Теперь все
           готово  к переходу: из кода выбирается двухбайтовое
           смещение     delta,     обеспечивающее     переход:
           PC:=-delta+PC.  После  выполнения группы операторов
           выбранной  альтернативы  выполняется  команда  XIT,
           которая осуществляет выход из CASE путем выполнения
           PC:=PC'. PC' берется командой XIT с П-стека.
.PAGE
.HEAD 1 '@wКРОНОС В КАРТИНКАХ                                   ПРОЦЕДУРЫ@W'
.HEAD 0 '@wКРОНОС В КАРТИНКАХ                                   ПРОЦЕДУРЫ@W'



                          2. ПРОЦЕДУРЫ


     2.1. Описание и вызов примитивной процедуры


 MODULE M;

 PROCEDURE P; (* процедура 1 *)

       - - - - - - - - - - - - - - - - - -
 BEGIN | RETURN END P;              RTN  |
       - - - - - - - - - - - - - - - - - -

 BEGIN        (* процедура 0 *)
  - - - - - - - - - - - - - - - - - - - -
  | P;                              CL1 | (2.1.1)
  - - - - - - - - - - - - - - - - - -|- -
 END M.                              |
                        вызов локальной процедуры 1


Примечание 2.1.1. CL1 маркирует П-стек следующим образом:

                П-стек--> |          |
                          |__________|
      L в точке входа --> |          | <-- S в точке вызова
                          |    L     |
      статическая     --> |__________| \
          и           --> |    L     |__\ значения регистров
      динамическая        |__________|  / в точке вызова
        цепочки           |    PC    | /
                          |__________|
                          |не трогает|<-- см. команды SETM,RTN
                          |__________|
      S  в точке входа--> |          |
                          |          |

           После  маркировки  в L засылается значение S, а в S
           значение  S+4. По номеру процедуры (в данном случае
           -  1) из процедурной таблицы (см. Примечание 2.1.2)
           извлекается смещение до начала кода соответствующей
           процедуры  и  засылается  в РС, после чего начинают
           исполняться  команды  тела  процедуры. RTN берет из
           области  процедурных связей П-стека значение РС и L
           в  точке их вызова и засылает их в регистры РС и L.
           В  регистр S засылается значение L в точке возврата
           (которое   является  старым  значением  S  в  точке
           вызова).

Примечание  2.1.2.  Процедурная  таблица  - таблица, по номеру
           процедуры    указывающая   смещение   начала   кода
           процедуры  относительно начала кода модуля. Нулевая
           процедура - инициализирующая часть модуля.


     2.2. Работа с локалами процедуры

 MODULE M;
 PROCEDURE P; (* процедура 1 *)
                         число локальных переменных процедуры
                                         |
       - - - - - - - - - - - - - - - - - |- - - --
 VAR   |L4: INTEGER;                ENTR 01      | (2.2.1)
 BEGIN |L4:=0; RETURN               LI0 SLW4 RTN |
       - - - - - - - - - - - - - - - - - - |- - --
 END P;                                    |
                                  первые четыре слова (0..3)
                                  заняты под область связей

 BEGIN        (* процедура 0 *)
 - - - - - - - - - - - - - - - - - - - - - -
 |P;                                CL1    |
 - - - - - - - - - - - - - - - - - - - - - -
 END M.

Примечание 2.2.1. ENTR 01 передвигает регистр S на одно слово:

        |___________| <-- L                 |__________| <-- L
       0|           |          ENTR 01     0|          |
       1| с в я з и |        ---------->   1| с в я з и|
       2|           | <-- S                2|          |
       3|___________|                      3|__________|
        |           |                      4|__________| <-- S
                                            |          |

           После   этого   становится   возможным  работать  с
           локальной    переменной    командами    LLW,    SLW
           (аналогичными командам  LGW, SGW), базирующимися по
           L-регистру.



     2.3. Вложенные процедуры


 MODULE M;


 PROCEDURE p1;  (* процедура 1*)
   VAR p1L4:INTEGER;


   PROCEDURE p2; (* процедура  2*)
.PAGE
                                кладет      на     А-стек
                                L-регистр    охватывающей
   VAR p2L4:INTEGER;            процедуры p1
   BEGIN                             |
      - - - - - - - - - - - - - - - -|- - - - - - - ---
      |p1L4:=12;                    GB1  LI12  SSW4   |
      |p2L4:=11;                    LI11 SLW4  RTN    |
      - - - - - - - - - - - - - - - - - - - - - - - - -
   END p1;               номер процедуры в процедурной таблице
 BEGIN                                         |
   - - - - - - - - - - -- - - - - - - - - - - -|- - -
   |p1L4:=2;                       LI2  SLW4   |     |
   |p2;                            LLA 00  CI 02 RTN | (2.3.1)
   - - - - - - - - - - -- - - - - - - -|- -|- - - - -
 END p1;                               |   |
                       Значение L-регистра |
                                           |
                команда вызова процедуры промежуточного уровня

 BEGIN
 - - - - - - - - - - - - - - - - - - - - -
 |p1;                               CL1  |
 - - - - - - - - - - - - - - - - - - - - -
 END M.


Примечание   2.3.1.  CI  берет  с  А-стека  значения  базового
           регистра  (в  данном случае L) и вызывает процедуру
           (данного  модуля),  запоминая в статической цепочке
           это    значение    (вместо    L-регистра,   который
           запоминается    в   команде   CL).   GB1   проходит
           статическую цепочку процедур на 1 уровень, получает
           базовый   адрес  статики  процедуры  уровня  0,  из
           которой  вызвана  процедура  p1,  и  кладет  его на
           A-стек.  По  нему обеспечивается доступ к локальным
           переменным   соответствующей  процедуры  с  помощью
           команд LSW, SSW. В данном примере компилятор вместо
           CI   породит   CL,   так  как  статическая  цепочка
           совпадает с динамической.


     2.4. Вызов внешней процедуры


 DEFINITION MODULE N;

 PROCEDURE proc1;

 END N.


 MODULE M;

 FROM N IMPORT proc1;


                                    номер модуля
                                      |
 PROCEDURE p1;                        | номер процедуры модуля
 BEGIN                                |  |
 - - - - - - - - - - - - - - - - - - -| -|- - -
 |  proc1;                        CX 01 01 RTN |  (2.4.1)
 - - - - - - - - - - - - - - - - - - - - - - - -
 END p1;

 END M.


Примечание   2.4.1.  В  локальной  DFT  элемент  с  номером  1
           соответствует  модулю  N  и после загрузки в память
           ссылается  на элемент DFT, указывающий на G-область
           модуля   N,   в  первом  слове  которой  содержится
           F-регистр  модуля  N,  позволяющий добраться до его
           сегмента кода:


                              D F T
                           +-------+
                     +---->| N *- -|--+   -- элемент DFT для N
                     |     |-------|  |
                     |     |       |  |
                     |     |_______|  |
                     | +-->| M *- -|  |   -- элемент DFT для M
                     | |   |_______|  |
                     | |              |
     Образ модуля M  | |              |   Образ модуля N
                     | |              |
      +---------+    | |              |    +---------+
      | 1 *- - -|- - + |              |    |         |
      |_________|      |              |    |         |
      | 0 *- - -|- - - +              | G  |         |
 G -> |_________|                     +--> |_________|
      | F *- - -|--> на сегмент кода       | F *- - -|-->
      |_________|                          |_________|
      |   *- - -|--> на строковый пул      |   *- - -|-->
      |_________|                          |_________|
      |         |                          |         |
      |G-область|                          |G-область|
      |модуля М |                          |модуля N |
      |_________|                          |_________|

           CX  кладет  в  область  связей  cтатической цепочки
           G-регистр  и  помечает, выставляя признак во втором
           локальном  слове,  что  вызов  был внешним. Команда
           RTN  анализирует  этот бит и в случае необходимости
           востанавливает значение G-регистра.



     2.5. Размещение мультизначений

 MODULE M;

 PROCEDURE p;
     - - - - - - - - - - - - - - - - - - - - - - - - -
 VAR |i: INTEGER;                   ENTR 02           |
     |A: ARRAY [0..15] OF INTEGER;  LIB 10 ALLOC SLW5 |(2.5.1)
     - - - - - - - - - - - - - - - - - - - - - - - - -
 BEGIN
   - - - - - - - - - - - - - - - - - - - - - - - - - -
   |i:=0;                       LI0  SLW4   |        |
   |                                                 |
   |                             A    i              |
   |                             |    |              |
   |A[i]:=1;                    LLW5 LLW4 LI1 SXW    | (2.5.2)
   - - - - - - - - - - - - - - - - - - - - - - - - - - (2.5.3)
END p;

END M.


Примечание  2.5.1. ALLOC берет с А-стека размер мультизначения
           (массив  или  запись),  кладет  на  А-стек значение
           регистра  S  и  передвигает S на взятый размер, тем
           самым  отводя  нужное  число  слов  на  П-стеке для
           мультизначения.    После    этого   адрес   массива
           запоминается в нужном локальном слове.

Примечание 2.5.2. Индексация без контроля границ. По умолчанию
           контроль границ включен.

Примечание  2.5.3.  При  возврате  из  процедуры  команда  RTN
           пeреставяет  S  в  L,  и  тем самым освобождает всю
           память,  занятую  локалами,  в  том числе и память,
           выделенную на П-стеке командой ALLOC.


     2.6. Оформление возврата из инициализирующей части модуля

     В  настоящей реализации системы программирования MODULA-2
принято,  что  нулевая  процедура  (тело  модуля) при возврате
кладет  на  А-стек  размер памяти, отведенной на П-стеке после
инициализации  модуля, т.е. <размер мультизначений в словах> +
4   слова  процедурных  связей  процедуры  0.  Эта  информация
используется в инициаторе задач:

 MODULE M;
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 |VAR A: ARRAY [0..0Fh] OF INTEGER;    LIB 010 ALLOC SGW2    |
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

 BEGIN (* процедура 0 *)
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 |END M.                                LIB 14 RTN           |
 - - - - - - - - - - - - - - - - - - - - - -|- - - - - - - - -
                                            14h = 10h + 4h


Если в модуле нет мультизначений, то он должен вернуть 0:

 МODULE M;
 - - - - - - - - - - - - - - - - - - - - - - - - -
 |BEGIN END M.                           LI0 RTN |
 - - - - - - - - - - - - - - - - - - - - - - - - -


     2.7. Работа с процедурными значениями


 MODULE M;

 TYPE proc1=PROCEDURE (INTEGER);

 PROCEDURE P(p1 : proc1); (* процедура # 1 *)


                       сохранить А-стек на П-стеке
                          | загрузить процедурное значениe P1
                          | из локального слова 4 процедуры Р
 BEGIN                    |     |  записать на П-стек значение
                          |     |     |             с  А-стека
   - - - - - - - - - - - -|- - -|- - -|- - - - - - - - - -
   |p1(1);              SLW4   LLW4  STOT  LI1  CF  RTN  |
   - - - - - - - - - - - - - - - - - - - - -|- -|- - - - -
 END P;                                     |   |
                                       параметр |
                                              вызов формальной
                                                     процедуры

 PROCEDURE p(w: INTEGER); (* процедура # 2 *)
 BEGIN
   - - - - - - - - - - - - - - - - - - - - - - - -
   |                                SLW4     RTN |
   - - - - - - - - - - - - - - - - - - - - - - - -
 END p;


 VAR v: proc1;         номер модуля =0, т.к. проц. собственная
                                         | номер процедуры
 BEGIN                                   |  |
   - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   |v:=p;                            LPC 00 02  SGW2      |
   |v(5);                            LGW2  STOT  LI5  CF  |
   |P(v);                            LGW2  CL1            |
   |P(p);                            LPC 00 02  CL1       |
   - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 END M.



                           |<--  о д н о   с л о в о -->|
                           |____________________________|
 Процедурное значение:     | 31..24 | 23 . . . . . . .0 |
                           -----|-------------|----------
                                |             |
                              номер        адрес входа
                            процедуры      в DFT модуля


     Процедурные   связи  при  вызове  процедуры  командой  CF
(аналогично CX):

                      L'-->   |          |
                              .          .
                              |----------|
                      S', L-->| G-регистр|
                              |__________|
                              |    L'    |
                              .----------.
                      S -->   .          .
                              |          |



     2.8. Передача параметров


 MODULE M;

 TYPE String=ARRAY [0..255] OF CHAR;

 PROCEDURE P(i: INTEGER; S: String; VAR w: ARRAY OF CHAR);
   VAR k,j:INTEGER;
 BEGIN

 (* сохранение параметров и размещение переменных *)
 - - - - - - - - - - - - - - - - - - - - - - - - - -
 |                                STORE ENTR 01    |  (2.8.1)
 - - - - - - - - - - - - - - - - - - - - - - - - - -

 (* копирование массива S, переданного по значению *)

 - - - - - - - - - - - - - - - - - - - - - - - - - -
 |k:=HIGH(S);                       LIB FF  SLW8   |
 |j:=HIGH(w);                       LLW4 SLW9 RTN  |  (2.8.2)
 |                                   |    |        |
 |                                  HIGH  j        |
 - - - - - - - - - - - - - - - - - - - - - - - - - -
 END P;

 VAR
     - - - - - - - - - - - - - -- - - - - - - -  - -
     |str8:ARRAY[0..7] OF CHAR;  LI2 ALLOC SGW2    |
     |str :String;               LIB 40 ALLOC SGW3 |
     - - - - - - - - - - - - - -- - - - - - - - -  -

BEGIN
                     загрузка на А-стек адреса константы 'abc'
                               |
 - - - - - - - - -  - - - - - -|- - - - - - - - - - -
 |p(1,'abc',str8);        LI1 LSTA 0001 LGW2 LI7 CL1 |
 |                                                   |
 |str:='def';             LGW3 LSTA *ind* LI1 MOVE   | (2.8.3)
 |                                                   |
 |p(2,str,str);           LI2 LGW3 LGW3 LIB FF CL1   |
 - - - - - - - - -  - - - - - - - - - - - - - - - - -

 END M.


Примечание  2.8.1.  STORE записывает А-стек на П-стек, выделяя
           на  П-стеке память под локалы: 4-е слово - HIGH(w),
           5-e  слово  -  w(адрес), 6-е слово - S (адрес), 7-е
           слово   -   i,  8-e  слово  -  число  параметров  -
           используется   для   локала   k.  Команда  ENTR  01
           завершает отведение памяти; 9-е слово отводится для
           j :



 А-стек             |__________|       L -----> |__________|
 перед вызовом      |  HIGH(w) |                |__________|
 процедуры p :      |----------|                |__________|
                    |    w     |                |__________|
                    |----------|                |__________|
                    |    S     |          --> 4 | HIGH(w)  |
                    |----------|          |     |----------|
                    |    i     |          |   5 |    w     |
                    |----------|          |     |----------|
                                          |   6 |    S     |
                                  STORE   |     |----------|
                                          |   7 |    i     |
                                          |     |----------|
                                          |   8 |          | k
                                          -->   |----------|
                                  ENTR 1 ---> 9 |          | j
                                                |__________|
                                       S -----> |          |


Примечание  2.8.2.  Здесь  приведена  группа  команд,  которая
           копирует  переданный по значению массив S. Приводим
           три варианта (2.8.2):


           I)  LIB 40        II)  LLW6           III)  LLW6
               ALLOC              LIB FF               LIB 3F
               COPT               CPCOP 06             PCOP 06
               LLW6
               LIB 40
               MOVE
               SLW6

           Очевидна целесообразность введения в систему команд
           CPCOP  и  PCOP,  предназначенных  для  размещения и
           копирования мультипараметров.

Примечание  2.8.3. LSTA *ind* по относительному смещению *ind*
           в   строковом   пуле   грузит   на   А-стек   адрес
           соответствующей  строковой  константы. Обозначенную
           последовательность команд можно заменить :
           LGW3 RDS 01 XYZ0
           ( X,Y,Z - коды литер 'x', 'y', 'z' ).

     2.9. Вызов функции (на непустом стеке)

 MODULE M;

 PROCEDURE f(i,j: INTEGER): INTEGER;
 BEGIN
 - - - - - - - - - - - - - - - - - - - - - - - - - - -
 | RETURN  i+j               STORE LLW5 LLW4 ADD RTN |
 - - - - - - - - - - - - - - - - - - - - - - - - - - -
 END f;

 PROCEDURE p(i,j: INTEGER);
   VAR k:INTEGER;
 BEGIN
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 | k:=i+j;                      STORE LLW5 LLW4 ADD SLW6 RTN |
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 END p;
 VAR v: PROCEDURE(INTEGER,INTEGER): INTEGER;
 BEGIN
 - - - - - - - - - - - -- - - - - - - - - - - - - - - -
 | p(1,f(2,3));   LI1     STORE LI2 LI3 CL1 LODFV CL2 |
 | v:=f;          LPC 00 01 SGW2                      |
 | p(1,v(2,3));   LI1 LGW2 STOFV LI2 LI3 CF LODFV CL2 |(2.9.1)
 |                                                    |
 - - - - - - - - - - - - - - - - - - - - -  - - - - - -
 END M.

Примечание  2.9.1.  Последовательность  команд LI1 LI2 CL1 CL2
           была  бы  неверна,  поскольку  CL1  в  точке  входа
           забирает со стека все значения (STORE), в том числе
           и 1, предназначающуюся не для нее (!).
.PAGE
.HEAD 1 '@wКРОНОС В КАРТИНКАХ                                   ВЫРАЖЕНИЯ@W'
.HEAD 0 '@wКРОНОС В КАРТИНКАХ                                   ВЫРАЖЕНИЯ@W'

                          3. ВЫРАЖЕНИЯ


     3.1. Индексация словных массивов


MODULE M;

VAR x: ARRAY [0..3] OF INTEGER;
    i: INTEGER;

BEGIN
- - - - - - - - - - - - - - - - - - - - - -
|  x[i]:=1;    LGW2 LGW3 LI3 CHKZ LI1 SXW |-- с контролем
|  i:=x[1];    LGW2 LI1  LXW SGW2         |   границ
- - - - - - - - - - - - - - - - - - - - - -

- - - - - - - - - - - - - - - - - - -
|  x[i]:=1;      LGW2 LGW3 LI1 SXW  | -- без контроля границ
|  i:=x[1];      LGW2 LI1  LXW SGW2 |    (3.1.1)
- - - - - - - - - - - - - - - - - - -
END M.


Примечание  3.1.1.  Компилятор  использует  здесь  константную
           индексацию, породив код

           - - - - - - - - - - - - - - - - - - - - -
           |    i:=x[1]        LGW2 LSW1     SGW2  |
           - - - - - - - - - - - - - - - - - - - - -

           и  таким  образом,  контроль  границ  становится не
           нужен.


     3.2. Индексация байтовых массивов


 MODULE M;
     - - - - - - - - - - - - - - - - - - - - - - -
 VAR | A:ARRAY [0..0Fh] OF CHAR;  LI4 ALLOC SGW2-|--(3.2.1)
     - - - - - - - - - - - - - - - - - - - - - - -
       i:INTEGER;                                   (3.2.2)


 BEGIN
 - - - - - - - - - - - - - - - - - - - - - - -
 |i:=0;                             LI0 SGW3 |
 - - - - - - - - - - - - - - - - - - - - - - -





                               HIGH    i   '>='
 - - - - - - - - - - - - ->      |     |     |
 | WHILE HIGH(A)>=i DO       |->LI0F  LGW3  GEQ JSFC 014------
 | A[i]:='*';                |  LGW2 LGW3 LIB 2A SXB         |
 | INC(i);                   |  LGA 03 INC1                  |
 | A[i-1]:= A[i-1]; END;     |  LGW2 LGW3 LI1 SUB            |
 - - - - - - - - - - - - ->  |  LGW2 LGW3 LI1 SUB            |
 END M.                      |    |    |   |   |             |
                             |    A[   i   1  '-'            |
                             |   LXB  SXB JSB 019            |
                              \_______________/              |
                                                             |
                                         <--------------------
                                                     (3.2.3)

Примечание 3.2.1.  В  глобальном   слове  2 адрес размещенного
           массива.

Примечание 3.2.2. Литерные массивы пакуются.

Примечание 3.2.3.  LXB и SXB работают аналогично LXW и SXW, но
           читают  и  пишут соответствующий байт, а  не слово.
           0 <байтовый адрес> LXB  и  0 < байтовый адрес > SXB
           осуществляют абсолютную байтовую адресацию памяти.


     3.3. Индексация байтовых массивов с контролем границ


 MODULE M;

 VAR A:ARRAY [0..0Fh] OF CHAR;
     i:INTEGER;



 BEGIN i:=0;
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  |WHILE  i#HIGH(A) DO -> LIW3 LI0F NEQ JSFC 0E             |
  |  A[i]:=A[i+1];     -> LGW2 LGW3 LI0F CHKZ               |
  |                       LGW2 LGW3 LI1 ADD LI0F            |
  |                        |     |   |   |    |             |
  |                        A     i   1  '+'  HIGH(A)        |
  |                                                         |
  |END (*WHILE *)         CHKZ LXB SXB JSB 013              |
  |                        |                                |
  |                       (3.3.1)                           |
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


Примечание  3.3.1.  CHKZ  проверяет,  лежит  ли второй элемент
           А-стека  между  0  и  верхним  элементом  (задающим
           границу);  если  это  так,  то  счеркивает границу,
           иначе возбуждает TRAP(4Ah).




     3.4. Проверка принадлежности диапазону

 MODULE M;

 VAR x:[10h..20h];
 BEGIN
    - - - - - -  - - - - - - - - - - - - - - - - - - - - - - -
   |x:=13h;                    LIB 13 LIB 10 LIB 20 CHK SGW2 |
   - - - - - - - - - - - - - - - - - - - - - - - - - | - - - -
 END M.                                              |
                                                  (3.4.1)

Примечание  3.4.1. CHK проверяет принадлежность диапазону. Эту
           проверку  производит  компилятор  при  компиляции и
           порождает код LIB13 SGW2.


     3.5. Работа с объектами типа BITSET.

 MODULE M;
 VAR b1, b2:BITSET;
 BEGIN
   - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   |b1:={}; b2:={1};                LI0  SGW2  LI2  SGW3 |
   |b1:=b1+b2;                      LGW2  LGW3  OR  SGW3 |
   (*     *                                     AND
          /                                     XOR
          -                                     BIC      *)

   |b1:={1}; INCL(b1,2);            LGA 2  LI2  INCL     |
   |         EXCL(b1.2);            LGA 2  LI2  EXCL     |
  (* 2 IN b1                        LI2  LGW2   IN       *)
   - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 END M.

     3.6. Команды ANDJP и ORJP

 MODULE M;
 .
 .
 BEGIN
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  |IF FALSE AND TRUE THEN END;   LI0  ANDJP 1  LI1  JSFC  |
  |IF TRUE OR FALSE  THEN END;   LI1  ORJP 1   LI0  JSFC  |
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 END M.                                                (3.6.1)

Примечание 3.6.1.  Компилятор  вместо  этого   смешного  кода,
           оптимизируя, не породит ничего.
