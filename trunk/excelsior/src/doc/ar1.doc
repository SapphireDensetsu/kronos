.TAIL 1 ''
.TAIL 0 ''
.HEAD 1 ''
.HEAD 0 ''



                - Сибирское отделение  АН СССР -




                    - Вычислительный центр -













:::::      ::::
:::::      ::::
 :::      :::
 :::     ::
 :::    ::
 ::: : :        ::::::       :::    :::   :::    :::       :::
 :::    ::      ::    ::   ::: :::  :::   :::  ::: :::   ::: :::
 :::     :::    ::     :: ::     ::  ::   ::  ::     :: ::
 :::      :::   ::     :: ::     ::  :::::::  ::     :: ::
:::::      :::: :::  :::   ::: :::  :::   :::  ::: :::   ::: :::
:::::      :::: ::::::       :::    :::   :::    :::       :::
                ::
                ::
                ::  АРХИТЕКТУРА ПРОЦЕССОРОВ СЕМЕЙСТВА КРОНОС











                         Новосибирск - 89
.PAGE
.TAIL  1  '@w%D%21d%20x%K@W'
.TAIL  0  '@w%D%21d%20x%K@W'





















                         Мы    надеемся,    что    информация,
                    изложенная  в  этом томе, является верной.
                    Будем    признательны,    если    читатель
                    критически  подойдет к ней и все возникшие
                    вопросы,    замечания,    исправления    и
                    пожелания   доведет  до  нашего  сведения.
                    Выражаем благодарность всем, кто прямо или
                    косвенно  принимал  участие в подготовке и
                    издании тома.



                    Наш адрес:

                         630090,   Новосибирск-90,    проспект
                    ак. Лаврентьева, 6,  ВЦ СОАН СССР,  к.503,
                    тел. 35-50-67.
                         Для сотрудников ВЦ СOАН тел. 8-97.




Последнее изменение 03.01.89
.PAGE
                          СОДЕРЖАНИЕ


Введение . . . . . . . . . . . . . . . . . . . . . . . . . . 4
Виртуальная Модула-2 машина . . . . . . . . . . . . . . . .  6
Интерпретатор M-кода . . . . . . . . . . . . . . . . . . . .13
Описание системы команд  . . . . . . . . . . . . . . . . . .26
Иллюстрации к архитектуре процессоров . . . . . . . . . . . 69
1. Операторы  . . . . . . . . . . . . . . . . . . . . . . . 70
   1.1. Присваивание  . . . . . . . . . . . . . . . . . . . 70
   1.2. Доступ к глобальным переменным  . . . . . . . . . . 70
   1.3. Доступ к внешним переменным . . . . . . . . . . . . 71
   1.4. Условный оператор (IF) . . . . . . . . . . . . . . .71
   1.5. Оператор цикла (LOOP) . . . . . . . . . . . . . . . 71
   1.6. Оператор цикла (REPEAT) . . . . . . . . . . . . . . 72
   1.7. Оператор цикла (FOR) . . . . . . . . . . . . . . . .73
   1.8. Оператор выбора (CASE) . . . . . . . . . . . . . . .74
2. Процедуры  . . . . . . . . . . . . . . . . . . . . . . . 75
   2.1. Описание и вызов примитивной процедуры  . . . . . . 75
   2.2. Работа с локалами процедуры . . . . . . . . . . . . 76
   2.3. Вложенные процедуры . . . . . . . . . . . . . . . . 76
   2.4. Вызов внешней процедуры . . . . . . . . . . . . . . 77
   2.5. Размещение мультизначений . . . . . . . . . . . . . 79
   2.6. Оформление возврата из инициализирующей
        части модуля . . . . . . . . . . . . . . . . . . .  79
   2.7. Работа с процедурными значениями . . . . . . . . .  80
   2.8. Передача параметров . . . . . . . . . . . . . . . . 81
   2.9. Вызов функции (на непустом стеке)  . . . . . . . .  83
3. Выражения . . . . . . . . . . . . . . . . . . . . . . .  84
   3.1. Индексация словных массивов . . . . . . . . . . . . 84
   3.2. Индексация байтовых массивов  . . . . . . . . . . . 84
   3.3. Индексация байтовых массивов с контролем границ  .  85
   3.4. Проверка принадлежности диапазону . . . . . . . . . 86
   3.5. Работа с объектами типа BITSET. . . . . . . . . . . 86
   3.6. Команды ANDJP и ORJP . . . . . . . . . . . . . . .  86
.PAGE
.HEAD 1 '@wАРХИТЕКТУРА                                           ВВЕДЕНИЕ@W'
.HEAD 0 '@wАРХИТЕКТУРА                                           ВВЕДЕНИЕ@W'
                           ВВЕДЕНИЕ

                         -  А  какая  система  счета  у вас? -
                    задал вопрос Новобрачный.
                         -  На  Аллиоларе,  как  и  на  прочих
                    высокоцивилизованных   планетах,   принята
                    единая  тридцатидвоичная  счетная система.
                    Основой ее послужили зубы. Суть в том, что
                    у всех разумных существ всегда по тридцать
                    два  зуба.  Все мы - братья по разуму и по
                    зубам!

                                                     В. Шефнер
                                         Записки зубовладельца


     Архитектура процессоров семейства КРОНОС ориентирована на
поддержку  языков  высокого  уровня  (Си,  Модула-2,  Паскаль,
Оккам),   что   оказывает   возможность   реализации  новейших
концепций  в  области использования ЭВМ. Наличие 32-разрядного
машинного  слова  позволяет  использовать процессоры семейства
для    решения    вычислительных   задач.   Широкое   адресное
пространство  (до 2 миллиардов слов) дает возможность создания
виртуальной   памяти   для   объектно-ориентированных  моделей
вычислений   и   тем   самым  обеспечивает  разработку  систем
искусственного интеллекта.  Аппаратная поддержка прерываний по
событиям,  по  синхронизации  процессов,  а также компактность
кода   программ   позволяет  с  уверенностью  утверждать,  что
процессоры   семейства  КРОНОС  могут  успешно  применяться  в
системах реального времени.
     Любой   процессор  семейства  может  быть  использован  в
составе отдельной ЭВМ и в мультипроцессорных комплексах.


                      Процессоры КРОНОС


     1.   КРОНОС-2   является  первой  реализацией  изложенных
архитектурных   концепций.  Он  выполнен  в  конструктиве  ЭВМ
"Электроника-60"  и полностью совместим с серийно выпускаемыми
для  нее внешними устройствами и памятью. Процессор реализован
на  микросхемах  серий  1802,  1804,  155,  531.  В отличие от
"Электроники-60",    процессор     имеет     вдвое     большую
производительность,    оперирует   32-разрядными   словами   и
позволяет наращивать объем оперативной памяти до 4 Мбайт.
     2.  КРОНОС-2.5  является  развитием процессора КРОНОС-2 и
отличается от него более высокой производительностью:
     3 млн/с простых операций над стеком;
     2  млн/с  команд  обмена  с памятью. Интерфейс с внешними
устройствами реализуется через шину MULTIBUS.
     3.  В  процессоре КРОНОС-2.6 предусмотрен выход на прямые
каналы  связи  большой  пропускной способности для объединения
нескольких  процессоров, что позволяет использовать процессоры
КРОНОС-2.6,   оснащенные   арифметическими   расширителями,  в
качестве ядра макета многопроцессорной системы МАРС-Т. Высокая
производительность  обеспечивается транспьютерной организацией
и   естественным   включением   в  систему  спецпроцессоров  и
функциональных   модулей.  Процессоры  КРОНОС-2.6  могут  быть
использованы также в рабочих станциях системы МАРС.
     Разрабатывается    однокристальный   вариант   процессора
КРОНОС.  Перспективность этой работы обусловлена относительной
простотой  аппаратной  реализации  системы команд процессора и
назревшей    необходимостью   в   персональных   ЭВМ   высокой
производительности,         качественно         поддерживающих
программирование  на  языках высокого и сверхвысокого уровней.
Переход  на новую элементную базу позволит создавать системы с
производительностью около  5  млн  операций  в секунду на один
транспьютерный модуль.



               Процессоры КРОНОС семейства 2.*

     Семейство   процессоров   Кронос-2.*  состоит  из  набора
процессоров,    выполненных    в   разных   конструктивах,   с
использованием различных системных шин. Все они реализуют одну
систему команд (М-код) и различаются только способами работы с
периферией и производительностью.


         Инженерные характеристики процессоров КРОНОС

  ---------------------------------------------------------
   Процессор |    Конструктив    | Шина | Число | Тактовая
             |                   |      | плат  | частота
  -----------+-------------------+------+-------+----------
             |                   |      |       |
    2.2      |  Электроника - 60 | Qbus |  1    |   4 MГц
             |                   |      |       |
             |                   |      |       |
    2.5      |    Multibus-1     | M-1  |  2    |   3 МГц
             |    (c) Intel      |      |       |
             |                   |      |       |
    2.6      | Евромеханика E-2  | Qbus | 4..8  |   3 МГц
             |    233.3x220mm    |      |       |
             |                   |      |       |
             |                   | TSB  |       |
             |                   |      |       |


     Данный  том  ставит  своей  целью  дать  представление об
архитектуре  процессоров  семейства  КРОНОС.  В первом разделе
вводятся  основные  понятия архитектуры. Раздел "Интерпретатор
m-кода"  содержит описание системы команд процессоров на языке
Модула-2.   За   этим   следует  описание  на  русском  языке,
представляющее  собой  развернутый  комментарий  к предыдущему
разделу.  Завершают  том  иллюстрации  к  работе процессоров и
компилятора с языка Модула-2.
.PAGE
.HEAD 1 '@wАРХИТЕКТУРА                      ВИРТУАЛЬНАЯ  МОДУЛА-2  МАШИНА@W'
.HEAD 0 '@wАРХИТЕКТУРА                      ВИРТУАЛЬНАЯ  МОДУЛА-2  МАШИНА@W'

                ВИРТУАЛЬНАЯ  МОДУЛА-2  МАШИНА

     Виртуальная  Модула-2  машина  (ВМ2М)  и ее программный и
аппаратный   интерпретаторы  поддерживают  процесс  исполнения
программ.   В  данном  разделе  будет  охарактеризован  M-код,
пояснена   его  интерпретация  и  проиллюстрированы  отдельные
команды.
     Основные отличия ВМ2М от традиционных машин:
     1)   вычисление  выражений  на  быстром  стеке  небольшой
аппаратно  фиксированной  глубины.  Освобождение  этого  стека
(копирование  в память) при вызове процедур-функций;
     2)  разделение  кода  и  области  данных любого процесса,
следствием  чего  является повторно-входимость всех программ и
даже их отдельных частей (модулей);
     3)  отказ  от  абсолютной адресации даже в сегменте кода.
Наличие таблицы смещений начал процедур упрощает их вызовы;
     4)  развитые  виды адресации отражают понятия современных
языков    программирования.   Имеется   адресация   локальных,
глобальных, внешних объектов и объектов промежуточного уровня;
     5)   специальные  операции  упрощают  реализацию  циклов,
вызовов, выбирающих операторов и некоторых других;
     6)   таблица   раздельно  загруженных  модулей  позволяет
организовать    динамическую    загрузку-связывание-исполнение
программ;
     7)   имеются команды для работы с мультизначениями.

     Для понимания этого раздела требуется знакомство с языком
программирования   Модула-2.   В   дальнейшем  считается,  что
читатель знаком со следующими понятиями Модулы-2:
     @wПРОГРАММА
     МОДУЛЬ
     ИМПОРТ-ЭКСПОРТ ОБЪЕКТОВ
     ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ
     ПРОЦЕДУРА
     ЛОКАЛЬНАЯ ПРОЦЕДУРА
     ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ@W

     Ввод/вывод  существенно  зависит от реализации и здесь не
рассматривается.
     ВМ2М   состоит   из   @wпроцессора@W,   @wстека@W   для  хранения
обрабатываемых  данных  и  вычисления  выражений (в дальнейшем
обозначается   @wА-стек@W),   регистра  -  указателя  (@wP-регистр@W),
@wсегмента кода@W и данных.
     @wПроцессор@W  ВМ2М  -  устройство  для  обработки  данных  и
интерпретирования инструкций управления (@wМ-кода@W).
     @wА-стек@W  - быстрый стек небольшой, аппаратно фиксированной
глубины, шириной в одно слово (здесь и далее: ширина машинного
слова  32 бита), с которым определены операции помещения слова
на стек (Push) и снятия слова с верхушки стека со счеркиванием
(Pop). Переполнение и исчерпание стека отслеживается аппаратно
с возбуждением соответствующего прерывания.
     @wПамять@W в ВМ2М представляется линейной последовательностью
слов   шириной   32   бита,  каждому  из  которых  сопоставлен
тридцатидвухразрядный  номер  - адрес слова. Адресуется только
все слово целиком.

          адрес: 0FFFFF               адрес: 1        адрес: 0
       _______________        _______________________________
 .... | 3 | 2 | 1 | 0 | .... | 3 | 2 | 1 | 0 | 3 | 2 | 1 | 0 |
       ---------------        -------------------------------

     Программа,   исполняемая   ВМ2М  в  фиксированный  момент
времени, называется @wпроцессом@W.
     Во  время  работы  ВМ2М  в  памяти  выделяются  следующие
структуры:    набор    раздельно   скомпилированных   модулей,
@wпроцедурных  стеков@W  (дальше @wП-стек@W), @wдескрипторов процессов@W и
таблица  указателей  на глобальные области загруженных модулей
(глобальная @wDFT@W - Data Frame Table).
     @wДескриптор   процесса@W  -  7  слов  в  памяти,  содержащие
указатели  на  специальные  информационные структуры в памяти,
связанные с процессом. Эти указатели в совокупности определяют
весь  контекст  процесса, т.е. всю информацию, необходимую для
исполнения текущего процесса виртуальной машиной. Адрес начала
дескриптора   текущего   процесса   содержится   в  @wP-регистре@W
процессора.
     В  терминах  Модулы-2  дескриптор  процесса  представляет
собой запись:
     TYPE Process_Descriptor = RECORD
                                 F, PC, G, H, S, L, M: WORD;
                               END;
     Каждое из полей дескриптора имеет специальное назначение,
описанное  ниже.  В  дальнейшем  поля дескриптора процесса для
удобства изложения называются регистрами процессора (например,
"Process_Descriptor.G" в дальнейшем "G - регистр").
     Примечание.   Существующие  реализации  ВМ2М  (процессоры
семейства   КРОНОС)   действительно  имеют  специализированные
регистры,  во  время  работы  содержащие копии соответствующих
полей   дескриптора   текущего   процесса.   При  переключении
процессов  текущее  содержимое  этих  регистров  копируется  в
память по адресу, содержащемуся в P-регистре.
     Готовый  к  исполнению  и  загруженный  в  память  модуль
состоит  из  @wсегмента кода@W, @wобласти глобальных данных@W, области
констант  структурных  типов,  т.е  строк,  массивов,  записей
(@wстроковый пул@W), области связи с внешними модулями - локальная
@wDFT@W (при наличии в модуле импорта объектов).
     @wСегмент  кода@W  занимает  непрерывный кусок памяти и имеет
сложную  структуру.  В  начале  сегмента находится @wпроцедурная
таблица@W:  до  256 слов, содержащих байтовые смещения от начала
сегмента  до  начала  кода  соответствующей  процедуры.  Таким
образом,   внутри   модуля  процедура  идентифицируется  своим
номером  в  процедурной  таблице  модуля. При исполнении любой
процедуры  модуля указатель на начало сегмента кода содержится
в  F-регистре  процессора.  В  другом  регистре - PC (Programm
Counter)- содержится байтовое смещение от начала сегмента кода
до байта, содержащего следующую за исполняемой в данный момент
команду.
     @wОбласть   глобальных   данных@W   одного   модуля  занимает
непрерывный  кусок памяти и представляется последовательностью
слов.   При   этом   однословные   данные   хранятся   в   них
непосредственно,  а структурные переменные представлены в виде
ссылки  на  специально  отведенные  для них области памяти. На
начало области глобальных данных текущего модуля указывает G -
регистр   процессора.   Таким  образом,  доступ  к  глобальным
переменным   модуля   организуется   индексно  по  содержимому
G-регистра,  т.е.  глобальное  слово  с  номером 3 находится в
ячейке  памяти  с  адресом  [G]+3  (здесь и далее запись [REG]
обозначает   содержимое  регистра  "REG").  Первые  два  слова
области   глобальных  данных  зарезервированы  для  спецальной
информации.  В  нулевом  слове области содержится указатель на
начало  сегмента кода данного модуля (копия F-регистра), в 1-м
слове - указатель на начало строкового пула.
     @wСтроковый   пул@W   занимает  непрерывный  кусок  памяти  и
содержит  в себе константы структурных типов (строки, массивы,
записи).   На  начало  строкового  пула  указывает  1-е  слово
глобальной области данных модуля.
     @wОбласть  связей@W   с  внешними  модулями  (локальная  DFT)
занимает  непрерывный  кусок  памяти и представляется массивом
слов,  содержащих  ссылку на элемент глобальной DFT, в котором
находится   указатель  на  начало  области  глобальных  данных
соответствующего   внешнего  модуля.  Таким  образом,  внешние
модули  идентифицируются индексом в локальной DFT модуля, т.е.
адрес  ссылки  на  область глобальных данных внешнего модуля с
номером i находится в элементе DFT[i].
     Локальная   DFT   располагается   непосредственно   перед
областью   глобальных   данных  модуля,  т.е.  элемент  DFT[i]
находится  по  адресу  [G]-i-1  памяти. Заметим, что при такой
организации  информации  для доступа к статически существующим
объектам  (процедурам,  переменным),  т.е.  объектам  внешнего
модуля,  которые могут быть проимпортированы, достаточно знать
только адрес начала области глобальных данных.
     @wП-стек@W   используется  для  размещения  @wлокальных  данных
процедур@W,  организации  вызовов  и  возвратов  из  процедур  и
размечен  тремя  регистрами процессора. S-регистр указывает на
вершину  П-стека,  т.е.  первое  свободное  на  П-стеке слово.
Н-регистр   указывает   на   верхнее   слово  области  памяти,
отведенной  под  П-стек  (предел  увеличения  [S]).  L-регистр
указывает   на  начало  области  локальных  данных  процедуры,
исполняемый  в данный момент (текущей). Перекрытие регистров S
и  H (т.е. ситуация, когда [S] >= [H]) отслеживается аппаратно
с возбуждением соответствующего прерывания.
     Область  @wлокальных данных@W текущей процедуры располагается
на  П-стеке  и  представляет  собой  последовательность  слов,
содержащих  однословные  локальные  переменные непосредственно
или   ссылки   на   начала  участков  памяти,  отведенных  для
переменных   структурных  типов.  Доступ  к  локальным  данным
осуществляется  индексно  по L-регистру, т.е локальное слово с
номером  i  находится  по  адресу  [L]+i в памяти. Специальные
команды облегчают доступ к локальным словам с номерами 4..255.
     Первые  4 локальных слова с номерами 0..3 зарезервированы
под  следующее: в нулевом локальном слове содержится указатель
на   начало  области  локальных  данных  объемлющей  процедуры
(процедуры,  внутри  которой  текущая  описана  как  локальная
процедура),   или   указатель  на  область  глобальных  данных
вызывающего  модуля  (если  процедура была вызвана из внешнего
модуля)  -  так  называемая @wстатическая цепочка@W. 1-е локальное
слово  указывает на начало области локальных данных процедуры,
из которой произошел вызов текущей (@wдинамическая цепочка@W). 2-е
локальное слово содержит значение PC возврата. В 3-е локальное
слово  при необходимости спасается маска прерываний процессора
(см. примечание к схеме (1) и интерпретатор M-кода).
     Организацию   кода,  статических  и  динамических  данных
процесса иллюстрирует схема (1).
.PAGE
                                                   Схема 1
     DFT
|------------|
|            |<------+                           <-32 бит->
|------------|       |
|       *----+-+     |    |----------|     ___   |--------|
|------------| |     +----+-----*    |  +-| F |->|проц0 *-+--+
| Таблицы    | |         :|----------|  |  ~~~   |--------|  |
: глобальных : |        01| DFT      |  |        |проц1 *-+----+
: областей   : |        00|   модуля |  |        |--------|  | |
|____________| |   ___    |==========|  |        :  ...   :  | |
               +--| G |-->|    *-----+--+        |========|  | |
|------------|     ~~~    |----------|           |код про-|<-+ |
|            |            |    *-----+-----+     |цедуры 0|    |
|------------|            |==========|     |     |        |    |
:            :         02 |глобальные|     |     |        |    |
:            :         03 |  данные  |     |     |--------|    |
|------------|         04 |  модуля  |     |     |код про-|<---+
|            |          : :          :     |     |цедуры 1|
|____________|         FF |__________|     |     |--------|
<-- 32 бита-->            <- 32 бита->     |     :  ...   :
                                           |     |________|
 ___    +--------------+       +-----------+     <- 8 бит->
| P |-->| Дескриптор   |       |
 ~~~    |    процесса  |       |  |---------------------------|
        |    (копия    |       +->|константы структурных типов|
        |   регистров  |          |  (массивы,записи,строки)  |
        |  процессора) |          |___________________________|
        |--------------|
        \/\/\/\/\/\/\/\/
                        <-----+
         /\/\/\/\/\/\/\ <--+  |
 ___    |--------------|   |  |          |         |  \
| L |-->| статическая  |   |  |          |  стек   |   |
 ~~~  00|  цепочка *----------+          |выражений|   | 7 слов
        |--------------|   |             |         |   |
        | динамическая |   |             |         |   |
      01|  цепочка *-------+             |_________|  /
        |--------------|                 <-32 бита->
        |  PC  точки ')|
      02|    вызова    |
        |--------------|   ___
      03|  M   маска ")|  | r | -- Регистры процессора
        |--------------|   ~~~
      04|  локальные   |   ') -- В случае  вызова  из внешнего
      05|    данные    |         модуля  L2  содержит пометку,
       ::   процедуры  :         и вместо статической  цепочки
 ___  FF|              |         в слове L0 сохранен G-регистр
| S |-->|--------------|
 ~~~    |              |   ") -- Текущая маска спасается в это
        :              :         слово только при первом изме-
 ___    |______________|         нении маски внутри процедуры,
| H |--><--- 32 бита--->         что также помечается в L2.
 ~~~                                                        *)

     Код  ВМ2М  (@wМ-код@W)  представляет собой поток байтов, т.е.
код  операции  всегда  занимает  один  байт.  Команды  ВМ2М не
содержат  в  себе  адресных  полей,  но по коду команды всегда
точно  известно, где  находятся  операнды.  Различные  команды
доступаются  к  данным  с  использованием  следующих  способов
адресации:
     локальный           : адрес = [L] + N
     глобальный          : адрес = [G] + N
     внешний             : адрес = DFT[M]^ + N
     промежуточный       : адрес = [L]^+ N
                                   или [[L]^]^+ N ...
     косвенный           : адрес = [POP()]^   + N,

где M - номер внешнего модуля, N - индекс объекта, символ  "^"
обозначает операцию разыменования указателя.
     Промежуточный   способ   адресации   представляет   собой
обращение   к   нелокальным   переменным  внутри  процедуры  и
осуществляет проход по статической цепочке процедур.
     Некоторые   команды   содержат   от   4  бит  до  4  байт
непосредственных  операндов,  причем  по  коду операции всегда
однозначно  известно,  сколько байт непосредственных операндов
следует за ним. При извлечении данных из потока команд и самих
команд   счетчик  команд  (PC)  передвигается  на  1..4  байта
соответственно.
     M-код  имеет  четыре  модификации длины непосредственного
операнда:
     1.   Полубайтовый   операнд:  последние  4  бита  команды
интерпретируются  как непосредственный операнд. Так, например,
имеются команды
    LI0, LI1,...,LI15:
     (*  Load  Immediate  - загрузка непосредственная с кодами
0,1,...,15 и семантикой: *)
    Push(IR MOD 16)
(* где IR - регистр кода команды *)

    SLW4,...,SLW15:
(* Store Local Word *)
    STK[L + IR MOD 16] := Pop();
(* STK -физическая или логическая память *)
Таким образом, тело процедуры

    PROCEDURE p; CONST c=2;
      VAR i: INTEGER;
    BEGIN i:=c;
    END p;

перейдет в две следующие однобайтовые команды:
    LI2
    SLW4.

     Замечание:    команды   LI0..LI15   очень   полезны   для
представления значений перечислимых типов, например,
   Color=(Red, Green, Blue);

     2. Байтовый операнд:
        Например,
    LIB:
(* Load Immediate Byte *)
    Push(Next());
(* Next() - операция выборки одного байта из кода *)
     При  замене  описания  константы  в предыдущем примере на
следующее:
    c=153
породится код
    LIB
    153
    SLW4
     3.  Двухбайтовый  операнд  -  представленный следующей за
кодом парой байтов.
     4.  Словный  операнд  - представленный следующей за кодом
четверкой байтов.
     Cуществуют команды, имеющие несколько операндов различной
длины  (см.,  например,  FOR1  и FOR2 в интерпретаторе системы
команд).
     Команды  ВМ2М условно подразделяются на следующие группы:
арифметико-логические, команды организации управления, команды
для работы с А-стеком, вспомогательные.
     Команды для работы со стеком содержат инструкции загрузки
констант,  обмена  стека с локальными, глобальными, внешними и
другими данными.
     Все арифметико-логические операции работают над одним или
двумя  верхними элементами стека и помещают результат на место
аргументов.
     Команды  для организации управления представлены обычными
командами  переходов,  условных  и  безусловных,  специальными
командами  для  организации  операторов  FOR  и  CASE, набором
инструкций  вызова  и возврата из процедуры. Сюда же относятся
команды   TRAP   -   программного   прерывания  и  TRANSFER  -
переключения процессов, аналог переключения сопрограмм, дающий
мощное  средство  для  организации  мультипрограммной работы и
синхронизации.
     Механизм   передачи   параметров  процедурам  может  быть
различным.   В  существующей  реализации  передача  параметров
осуществляется   через   арифметический  стек,  что  сокращает
расходы на обработку параметров в точке вызова.
     Все прерывания обрабатываются как переключения процессов,
указатели   которых   находятся   в   соответствующем   номеру
прерывания элементе массива векторов прерываний.
     ВМ2М  имеет  набор  вспомогательных  команд,  облегчающих
обработку   мультизначений,   параметров   процедуры,  команды
ввода/вывода и др..
     Более  полное  и  подробное  представление  о  ВМ2М можно
получить,  ознакомившись  с  программой интерпретатора M-кода,
которая также является спецификацией микропрограмм процессоров
Кронос.
.PAGE
.HEAD 1 '@wАРХИТЕКТУРА                               ИНТЕРПРЕТАТОР M-КОДА@W'
.HEAD 0 '@wАРХИТЕКТУРА                               ИНТЕРПРЕТАТОР M-КОДА@W'

                    ИНТЕРПРЕТАТОР  M-КОДА
(*

     00     20      40      60      80     A0     C0     E0

00   LI0    LLW     LXB     LSW0           LSS    MOVE   INCL
01   LI1    LGW     LXW     LSW1    QUIT   LEQ    RDS    EXCL
02   LI2    LEW     LGW2    LSW2    GETM   GTR    LSTA   SLEQ
03   LI3    LSW     LGW3    LSW3    SETM   GEQ    COMP   SGEQ
04   LI4    LLW4    LGW4    LSW4    TRAP   EQU    GB     INC1
05   LI5    LLW5    LGW5    LSW5    TRA    NEQ    GB1    DEC1
06   LI6    LLW6    LGW6    LSW6    TR     ABS    CHK    INC
07   LI7    LLW7    LGW7    LSW7    IDLE   NEG    CHKZ   DEC

08   LI8    LLW8    LGW8    LSW8    ADD    OR     ALLOC  STOT
09   LI9    LLW9    LGW9    LSW9    SUB    AND    ENTR   LODT
0A   LI0A   LLW0A   LGW0A   LSW0A   MUL    XOR    RTN    LXA
0B   LI0B   LLW0B   LGW0B   LSW0B   DIV    BIC    NOP    LPC
0C   LI0C   LLW0C   LGW0C   LSW0C   SHL    IN     CX    *BBU
0D   LI0D   LLW0D   LGW0D   LSW0D   SHR    BIT    CI    *BBP
0E   LI0E   LLW0E   LGW0E   LSW0E   ROL    NOT    CF   **BBLT
0F   LI0F   LLW0F   LGW0F   LSW0F   ROR    MOD    CL

10   LIB    SLW     SXB     SSW0 ***IO0    DECS   CL0    SWAP
11   LID    SGW     SXW     SSW1    IO1    DROP   CL1    LPA
12   LIW    SEW     SGW2    SSW2    IO2    LODFV  CL2    LPW
13   LIN    SSW     SGW3    SSW3    IO3    STORE  CL3    SPW
14   LLA    SLW4    SGW4    SSW4    IO4    STOFV  CL4    SSWU
15   LGA    SLW5    SGW5    SSW5    IO5    COPT   CL5
16   LSA    SLW6    SGW6    SSW6    IO6    CPCOP  CL6
17   LEA    SLW7    SGW7    SSW7    IO7    PCOP   CL7

18   JFLC   SLW8    SGW8    SSW8    FADD   FOR1   CL8
19   JFL    SLW9    SGW9    SSW9    FSUB   FOR2   CL9
1A   JFSC   SLW0A   SGW0A   SSW0A   FMUL   ENTC   CL0A   ACTIV
1B   JFS    SLW0B   SGW0B   SSW0B   FDIV   XIT    CL0B   USR
1C   JBLC   SLW0C   SGW0C   SSW0C   FCMP   ENTS   CL0C   SYS
1D   JBL    SLW0D   SGW0D   SSW0D   FABS          CL0D  *NII
1E   JBSC   SLW0E   SGW0E   SSW0E   FNEG   ORJP   CL0E
1F   JBS    SLW0F   SGW0F   SSW0F   FFCT   ANDJP  CL0F   INVLD


  * -- Не реализовано на П2.2.
 ** -- Не реализовано.
*** -- Команды IO0..IO7 определяют интерфейс процессора с шиной.

----------------------------------------------------------------
(c) COPYRIGHT Kronos Research Group      1985,1986,1987

    Последнее исправление                30-Aug-1987
.PAGE

MODULE Kronos_Interpreter;  (* Leo 27-Nov-85. (c) Kronos *)
                            (* Ned 30-Aug-87. (c) KRONOS *)

(* Этот интерпретатор является спецификацией аппаратуры. *)

FROM SYSTEM    IMPORT  ADDRESS, WORD, ADR;
FROM KRONOS    IMPORT  ROR, ROL, SHR, SHL;

TYPE CPUs = (Kronos2_2, Kronos2_5, Kronos2_6);

VAR cpu: CPUs;

CONST ESdepth = 7; (* глубина стека выражений *)

TYPE
  BYTE     = [0..255];
  WORD16   = [0..0FFFFh];
  PC_Range = WORD16;
  CodePtr  = POINTER TO ARRAY PC_Range OF BYTE;

VAR
  PC:    PC_Range;    (* счетчик команд *)
  IR:    [0..0FFh];   (* регистр команды *)
  F :    CodePtr;     (* адрес сегмента кода *)
  G :    ADDRESS;     (* адрес сегмента глобальных данных *)
  L :    ADDRESS;     (* адрес сегмента локальных  данных *)
  S :    ADDRESS;     (* адрес вершины  П-стека *)
  H :    ADDRESS;     (* граница П-стека *)
  P :    ADDRESS;     (* адрес дескриптора процесса *)
  M :    BITSET;      (* маска прерываний *)
  Ipt:   BOOLEAN;     (* запрос на прерывание *)
  IptNo: WORD16;      (* номер прерывания *)

(* Номера прерываний, аппаратно фиксированные:

   01h    таймер
   02h    останов процессора
   03h    обращение к отсутствующей памяти
   04h    авария питания
   05h    ошибка процессора
   06h    ошибка ввода вектора прерывания
   07h    нереализованная команда
   08h    по вызову процедуры      (П2.2)
   09h    по возврату из процедуры (П2.2)

   0Bh    трассировка (прерывание по каждой команде)
          (П2.5,П2.6)

   40h    переполнение П-стека (S>H)
   41h    переполнение целого
   42h    переполнение вещественного
   43h    исчерпание вещественного
   44h    переполнение адреса

   49h    INVLD команда
   4Ah    выход из диапазона
   4Bh    неверный параметр команды (аппаратный ASSERT)
   4Ch    исчерпание или переполнение стека выражений

   Замечание  1.  О  том,  как  маскируются  прерывания, см. в
   процедуре NotMasked.

   Замечание  2. Если в скобках указаны модели процессоров, то
   прерывание возбуждается только для этих моделей.
*)

CONST  (* номера битов в слове L2 (см. рис.) *)
  ExternalBit   = 1Fh;
  ChangeMaskBit = 1Eh;

CONST
  NonVectBit = 1Fh;
(* бит, маскирующий программные прерывания *)

(* Замечание.  Регистр  H  задает заниженную на ESdepth+1 слов
   границу   стека.   Это   необходимо  для  сохранения  стека
   выражений при переключении процессов.
*)

VAR Core: ARRAY ADDRESS OF WORD; (* Вся память *)
    ByteCore: ARRAY OF BYTE; (* Наложен на Core *)

MODULE InstructionFetch;

  IMPORT F, PC, WORD, WORD16, BYTE, Core, ADDRESS;
  EXPORT Next, Next2, Next4, GetPc;

  PROCEDURE Next(): BYTE;
  BEGIN INC(PC); RETURN INTEGER(F^[PC-1])
  END Next;

  PROCEDURE Next2(): WORD16;
  BEGIN RETURN Next()+Next()*100h
  END Next2;

  PROCEDURE Next4(): WORD;
  BEGIN RETURN Next2()+Next2()*10000h
  END Next4;

  PROCEDURE GetPc(procno: INTEGER): INTEGER;
  (* Выдает PC начала процедуры *)
  BEGIN RETURN Core[ADDRESS(F)+procno]
  END GetPc;

END InstructionFetch;

MODULE Mask;
  IMPORT M, NonVectBit, BYTE;
  EXPORT NotMasked;

  PROCEDURE NotMasked(N: BYTE): BOOLEAN;
  BEGIN
    IF    (N>=0Fh) & (N<3Fh)  THEN RETURN (0 IN M)
    ELSIF (N< 0Fh) & (N>0)    THEN RETURN (0 IN M) & (N IN M)
    ELSIF (N =3Fh)            THEN RETURN (NonVectBit IN M)
    ELSE ASSERT(FALSE)
    END
  END NotMasked;

END Mask;

MODULE ExpressionStack;
  IMPORT WORD, ESdepth, Ipt, IptNo;
  EXPORT Push, Pop, Empty;

  VAR A: ARRAY [0..ESdepth-1] OF WORD;  sp: [0..ESdepth];

  PROCEDURE Push(X: WORD);
  BEGIN A[sp]:=X;
    IF sp<ESdepth THEN INC(sp) ELSE Ipt:=TRUE; IptNo:=4Ch END;
  END Push;

  PROCEDURE Pop(): INTEGER;
  BEGIN
    IF sp=0 THEN Ipt:=TRUE; IptNo:=4Ch ELSE DEC(sp) END;
    RETURN A[sp];
  END Pop;

  PROCEDURE Empty(): BOOLEAN;
  BEGIN RETURN sp=0 END Empty;

BEGIN sp:=0 END ExpressionStack;

MODULE ProcessSupport;
  IMPORT PC,G,F,H,L,S,P,M, Core, NotMasked, ESdepth
       , CodePtr, WORD16, ADDRESS;
  FROM ExpressionStack IMPORT Pop, Push, Empty;

  EXPORT SaveExpStack, RestoreExpStack, Transfer, TRAP;

  PROCEDURE SaveExpStack;
    VAR c: CARDINAL; (* счетчик глубины стека *)
  BEGIN c:=0;
    WHILE NOT Empty() DO Core[S]:=Pop(); INC(S); INC(c) END;
    Core[S]:=c; INC(S);
  END SaveExpStack;

  PROCEDURE RestoreExpStack;
    VAR c: CARDINAL; (* счетчик глубины стека *)
  BEGIN DEC(S); c:=Core[S];
    WHILE c>0 DO DEC(c); DEC(S); Push(Core[S]) END;
  END RestoreExpStack;

  PROCEDURE SaveRegs;
  BEGIN SaveExpStack;
    Core[P+0]:=G;  Core[P+1]:=L;
    Core[P+2]:=PC; Core[P+3]:=CARDINAL(M);
    Core[P+4]:=S;  Core[P+5]:=H+ESdepth+1;  
  END SaveRegs;

  PROCEDURE RestoreRegs;
  BEGIN
    G:=Core[P+0];    F :=CodePtr(Core[G]);
    L:=Core[P+1];    PC:=Core[P+2];  M:=BITSET(Core[P+3]);
    S:=Core[P+4];    H:=Core[P+5]-ESdepth-1;
    RestoreExpStack;
  END RestoreRegs;

  PROCEDURE Transfer(pFrom,pTo: ADDRESS);
    VAR j: CARDINAL;
  BEGIN (* заметьте - pFrom может быть равно pTo *)
    j:=Core[pTo]; SaveRegs; Core[pFrom]:=P; Core[1]:=P;
    P:=j;         RestoreRegs;              Core[0]:=P;
  END Transfer;

  PROCEDURE TRAP(N: WORD16);
  BEGIN Core[P+6]:=N;
    IF N>3Fh THEN N:=3Fh END;
    IF NotMasked(N) THEN Transfer(N*2,Core[N*2+1]) END;
  END TRAP;

END ProcessSupport;

(* Маркировка П-стека перед вызовом процедуры *)

PROCEDURE  Mark(X: ADDRESS; External: BOOLEAN);
  VAR i: ADDRESS;
BEGIN i:=S;
  Core[S]:=X; INC(S); (* статическая  цепочка *)
  Core[S]:=L; INC(S); (* динамическая цепочка *)
  IF External THEN Core[S]:=WORD(BITSET(PC)+{ExternalBit})
  ELSE             Core[S]:=PC
  END; INC(S,2); L:=i;
END Mark;

PROCEDURE ioP2_2;
BEGIN ASSERT(IR-90h IN {0..7});
(* см. документацию на П2.2 *)
END ioP2_2;

PROCEDURE ioP2_5;
BEGIN ASSERT(IR-90h IN {0..7});
(* Запросы  на  В/В  передаются другим процессорам через общую
   память. См. LABTAM 3000 manuals.
*)
END ioP2_5;

PROCEDURE ioP2_6;
BEGIN ASSERT(IR-90h IN {0..7});
(* Смотря на какой шине.
*)
END ioP2_6;

(* Рабочие переменные интерпретатора: *)

VAR i,j,k: CARDINAL;   X,Y  : REAL;
    v,w  : BITSET;     a,b  : CHAR;
    adr,adr1,sz,hi,low: CARDINAL;

PROCEDURE ConsolMicroProgram;
BEGIN
(* Пультовая  микропрограмма  позволяет  произвести  начальную
   загрузку  программы  и  по команде оператора "Go" выполняет
   Transfer(0,1).
*)
END ConsolMicroProgram;

PROCEDURE Interpret;
BEGIN
  CASE IR OF
   00h..0Fh:(* LI0..LI0F  Load Immediate *) Push(IR MOD 10h);

  |10h: (* LIB  Load Immediate Byte *) Push(Next())
  |11h: (* LID  Load Immediate Double byte *) Push(Next2())
  |12h: (* LIW  Load Immediate Word *) Push(Next4())
  |13h: (* LIN  Load Immediate NIL  *) Push(NIL)
  |14h: (* LLA  Load Local  Address *) Push(L+Next())
  |15h: (* LGA  Load Global Address *) Push(G+Next())
  |16h: (* LSA  Load Stack  Address *) Push(Pop()+Next())
  |17h: (* LEA  Load External Addres *)
        i:=G-Next()-1; (* индекс в DFT модуля.*)
        adr:=Core[i]; (* указатель на элемент большой DFT *)
        Push(Core[adr]+Next())
  |18h: (* JFLC Jump Forward Long Condition *)
        IF Pop()=0 THEN PC:=Next2()+PC
        ELSE INC(PC,2) END
  |19h: (* JFL  Jump Forward Long *) PC:=Next2()+PC;
  |1Ah: (* JFSC Jump Forward Short Condition *)
        IF Pop()=0 THEN PC:=Next()+PC
        ELSE INC(PC) END
  |1Bh: (* JFS  Jump Forward Short *) PC:=Next()+PC;
  |1Ch: (* JBLC Jump Back Long Condition *)
        IF Pop()=0 THEN PC:=-Next2()+PC
        ELSE INC(PC,2) END
  |1Dh: (* JBL  Jump Back Long *) PC:=-Next2()+PC;
  |1Eh: (* JBSC Jump Back Short Condition *)
        IF Pop()=0 THEN PC:=-Next()+PC
        ELSE INC(PC) END
  |1Fh: (* JBS  Jump Back Short  *) PC:=-Next()+PC;
  |20h: (* LLW  Load Local  Word *)  Push(Core[L+Next()])
  |21h: (* LGW  Load Global Word *)  Push(Core[G+Next()])
  |22h: (* LEW  Load External Word *)
        i:=G-Next()-1; adr:=Core[Core[i]]; (* external G *)
        Push(Core[adr+Next()])
  |23h: (* LSW  Load Stack addressed Word *)  
         Push(Core[Pop()+Next()])
  |24h..2Fh: (* LLW0..LLW0F Load Local Word *)
        Push(Core[L+IR MOD 10h])
  |30h: (* SLW  Store Local  Word *)  Core[L+Next()]:=Pop()
  |31h: (* SLW  Store Global Word *)  Core[G+Next()]:=Pop()
  |32h: (* SEW  Store External Word *)
        i:=G-Next()-1; adr:=Core[Core[i]]; (* external G *)
        Core[adr+Next()]:=Pop()
  |33h: (* SSW  Store Stack addressed Word *)
        i:=Pop(); Core[Pop()+Next()]:=i
  |34h..3Fh: (* SLW0..SLW0F  Store Local Word *)
        Core[L+IR MOD 10h]:=Pop()

  |40h: (* LXB  Load Indexed Byte *)
        i:=Pop(); Push(ByteCore[Pop()*4+i]);
  |41h: (* LXW  Load Indexed Word *)
        i:=Pop(); Push(Core[Pop()+i])
  |42h..4Fh: (* LGW02..LGW0F  Load Global Word *)
        Push(Core[G+IR MOD 10h])
  |50h: (* SXB  Store Indexed Byte *)
        j:=Pop(); i:=Pop(); ByteCore[Pop()*4+i]:=j;
  |51h: (* SXW  Store Indexed Word *)
        j:=Pop(); i:=Pop(); Core[Pop()+i]:=j
  |52h..5Fh: (* SGW02..SGW0F  Store Global Word *)
        Core[G+IR MOD 10h]:=Pop()

  |60h..6Fh: (* LSW00..LSW0F  Load  Stack addressed Word *)
        Push(Core[Pop()+IR MOD 10h])
  |70h..7Fh: (* SSW00..SSW0F  Store Stack addressed Word *)
        i:=Pop(); Core[Pop()+IR MOD 10h]:=i

  |80h: TRAP(7h);
  |81h: (* QUIT   Stop processor *) ConsolMicroProgram
  |82h: (* GETM   Get Mask *) Push(M)
  |83h: (* SETM   Set Mask *)
        IF NOT (ChangeMaskBit IN BITSET(Core[L+2])) THEN
          (* маска меняется впервые*)
          Core[L+2]:=WORD(BITSET(Core[L+2])+{ChangeMaskBit});
          Core[L+3]:=WORD(M)
        END; M:=BITSET(Pop);
  |84h: (* TRAP interrupt simulation *) TRAP(Pop())
  |85h: (* TRA   Transfer control between process *)
        i:=Pop(); Transfer(Pop(),i)
  |86h: (* TR    Test & Reset *)
        i:=Pop(); Push(Core[i]); Core[i]:=0
  |87h: (* IDLE  IDLE process *)
        DEC(PC); REPEAT (* не занимая шины *) UNTIL Ipt
(* В   следующих   шести   командах,   а   также   в  командах
   MOD,NEG,ABS,FOR2,INC,DEC,INC1,DEC1  в  случае  переполнения
   возбуждaeтся прерывание с IptNo=41h.
*)
  |88h: (* ADD  integer ADD *) Push(Pop()+Pop())
  |89h: (* SUB  integer SUB *) i:=Pop(); Push(Pop()-i);
  |8Ah: (* MUL  integer MUL *) Push(Pop()*Pop())
  |8Bh: (* DIV  integer DIV *) i:=Pop(); Push(Pop() DIV i)
  |8Ch: (* SHL  integer SHift Left *)
        i:=Pop() MOD 20h; Push(SHL(Pop(),i))
  |8Dh: (* SHR  integer SHift Right *)
        i:=Pop() MOD 20h; Push(SHR(Pop(),i))

  |8Eh: (* ROL  word ROtate Left  *)
        i:=Pop() MOD 20h; Push(ROL(Pop(),i))
  |8Fh: (* ROR  word ROtate Right *)
        i:=Pop() MOD 20h; Push(ROR(Pop(),i))
  |90h..97h: (* io section *)
        CASE cpu OF
          |Kronos2_2: ioP2_2
          |Kronos2_5: ioP2_5
          |Kronos2_6: ioP2_6
        ELSE ASSERT(FALSE);
        END

(* В   следующих   восьми   командах   при   переполнении  или
   исчезновении  порядка  возбуждаются  прерывания с IptNo=42h
   или 43h соответственно.
*)
  |98h: (* FADD  Float ADD *) Push(REAL(Pop())+REAL(Pop()))
  |99h: (* FSUB  Float SUB *) X:=REAL(Pop()); Push(REAL(Pop())-X)
  |9Ah: (* FMUL  Float MUL *) Push(REAL(Pop())*REAL(Pop()))
  |9Bh: (* FDIV  Float DIV *) X:=REAL(Pop()); Push(REAL(Pop())/X)
  |9Ch: (* FCMP  Float CoMPare *) X:=REAL(Pop()); Y:=REAL(Pop());
        IF    X<Y THEN Push(1); Push(0)
        ELSIF X>Y THEN Push(0); Push(1)
        ELSE Push(0); Push(0) END
  |9Dh: (* FABS  Float ABS *) X:=REAL(Pop());
        IF X<0.0 THEN Push(-X) ELSE Push(X) END
  |9Eh: (* FNEG  Float NEG *) Push(-REAL(Pop()))
  |9Fh: (* FFCT  Float FunCTions *) i:=Next();
        IF    i=0 THEN Push(FLOAT(INTEGER(Pop())))
        ELSIF i=1 THEN Push(TRUNC(   REAL(Pop())))
        ELSE DEC(PC); TRAP(7h) END;

 |0A0h: (* LSS  int LeSS             *) i:=Pop(); Push(Pop()<i)
 |0A1h: (* LEQ  int Less    or EQual *) i:=Pop(); Push(Pop()<=i)
 |0A2h: (* GTR  int GreaTeR          *) i:=Pop(); Push(Pop()>i)
 |0A3h: (* GEQ  int Greater or EQual *) i:=Pop(); Push(Pop()>=i)
 |0A4h: (* EQU  int EQUal     *) Push(Pop()=Pop())
 |0A5h: (* NEQ  int Not EQual *) Push(Pop()#Pop())
 |0A6h: (* ABS  int ABSolute value *) Push(ABS(Pop()))
 |0A7h: (* NEG  int NEGate         *) Push(-Pop())

 |0A8h: (* OR   logical bit per bit OR *)
        v:=BITSET(Pop()); w:=BITSET(Pop()); Push(w+v)
 |0A9h: (* AND  logical bit per bit AND *)
        v:=BITSET(Pop()); w:=BITSET(Pop()); Push(w*v)
 |0AAh: (* XOR  logical bit per bit XOR *)
        v:=BITSET(Pop()); w:=BITSET(Pop()); Push(w/v)
 |0ABh: (* BIC  logical bit per bit BIt Clear *)
        v:=BITSET(Pop()); w:=BITSET(Pop()); Push(w-v)
 |0ACh: (* IN   membership to bitset *)
        v:=BITSET(Pop()); Push(Pop() IN v)
 |0ADh: (* BIT  setBIT *) i:=Pop();
        IF (i<0) OR (i>=20h) THEN TRAP(4Ah)
        ELSE w:={}; INCL(w,i); Push(w) END

 |0AEh: (* NOT  boolean NOT (not bit per bit!) *) Push(Pop()=0)
 |0AFh: (* MOD  integer MODulo *) i:=Pop(); Push(Pop() MOD i)

 |0B0h: (* DECS  DECriment S register (reverse to ALLOC) *) 
        DEC(S,Pop())
 |0B1h: (* DROP *) i:=Pop();
 |0B2h: (* LODF  reLOaD expr. stack after Function return *)
        i:=Pop(); RestoreExpStack; Push(i)
 |0B3h: (* STORE STORE expr. stack before function call *)
        IF S+ESdepth+1>H THEN DEC(PC); TRAP(40h) 
        ELSE SaveExpStack
        END
 |0B4h: (* STOFV STOre expr. stack with Formal function Value
           on top before function call (см. команду CF) 
         *)
        IF S+ESdepth+2>H THEN DEC(PC); TRAP(40h)
        ELSE i:=Pop(); SaveExpStack; Core[S]:=i; INC(S) END
 |0B5h: (* COPT  COPy Top of expr. stack *)
        i:=Pop(); Push(i); Push(i)
 |0B6h: (* CPCOP Character array Parameter COPy *)
        i:=Pop(); (* High *) sz:=(i+4) DIV 4;
        IF S+sz>H THEN Push(i); DEC(PC); TRAP(40h)
        ELSE Core[L+Next()]:=S; adr:=Pop();
          WHILE sz>0 DO Core[S]:=Core[adr]; INC(S); INC(adr) END
        END
 |0B7h: (* PCOP  structure Parameter allocate and COPy *)
        i:=Pop(); (* High *) sz:=i+1;
        IF S+sz>H THEN Push(i); DEC(PC); TRAP(40h)
        ELSE Core[L+Next()]:=S; adr:=Pop();
          WHILE sz>0 DO Core[S]:=Core[adr]; INC(S); INC(adr) END
        END
 |0B8h: (* FOR1  enter  FOR statment *)
        IF S+2>H THEN DEC(PC); TRAP(40h)
        ELSE sz:=Next(); (* =0 up; #0 down *)
          hi:=Pop(); low:=Pop(); adr:=Pop(); k:=Next2()+PC;
          IF ((sz=0) & (low<=hi)) OR ((sz#0) & (low>=hi)) THEN 
            Core[adr]:=low;
            Core[S]:=adr; INC(S); Core[S]:=hi; INC(S);
          ELSE (* цикл не исполняется не разу *) PC:=k
          END
        END
 |0B9h: (* FOR2  end of FOR statment *)
        hi:=Core[S-1]; adr:=Core[S-2]; sz:=Next();
        IF sz>7Fh THEN sz:=7Fh-sz END; (* шаг [-128..127] *)
        k:=-Next2()+PC;  i:=Core[adr]+sz;
        IF ((sz>=0) & (i>hi)) OR ((sz<0) & (i<hi)) THEN
          DEC(S,2); (* terminate *)
        ELSE Core[adr]:=i; PC:=k (* continue *)
        END
 |0BAh: (* ENTC  ENTer Case statment *)
        IF S+1>H THEN DEC(PC); TRAP(40h)
        ELSE PC:=Next2()+PC; (* jump to case table *)
          k:=Pop(); low:=Next2(); hi:=Next2();
          Core[S]:=PC + 2*(hi-low) + 4; INC(S);(*PC for exit*)
          IF (k>=low) & (k<=hi) THEN
            PC:=PC+2*(k-low+1) (* jump into case table *)
          END;
          PC:=-Next2()+PC (* jump back to variant's code *)
        END
 |0BBh: (* XIT  eXIT from case or control structure *)
        DEC(S); PC:=Core[S]
 |0BCh: (* ENTS ENTer control Structure *)
        IF S+1>H THEN DEC(PC); TRAP(40h)
        ELSE Core[S]:=Next2()+PC; INC(S) END
 |0BEh: (* ORJP   short circuit OR  JumP *)
        IF Pop()#0 THEN Push(1); PC:=Next()+PC
        ELSE INC(PC) END
 |0BFh: (* ANDJP  short circuit AND JumP *)
        IF Pop()=0 THEN Push(0); PC:=Next()+PC
        ELSE INC(PC) END
 
 |0C0h: (* MOVE   MOVE block *) sz:=Pop();
        i:=Pop(); j:=Pop();
        WHILE sz>0 DO 
          Core[j]:=Core[i]; INC(i); INC(j); DEC(sz)
        END
 |0C1h: (* RDS  ReaD String *) sz:=Next();
        IF sz>20h THEN DEC(PC,2); TRAP(4Bh)
        ELSE adr:=Pop();
          WHILE sz>0 DO Core[adr]:=Next4(); INC(adr); DEC(sz) END
        END
 |0C2h: (* LSTA  Load STring Address *) Push(Core[G+1]+Next2());
 |0C3h: (* COMP  COMPare strings *) i:=Pop()*4; j:=Pop()*4;
        REPEAT a:=CHAR(ByteCore[i]); b:=CHAR(ByteCore[j]);
        INC(i); INC(j)
        UNTIL (a=0c) OR (b=0c) OR (a#b); Push(a); Push(b)
 |0C4h: (* GB  Get procedure Base n level down *)
        i:=L; k:=Next();
        WHILE k>0 DO i:=Core[i]; DEC(k) END; Push(i)
 |0C5h: (* GB1 Get procedure Base 1 level down *) Push(Core[L])
 |0C6h: (* CHK   range bounds CHecK *)
        hi:=Pop(); low:=Pop(); i:=Pop(); Push(i);
        IF (i<low) OR (i>hi) THEN
          Push(low); Push(hi); TRAP(4Ah)
        END
 |0C7h: (* CHKZ  array bounds CHecK (low=Zero) *)
        hi:=Pop(); i:=Pop(); Push(i);
        IF (i<0) OR (i>hi) THEN Push(hi); TRAP(4Ah) END
 |0C8h: (* ALLOC ALLOCate block *) sz:=Pop();
        IF S+sz>H THEN  Push(sz); DEC(PC); TRAP(40h)
        ELSE Push(S); INC(S,sz) END
 |0C9h: (* ENTR  ENTeR procedure *) sz:=Next();
        IF S+sz>H THEN DEC(PC,2); TRAP(40h)
        ELSE INC(S,sz) END
 |0CAh: (* RTN   ReTurN from procedure *)
        S:=L; L:=Core[S+1]; PC:=WORD(BITSET(Core[S+2])*{0..0Fh});
        IF ExternalBit IN BITSET(Core[S+2]) THEN 
          (* external called *)
          G:=Core[S]; F:=CodePtr(Core[G])
        END;
        IF ChangeMaskBit IN BITSET(Core[S+2]) THEN 
          (* mask was changed *)
          M:=BITSET(Core[S+3])*{0..10h}
        END;
 |0CBh: (* NOP   No OPeration  *)
 |0CCh: (* CX    Call eXternal *)
        IF S+4<=H THEN j:=Core[G-Next()-1]; (* big DFT *)
          i:=Next(); Mark(G,TRUE);
          G:=Core[j]; F:=CodePtr(Core[G]); PC:=GetPc(i);
        ELSE DEC(PC); TRAP(40h) END
 |0CDh: (* CI    Call procedure at Intermediate level *)
        IF S+4<=H THEN 
          i:=Next(); Mark(Pop(),FALSE); PC:=GetPc(i);
        ELSE DEC(PC); TRAP(40h) END
 |0CEh: (* CF    Call Formal procedure *)
        IF S+3<=H THEN i:=Core[S-1]; DEC(S); Mark(G,TRUE);
          k:=i DIV 1000000h; i:=i MOD 1000000h;
          G:=Core[i]; F:=CodePtr(Core[G]); PC:=GetPc(k);
        ELSE DEC(PC); TRAP(40h) END
 |0CFh: (* CL    Call Local procedure *)
        IF S+4<=H THEN i:=Next(); Mark(L,FALSE); PC:=GetPc(i);
        ELSE DEC(PC); TRAP(40h) END
 |0D0h..0DFh: (* CL0..CL0F  Call Local procedure *)
        IF S+4<=H THEN Mark(L,FALSE); PC:=GetPc(IR MOD 10h);
        ELSE DEC(PC); TRAP(40h) END
 |0E0h: (* INCL  INCLude in set *)  i:=Pop();
        IF (i<0) OR (i>1Fh) THEN Push(i); DEC(PC); TRAP(4Ah)
        ELSE j:=Pop(); w:=BITSET(Core[j]); INCL(w,i);
          Core[j]:=CARDINAL(w) 
        END
 |0E1h: (* EXCL  EXCLude from set *)  i:=Pop();
        IF (i<0) OR (i>1Fh) THEN Push(i); DEC(PC); TRAP(4Ah)
        ELSE j:=Pop(); w:=BITSET(Core[j]); EXCL(w,i);
          Core[j]:=CARDINAL(w) 
        END
 |0E2h: (* SLEQ  bitSet Less    or EQual *)
        w:=BITSET(Pop()); v:=BITSET(Pop()); Push(v<=w)
 |0E3h: (* SGEQ  bitSet Greater or EQual *)
        w:=BITSET(Pop()); v:=BITSET(Pop()); Push(v>=w)
 |0E4h: (* INC1  INCrement by 1 *) INC(Core[Pop()])
 |0E5h: (* DEC1  DECrement by 1 *) DEC(Core[Pop()])
 |0E6h: (* INC   INCrement *) i:=Pop(); INC(Core[Pop()],i)
 |0E7h: (* DEC   DECrement *) i:=Pop(); DEC(Core[Pop()],i)
 |0E8h: (* STOT  STOre Top on proc stack *)
        IF S+1>H THEN DEC(PC); TRAP(40h)
        ELSE Core[S]:=Pop(); INC(S)
        END
 |0E9h: (* LODT  LOaD   Top of proc stack *)
        DEC(S); Push(Core[S])
 |0EAh: (* LXA   Load indeXed Address *)
        sz:=Pop(); i:=Pop(); adr:=Pop(); Push(adr+i*sz)
 |0EBh: (* LPC   Load Procedure Constant *)
        i:=Next(); j:=Next(); Push(j*1000000h+Core[G-i-1])

(* Следующие  3  команды  работают  с вырезками битов. Битовый
   адрес - это пара (адрес,битовое смещение). Битовое смещение
   может  быть  больше  32.  Вырезка  может переходить границы
   слова.
*)
 |0ECh: (* BBU  Bit Block Unpack *)
        sz:=Pop();
        IF (sz<1) OR (sz>32) THEN
          Push(sz); DEC(PC); TRAP(4Ah)
        END;
        i:=Pop(); adr:=Pop();
        (* j:=битовая вырезка длиной sz, начиная с 
           битового адреса (adr,i)
        *)
        Push(j);
 |0EDh: (* BBP  Bit Block Pack *)
        j:=Pop(); sz:=Pop();
        IF (sz<1) OR (sz>32) THEN
          Push(sz); DEC(PC); TRAP(4Ah)
        END;
        i:=Pop(); adr:=Pop();
        (* Упаковывает sz младших битов из j по битовому
           адресу (adr,i)
        *)
 |0EEh: (* BBLT Bit BLock Transfer *)
        sz:=Pop(); (* Длина может быть больше 32 *)
        i:=Pop(); adr:=Pop();
        j:=Pop(); adr1:=Pop();
        (* Переслать биты (adr,i) -> (adr1,j) длиной sz *)

 |0F0h: (* SWAP *)
        i:=Pop(); j:=Pop(); Push(i); Push(j)
 |0F1h: (* LPA Load Parameter Address *)
        Push(L-Next()-1);
 |0F2h: (* LPW Load Parameter WORD *)
        Push(Core[L-Next()-1]);
 |0F3h: (* SPW Store Parameter WORD *)
        Core[L-Next()-1]:=Pop();
 |0F4h: (* SSWU Store Stack Word Undistractive *)
        i:=Pop(); Core[Pop()]:=i; Push(i)

 |0FAh: (* ACTIVe process *) Push(P)
 |0FBh: (* USR User defined functions *) i:=Next(); (*  *)
 |0FCh: (* SYS SYStem rarely functions *)
        CASE Next() OF
         |00h: (* PID Processor IDent *)
               (* Push(PID) *)
(* Остальные могут быть различными в разных моделях *)
        ELSE TRAP(7h)
        END;
 |0FDh: (* NII Never Implemented Instruction *) TRAP(7h);
 |0FFh: (* INVLD INVaLiD Operatin *) TRAP(49h)
  ELSE  (* unimplemented instruction *) TRAP(7h)
  END (*CASE*)
END Interpret;

BEGIN (* "Power On" *)
 (* cpu:=Kronos2_2 | Kronos2_5 | Kronos2_6 *)
 ORIGIN(ByteCore,ADR(Core),SIZE(Core));
 ConsolMicroProgram;
 LOOP
   IF Ipt THEN TRAP(IptNo) END;
   IR:=Next();
   Interpret;
 END (*LOOP*)
END Kronos_Interpreter.
