.TAILER .
.HEADER .



                - Сибирское отделение  АН СССР -




                    - Вычислительный центр -




                        - ВНТК "Старт" -








:::::      ::::
:::::      ::::
 :::      :::
 :::     ::
 :::    ::
 ::: : :        ::::::       ::::    :::   :::    :::      :::::
 :::    ::      ::    ::   :::  :::  :::   :::  ::: :::   :::  :::
 :::     :::    ::     :: ::      ::  ::   ::  ::     :: ::
 :::      :::   ::     :: ::      ::  :::::::  ::     :: ::
:::::      :::: :::  :::   :::  :::  :::   :::  ::: :::   :::  :::
:::::      :::: ::::::       ::::    :::   :::    :::      :::::
                ::
                ::
                ::  БИБЛИОТЕКИ  ОС  EXCELSIOR











                         Новосибирск - 88

.PAGE
.TAILER .     <date          >           <#        >                   (c) KRONOS
.HEADER .

























                         Мы    надеемся,    что    информация,
                    изложенная  в  этом томе, является верной.
                    Будем    признательны,    если    читатель
                    критически  подойдет к ней и все возникшие
                    вопросы,    замечания,    исправления    и
                    пожелания   доведет  до  нашего  сведения.
                    Выражаем благодарность всем, кто прямо или
                    косвенно  принимал  участие в подготовке и
                    издании тома.



                    Наш адрес:

                         630090,   Новосибирск-90,    проспект
                    ак. Лаврентьева, 6,  ВЦ СОАН СССР,  к.503,
                    тел. 35-50-67.
                         Для сотрудников ВЦ СOАН тел. 8-97.
.PAGE
                          СОДЕРЖАНИЕ


Введение . . . . . . . . . . . . . . . . . . . . . . . . . . 4
ASCII. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
Args . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
BIO. . . . . . . . . . . . . . . . . . . . . . . . . . . . .11
Clock. . . . . . . . . . . . . . . . . . . . . . . . . . . .17
Code . . . . . . . . . . . . . . . . . . . . . . . . . . . .18
CodeFiles. . . . . . . . . . . . . . . . . . . . . . . . . .20
CONSTS . . . . . . . . . . . . . . . . . . . . . . . . . . .21
Edit . . . . . . . . . . . . . . . . . . . . . . . . . . . .22
Drivers. . . . . . . . . . . . . . . . . . . . . . . . . . .24
FileNames. . . . . . . . . . . . . . . . . . . . . . . . . .28
FileSeek . . . . . . . . . . . . . . . . . . . . . . . . . .30
Heap . . . . . . . . . . . . . . . . . . . . . . . . . . . .31
History. . . . . . . . . . . . . . . . . . . . . . . . . . .33
Image. . . . . . . . . . . . . . . . . . . . . . . . . . . .34
iterDirs . . . . . . . . . . . . . . . . . . . . . . . . . .37
Keyboard . . . . . . . . . . . . . . . . . . . . . . . . . .38
KRONOS . . . . . . . . . . . . . . . . . . . . . . . . . . .40
mCode. . . . . . . . . . . . . . . . . . . . . . . . . . . .42
mCodeMnem. . . . . . . . . . . . . . . . . . . . . . . . . .43
Media. . . . . . . . . . . . . . . . . . . . . . . . . . . .45
Memory . . . . . . . . . . . . . . . . . . . . . . . . . . .48
Misc . . . . . . . . . . . . . . . . . . . . . . . . . . . .49
Pattern. . . . . . . . . . . . . . . . . . . . . . . . . . .51
QuickStreams . . . . . . . . . . . . . . . . . . . . . . . .52
Radix. . . . . . . . . . . . . . . . . . . . . . . . . . . .54
Resource . . . . . . . . . . . . . . . . . . . . . . . . . .55
StdIO. . . . . . . . . . . . . . . . . . . . . . . . . . . .56
Streams. . . . . . . . . . . . . . . . . . . . . . . . . . .63
Strings. . . . . . . . . . . . . . . . . . . . . . . . . . .67
SymFiles . . . . . . . . . . . . . . . . . . . . . . . . . .69
sysDebug . . . . . . . . . . . . . . . . . . . . . . . . . .73
Tape . . . . . . . . . . . . . . . . . . . . . . . . . . . .74
TapeHead . . . . . . . . . . . . . . . . . . . . . . . . . .76
Terminal . . . . . . . . . . . . . . . . . . . . . . . . . .79
Time . . . . . . . . . . . . . . . . . . . . . . . . . . . .85
xRef . . . . . . . . . . . . . . . . . . . . . . . . . . . .87
.PAGE
.HEADER .          БИБЛИОТЕКИ                                            ВВЕДЕНИЕ

                           ВВЕДЕНИЕ

     Одним  из основных принципов, положенных разработчиками в
основу  программного  обеспечения  семейства  КРОНОС, является
принцип  интегрируемости.  Опыт  эксплуатации машин КРОНОС как
автоматизированных   рабочих  мест  программиста  в  различных
коллективах     показал,    что    большинство    создаваемого
программистами  программного  обеспечения  является фактически
набором  библиотек,  реализующих  абстрактные типы данных. Эти
библиотеки   удается   использовать   в   другом   программном
обеспечении,   они  постоянно  пополняют  набор  "строительных
материалов", используемых программистами КРОНОСа для написания
своих программ.
     Выделяются  два  вида  библиотечных  модулей:  уникальные
(unic)  и ресурсные (resource). Различие между ними сводится к
тому,  что  для  уникальных  модулей  в любой момент в системе
имеется одна и только одна копия глобальных переменных модуля,
тогда  как  для  ресурсных  такая  копия делается при загрузке
любой   программы   (модуля),   использующей   данный  модуль.
Следовательно,   для   последних   модулей   набор  глобальных
переменных  является разделенным ресурсом относительно каждого
своего  использования. По умолчанию любая библиотека считается
ресурсной,  объявление  модуля  уникальным достигается вызовом
процедуры Universe.IamUnic при инициализации модуля. В перечне
уникальные библиотеки помечены знаком (U).
     Основным   документом,  определяющим  каждую  библиотеку,
является   ее   определяющий   модуль   (DEFINITION   MODULE),
содержащий  интерфейсы  всех экспортируемых процедур, описания
типов  констант  и  переменных  и  подробные  комментарии  (на
русском языке) об их возможном использовании.
     Данный  том  представляет  собой  справочное  пособие  по
библиотекам   ОС   Excelsior.  Определяющие  модули  библиотек
приведены  в  алфавтном  порядке  и  составляют содержательную
часть тома.
     В  библиотеках  ОС  Excelsior  можно условно выделить три
раздела.

1. Библиотеки, полезные всем пользователям:

Args       - облегчает    обработку   параметров,   переданных
             процессу   при  его  запуске.  Параметр  процесса
             дублируется  в  строке  -Parm-,  после чего с ним
             можно   работать   средствами   модуля   Strings.
             Некоторые   наиболее   распространенные  действия
             вынесены непосредственно в данный модуль.

ASCII      - содержит  мнемоники  некоторых ASCII-символов, их
             семантику, соответствующие контрольные символы.

BIO        - является интерфейсом базовой файловой системы.

Clock (U)  - поставляет  процедуры службы времени на стартовом
             носителе. Здесь всюду INTEGER - время в секундах.

CONSTS     - поставляет    некоторые    полезные    константы,
             описывающие окружение.

Edit       - поставляет   процедуры   редактирования   строки.
             Ввод-вывод  осуществляется через модуль Terminal,
             поэтому все процедуры работают только с экраном!

FileNames  - поставляет процедуры работы с именами файлов.
             Здесь
             FileName = ['/']{ part '/'}part['.'extension'].
             part     = ARRAY OF CHAR.

FileSeek   - поставляет   процедуру,  позволяющую  итерировать
             какое-либо   действие   для   сопоставившихся   с
             образцом файлов.

Heap       - распоряжается  памятью на P-стеке задачи.

Image      - предназначается для работы с числовыми строками.

iterDirs   - позволяет итерировать директорию, сравнивая имена
             на ней с мультиобразцом.

Keyboard(U)- поставляет процедуры работы с клавиатурой.

Media      - является интерфейсом для работы с устройствами.

Misc       - 'Miscellaneos' - разное.

Pattern    - экспортирует  процедуры,  позволяющие  работать с
             образцами.

Resource   - поставляет процедуры работы с ресурсами.

StdIO      - экспортирует  процедуры стандартного ввода-вывода
             в стиле UNIX.

Streams    - позволяет рассматривать файлы как потоки байтов с
             возможным  позиционированием  в  них  и чтением с
             произвольной позиции.

Strings    - поставляет процедуры работы со строками.

Terminal(U)- гарантирует  в  качестве минимальных возможностей
             управления экраном функции, отрабатываемые VT-52.

Time       - осуществляет службу времени в системе.

2.  Библиотеки, являющиеся низкоуровневыми и рекомендуемые для
использования только системным программистам.

Code       - призван  скрыть  от  разработчиков  компиляторов,
             загрузчиков     и    комплексаторов    конкретное
             устройство кодофайла.

KRONOS     - предоставляет  некоторые  аппаратные возможности,
             позволяя     более    эффективно,чем    языковыми
             средствами,  выполнить  определенные  действия. В
             качестве  комментариев предлагается интерпретатор
             m-кода.

mCode      - поставляет   процедуру,   выдающую   5-символьную
             мнемонику команды.

mCodeMnem  - содержит мнемоники команд семейства процессоров.

Memory(U)  - менеджер памяти.

Radix      - поставляет процедуры преобразования  символов  из
             ASCII в Radix и обратно.

sysDebug   - поставляет процедуры визуализации процесса.

Tape       - поставляет процедуры работы с магнитофоном.

TapeHead   - поставляет  процедуры для  упаковки и  распаковки
             ленточных меток.

3.  Библиотеки,  предназначающиеся  для разработчиков систем и
компиляторов    и   не   рекомендуемые   к   использованию   в
пользовательских   программах,   поскольку   не  гарантируется
неизменность их интерфейса.

CodeFiles  - поставляет процедуры работы с кодофайлами.

History    - поставляет  процедуры, позволяющие узнать историю
             выполнения процесса.

QuickStreams  -  для того же, что и Stream, только быстрее.

SymFiles   - осуществляет создание симфайлов и работу с ними.

xRef       - поставляет   процедуры   для   удобства   отладки
             программ.

     Далее переходим к содержательной части тома.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                               ASCII
DEFINITION MODULE ASCII; (* Ned 14-Apr-87. (c) KRONOS *)

(* Модуль  содержит  мнемоники  некоторых  ASCII-символов,  их
   семантику, соответствующие контрольные символы.
*)

CONST

(*  Мнемоника     Семантика      Контрольный Дополнительная *)
(* ASCII-7.68                       символ     мнемоника    *)
(*                                CNTRL+char                *)

  NUL =  0c; (* NUL NUL -- line break    @  *)
  SOH =  1c; (* Начало заголовка         A  *)
  STX =  2c; (* Начало текста            B  *)
  ETX =  3c; (* Конец текста             C  *)  BREAK = ETX;
  EOT =  4c; (* Конец передачи           D  *)
  ENQ =  5c; (* Запрос                   E  *)
  ACK =  6c; (* Подтверждение            F  *)
  BEL =  7c; (* Звонок                   G  *)
   BS = 10c; (* Шаг назад                H  *)
   HT = 11c; (* Горизонтальная табуляция I  *)
   LF = 12c; (* Перевод строки           J  *)
   VT = 13c; (* Вертикальная табуляция   K  *)
   FF = 14c; (* Перевод формата          L  *)
   CR = 15c; (* Возврат каретки          M  *)
   SO = 16c; (* Национальный регистр     N  *)
   SI = 17c; (* Латинский регистр        O  *)

  DLE = 20c; (* Авторегистр 1            P  *)
  DC1 = 21c; (* Управление устройством 1 Q  *)  XON  = DC1;
  DC2 = 22c; (* ---------------------- 2 R  *)
  DC3 = 23c; (* ---------------------- 3 S  *)  XOFF = DC3;
  DC4 = 24c; (* ---------------------- 4 T  *)
  NAK = 25c; (* Отрицание                U  *)
  SYN = 26c; (* Синхронизация            V  *)
  ETB = 27c; (* Конец блока              W  *)
  CAN = 30c; (* Аннулирование            X  *)
   EM = 31c; (* Конец носителя           Y  *)
  SUB = 32c; (* Замена                   Z  *)
  ESC = 33c; (* Авторегистр 2            [  *)
   FS = 34c; (* Разделитель файлов       \  *)
   GS = 35c; (* Разделитель групп        ]  *)
   RS = 36c; (* Разделитель записей      ^  *)
   US = 37c; (* Разделитель элементов    _  *)

SPACE = 40c; (* Пробел                      *)
  DEL =177c; (* Забой!!!                    *)  RUBBOUT = DEL;


CONST  (* Соглашения ОС  Excelsior: *)

  NL = RS;
(* New  Line.  Отрабатывается  как CR LF для телевизоров и для
   других  последовательных  устройств. *) Разделитель строк в
   тестовых файлах.
*)

  EOF = FS;

END ASCII.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                                Args
DEFINITION MODULE Args; (* Leo 19-Dec-85. (c) KRONOS *)

(* Модуль  облегчает обработку параметров, переданных процессу
   при  его  запуске.  Параметр  процесса дублируется в строке
   -Parm-,  после  чего с ним можно работать средствами модуля
   Strings.   Некоторые   наиболее  распространенные  действия
   вынесены непосредственно в данный модуль.
*)

FROM SYSTEM    IMPORT   WORD;

CONST flagprefix='-';
   numflagprefix='=';

TYPE String=ARRAY [0..255] OF CHAR;
     Str256=ARRAY [0..255] OF CHAR;

(* Инициатор  задачи  должен  обеспечивать  поле -ParmLink- не
   менее 256 байт!
*)

PROCEDURE ScanFlags;
(* Ищет среди параметров все последовательности вида:
    -<буква>
    -<буква><буква>...
   Исключает  их  из строки и собирает для последующего опроса
   процедурой  флаг.  Знак  '-'  является  значением константы
   flagprefix  и  может  быть изменен при конкретной настройке
   модуля.
*)

PROCEDURE Flag?(Ch: CHAR): BOOLEAN;
(* Опрашивает  наличие  в  командной  строке указанного флага.
   Перед   этой   операцией  должна  быть  применена  операция
   ScanFlags.   Например,   при  запуске  программы  MyProg  с
   параметром:
     MyProg -abc -l
   программа MyProg может иметь такой вид:
   MODULE MyProg;
   FROM Args   IMPORT ScanFlags,Flag?;
   ....
   BEGIN ScanFlags;
     IF Flag?('a') OR Flag?('c') & NOT Flag?('l') THEN ... END
     ...
     IF Flag?('a') &  Flag?('b') THEN ... END
   END MyProg.
*)

PROCEDURE TakeWord(VAR w: ARRAY OF CHAR);
(* Эквивалентна: GetWord(Parm,w), см. Strings *)

PROCEDURE TakeHex(VAR w: ARRAY OF CHAR; VAR N: WORD): BOOLEAN;
(* Берет  из  строки  w  шестнадцатeричное число и кладет в N;
   выдает TRUE в случае неудачи.
*)

PROCEDURE TakeNum(VAR w: ARRAY OF CHAR;
                  VAR N: INTEGER): BOOLEAN;
(* Берет   из  строки  w  десятичное  (если  не  получилось  -
   шестнадцатеричное) число и кладет в N; выдает TRUE в случае
   неудачи.
*)

PROCEDURE Num?(VAR N: INTEGER): BOOLEAN;
(* Выясняет,  является  ли  первое  слово  в строке параметров
   числом,  если  да,  то  вычеркивает его с помощью TakeWord,
   выдает  FALSE,  если  нет,  то  результат  интерпретируется
   следующим образом:
   1     это не число              (word not taken)
   2     переполнение              (word not taken)
   3     неправильный символ       (word not taken).
*)

PROCEDURE NumFlag?(Ch: CHAR; VAR N: INTEGER): BOOLEAN;
(* Ищет  в  строке  параметров последовательность Ch= <число>,
   кладет в N; в случае удачи выдает FALSE.
*)

PROCEDURE ArgC(): CARDINAL;
(* Подсчитывает число слов в строке -Parm- *)

PROCEDURE LastWord(VAR w: ARRAY OF CHAR);
(* Забирает последнее слово из -Parm- *)

PROCEDURE TakeParm(VAR Prm: ARRAY OF CHAR);
(* Берет всю строку -Parm- *)

END Args.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                                 BIO
DEFINITION MODULE BIO; (* Leo 06-Jan-86. (c) KRONOS *)
                       (* Ned 13-Apr-87. (c) KRONOS *)

(* Модуль является интерфейсом базовой файловой системы.
*)

(* Основными понятиями файловой системы являются:
   ФАЙЛ       -- (file)     последовательность    блоков    на
                 поименованном внешнем НОСИТЕЛЕ.
   НОСИТЕЛЬ   -- (volume)  единица совместного хранения файлов
                 (обычно    диск    или    дисковый    пакет),
                 устанавливаемая     на    любой    подходящий
                 НАКОПИТЕЛЬ.
   УСТРОЙСТВО -- (driver)     физическое     устройство    для
                 обслуживания  некоторого множества однотипных
                 НАКОПИТЕЛЕЙ.                   Представляется
                 стандартизированным   набором  операций  (см.
                 станадрт      на     написание     драйверов)
                 Идентифицируется   уникальным  двухсимвольным
                 именем, например: "dp","dx","mt" и т.п.
   НАКОПИТЕЛЬ -- (unit)  позиция  для  установки произвольного
                 НОСИТЕЛЯ  подходящего  типа. Идентифицируется
                 указанием  УСТРОЙСТВА и номера обслуживаемого
                 накопителя,   например:  "dx0","dp2","mt7"  и
                 т.п.
   ДИРЕКТОРИЯ -- (directory) специальный вид файла. Директория
                 содержит имена других файлов и указание на их
                 местоположение  в  файловой системе. При этом
                 говорят,  что данные файлы "ПРИВЯЗАНЫ" к этой
                 директории,  хотя  физически  они  могут быть
                 размещены на любом из имеющихся НОСИТЕЛЕЙ.

   Все  операции  файловой  системы  возвращают FALSE в случае
   удачного  завершения  операции,  иначе возвращают ненулевой
   результат,   который   может  быть  проинтерпретирован  как
   значение    TRUE.   За   более   подробной   интерпретацией
   результатов обращайтесь к модулю Files.
*)

IMPORT Files;
FROM SYSTEM    IMPORT    WORD, ADDRESS;
FROM FsPublic  IMPORT    File, dNode, FileName, VolumeName;


PROCEDURE check(r: BOOLEAN; s: ARRAY OF CHAR): BOOLEAN;
(* IF r#ok THEN Show(s,VisFSerr(r)) END; RETURN r *)
(* Если  r#FALSE,  то  выдает  сообщение об ошибке; возвращает
   -r-.
*)
PROCEDURE checkHALT(r: BOOLEAN; s: ARRAY OF CHAR);
(* IF check(r) THEN HALT END; *)

PROCEDURE CD(): File;
(* Выдает текущую директорию *)

PROCEDURE ChangeCD(directory: File): BOOLEAN;
(* Меняет текущую директорию на -directory- *)

(*
   Следующие  операции  предназначены  для  открытия  файлов и
   директорий по их полному имени.
   Имя может задаваться от корня файловой системы, например:

     /MyVolume/RootDirectory/MyDirectory/MyFile,

   где  первое  имя  интерпретируется  как  имя  носителя,  на
   котором  осуществляется дальнейшее ползание, или от текущей
   директории:

     SubDirectory/Documentation/Chapter1.

   В   случае  необходимости  текущая  директория  может  быть
   поименована  явно  именем  '.'.  Так, например, приведенный
   выше путь можно переписать так:

     ./SubDirectory/Documentation/Chapter1
*)

TYPE ErrProc=PROCEDURE(ARRAY OF CHAR);

PROCEDURE dummyErr(s: ARRAY OF CHAR);
(* Оставляет сообщение об ошибке без ответа *)

PROCEDURE ShowHALT(s: ARRAY OF CHAR);
(* Показывает сообщение об ошибке и производит останов *)

PROCEDURE GoPath(start:File; VAR dir:File;
                 VAR S: ARRAY OF CHAR; Err: ErrProc);
(* Проходит  путь  к  указанному  в  -S- полному имени файла и
   открывает   директорию   -dir-,   на  которой  данный  файл
   находится.  В  строке  S  остается  слово  после последнего
   символа  '/'.  В  случае неудачи вызывает процедуру -Err- с
   соответствующим  сообщением об ошибке в качестве параметра.
   Например:
     S:="SubDir/Book/Chapter1";
     GoPath(Cd,DirTo,S,er)
   -  при условии существования указанных директорий открывает
   директорию DirTo = "SubDir/Book"
   В  строке  -S-  остается чистое имя файла "Chapter1", после
   чего файл можно открыть операцией Open.
*)

PROCEDURE Go(start: File; VAR dir: File;
             VAR S: ARRAY OF CHAR; Err: ErrProc): BOOLEAN;
(* Полностью  аналогична  GoPath,  но дополнительно возвращает
   причину  неудачи  в  случае  ошибки. Возвращает FALSE, если
   действие выполнилось корректно.
*)

PROCEDURE OpenRelative(dr: File; VAR f: File;
                  name: ARRAY OF CHAR; Err: ErrProc): BOOLEAN;
(* Открывает  файл  по  полному  имени относительно директории
   -dr-. Эквивалентно:
   RETURN GoPath(dr,DestDir,S,Err) OR Open(DestDir,f,S);
*)

PROCEDURE Open(VAR f: File; name: ARRAY OF CHAR;
                 Err: ErrProc): BOOLEAN;
(* Открывает файл по полному имени. *)

PROCEDURE LookUpFile(VAR f: File; S : ARRAY OF CHAR;
                     Err: ErrProc): BOOLEAN;
(* Пытается  открыть файл на всех директориях, заданных в пути
   path Shell'а.
*)

PROCEDURE Create(VAR f: File): BOOLEAN;
(* Создает   файл   на   том  носителе,  где  открыта  текущая
   директория.   Созданный   файл   не  привязан  ни  к  какой
   директории  и по закрытии будет уничтожен, если до этого не
   произойдет явного привязывания его операцией -Link-.
*)

PROCEDURE Close(VAR f: File): BOOLEAN;
(* Закрывает  файл, делая невозможным дальнейшую работу с ним.
   Все   незакрытые   файлы   автоматически   закрываются  при
   завершении работы программы.
*)

PROCEDURE bRead(f: File; blockno: CARDINAL;
                Buf: ADDRESS; sz: CARDINAL): BOOLEAN;
(* Читает  из  файла  -f-  указанное  количество  байтов -sz-,
   начиная  с  начала  указанного  блока  -blockno-  в память,
   начиная  с  адреса -Buf-. Количество физически передаваемых
   при  чтении байтов может округлятся по модулю 4 с избытком.
   Размер блока равен 4096 байтов.
*)

PROCEDURE bWrite(f: File; blockno: CARDINAL;
                    Buf: ADDRESS; sz: CARDINAL): BOOLEAN;
(* Пишет  в  файл  -f- РОВНО указанное количество байтов -sz-,
   начиная с начала указанного блока -blockno- с адреса -Buf-.
   Если  sz  не  кратно  размеру блока, информация, оставшаяся
   недописанной, не изменяется.
*)

PROCEDURE Read(f: File; blockno: CARDINAL; Buf: ADDRESS;
              sz: CARDINAL);
(* Эквивалентно:
   checkHALT(bRead(f,blockno,Buf,sz).
*)

PROCEDURE Write(f: File; blockno: CARDINAL; Buf: ADDRESS;
               sz: CARDINAL);
(* Эквивалентно:
   checkHALT(bWrite(f,blockno,Buf,sz).
*)

PROCEDURE CreateDir(dir: File; Nm: FileName): BOOLEAN;
(* Создает  на  директории  -dir- директорию с именем -Nm-. На
   созданной  директории имя ".." привязывается к -dir- (* Ned
   13-Apr-87:   *),   причем   число   линков   у   -dir-   не
   увеличивается,   что   гарантирует  невозможность  отвязать
   поддерево.
*)

PROCEDURE Link(dir: File; Nm: FileName; ToFile: File): BOOLEAN;
(* Привязывает  файл  -ToFile-  к  директории -dir- под именем
   -Nm-.  Если в момент привязывания к директории уже привязан
   файл с таким именем, он отвязывается.
*)

PROCEDURE UnLink(dir: File; Nm: FileName): BOOLEAN;
(* Отвязывает  файл  от  директории.  Если  после  этого  файл
   становится   непривязанным   ни   к  одной  директории,  он
   физически уничтожается и занимаемые им ресурсы возвращаются
   системе.
*)

TYPE IterProc=PROCEDURE (dNode);
                                                           (*
PROCEDURE Ls(dir: File; IP: IterProc;
             Write?: BOOLEAN): BOOLEAN;
                                                            *)
CONST     Ls=Files.LsDir;
(* Итерирует  имена  на  директории -dir-, вызывая для каждого
   имени из директории процедуру -IP- с параметрами: имя файла
   и  имя  носителя.  Процедура  -IPможет  с  помощью операции
   -OpenU- произвести открытие файла и его обработку.
*)

PROCEDURE Flush(F: File): BOOLEAN;
(* Эквивалентна:  ReOpenU  CloseU.  Используется для занесения
   информации о файле на диск (Eof,Links и т.п.). Необходима в
   случае,  если  в  контексте  вызова  уже неизвестно, откуда
   получен  данный  файл  для  обеспечения надежности хранения
   файлов на внешних носителях.
*)

PROCEDURE GetRoot(VAR F: File; VolumeName:VolumeName):BOOLEAN;
(* Выдает корневую директорию на указанном носителе *)

PROCEDURE Opened?(f: File): BOOLEAN;
(* Выдает TRUE, если файл открыт. *)

PROCEDURE IsDir?(f: File): BOOLEAN;
(* Выдает TRUE, если файл является директорией. *)

PROCEDURE GetEof(f: File): CARDINAL;
(* Выдает размер файла. Если не открыт, то 0. *)

PROCEDURE SetEof(f: File; Eof: CARDINAL);
(* Устанавливает  размер файла. Значение размера на диске (как
   и  других  атрибутов)  изменится  только  после  выполнения
   операций  -FlushU- или -CloseU-. Тем не менее все процессы,
   использующие  данный  файл,  заметят  изменения немедленно,
   т.к.  все используют единственную копию дескриптора файла в
   памяти.
*)

PROCEDURE Driver(f: File; VAR drv: INTEGER): BOOLEAN;
(* Выдает номер накопителя, на котором открыт данный файл. *)

PROCEDURE ReOpen(f: File): BOOLEAN;
(* Еще  раз открывает файл. Теперь счетчик открытий у файла на
   единичку больше, что позволяет, например, использовать файл
   в  двух параллельных процессах, не заботясь о том, какой из
   них раньше его закроет.
*)

PROCEDURE OpenOnDir(dir: File; VAR f: File;
                    Nm: FileName): BOOLEAN;
(* Открывает файл по данному имени на данной директории.*)

PROCEDURE dOpen(VAR d: dNode; VAR f: File): BOOLEAN;
(* Открывает файл по dNode'у *)

PROCEDURE CreateOnVolume(VAR f: File;
                         DevName: VolumeName): BOOLEAN;
(* Создает  файл  на  указанном носителе. Носитель должен быть
   смонтирован  в  момент создания файла и в процессе работы с
   ним.  Созданный файл не привязан ни к какой директории и по
   закрытии  будет  уничтожен,  если  до  этого  не произойдет
   явного привязывания его операцией -LinkU-.
*)

PROCEDURE CloseAll(xx: INTEGER);
(* Закрыть все файлы, открытые данным процессом. *)

PROCEDURE AppPath(dir: File): BOOLEAN;
(* Добавляет еще один путь к уже существующим *)

PROCEDURE ClearPaths(): BOOLEAN;
(* Отвязывает все установленные пути *)

PROCEDURE CreateOn(VAR f: File; dir: File): BOOLEAN;
(* Создает  файл  на  том  же  носителе, где лежит директория.
   Созданный  файл  не  привязан  ни  к  какой директории и по
   закрытии  будет  уничтожен,  если  до  этого  не произойдет
   явного привязывания его операцией -LinkU-.
*)

PROCEDURE Extend(f: File; eof: INTEGER): BOOLEAN;
(* Расширяет файл до размера -eof- байтов и выставляет -eof-.
*)

PROCEDURE Cut(f: File): BOOLEAN;
(* Обрезает файл, удаляя все блоки за -eof-'ом *)

END BIO.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                               Clock
DEFINITION MODULE Clock; (* Leo 2-Nov-86. (c) KRONOS *)

(* Модуль    поставляет    процедуры    службы    времени   на
   системном носителе. Здесь всюду INTEGER - время в секундах.
*)

PROCEDURE SystemClock(): INTEGER;
(* Каждые  десять  минут  пытается  записать системное время в
   файл; если за эти десять минут не вводилось новое время, то
   десять минут прибавляются к ранее записанному времени.
*)

PROCEDURE SetTime(time: INTEGER);
(* Ввод в систему времени -time- *)

PROCEDURE TryRead(): INTEGER;
(* Пытается  прочитать  последнюю отметку времени с системного
   носителя.
*)

PROCEDURE TryWrite(t: INTEGER);
(* Пытается записать время -t- на системный носитель *)

PROCEDURE miliClock(): INTEGER;
(* Возвращает время  в  милисекундах с последней перезагрузки.
   Сбрасывается  в  0  примерно  каждые  580 часов непрерывной
   работы.
*)

END Clock.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                                Code
DEFINITION MODULE Code; (* Leo & Ned  15-Nov-85 *)

FROM SYSTEM    IMPORT   ADDRESS, WORD;

CONST NoCatrs=16; CurrentVersion = 100h;

   (*  Модуль  призван  скрыть  от разработчиков компиляторов,
   загрузчиков    и   комплексаторов   конкретное   устройство
   кодофайла.
   В  его  терминах кодофайл - это непрерывная область памяти,
   указатель  на  которую  и  является  значением типа "Code".
   Чтение  и запись этой области памяти на внешние носители не
   входит  в  задачи  этого  модуля  и  обеспечивается внешним
   образом.
   В   начале   кодофайла   располагается   область  атрибутов
   кодофайла  размером  -noCatrs- слов. Расположение остальных
   областей  кодофайла  не  фиксируется и может быть различным
   для разных компиляторов. Рекомендуемый порядок:
   <атрибуты>
            <строковый пул>
                          <код>
                              <внешние связи>
                                             <...остальное...>
   Первой строкой в <строковом пуле> ДОЛЖНО лежать имя модуля,
   завершенное  хотя  бы  одним байтом со значением 00. Версия
   кодофайла   имеет  внутрисистемное  значение  и  изменяется
   только  в  случае  существенных  изменений  в модуле Code с
   целью  проконтролировать  перекомпиляцию  всех  кодофайлов.
   (Загрузчик  отказывается  грузить  кодофайлы  с  устаревшей
   версией).    Версия    изменяется    с   оповещением   всех
   разработчиков зависящих от структруры кодофайла SoftWare.
   Текущая  версия  существенно не изменялась с 15 ноября 1985
   года.
*)


TYPE CodeAtr = (
     (*0      1       2      3       4        5       6   *)
       Vers,  DefT,   ImpT,  StrSz,  CodeSz,  Stk0,   StkSz
     (*7      8       9      0A      0B       0C          *)
      ,GloSz, NoExt,  NoPrc, SymOfs, XrefOfs, Kind
     (*0D        0E       0F    *)
      ,StrAdr,   CodeAdr, ExtAdr  (* for Read only *)
);

PROCEDURE GetCatr(Code: ADDRESS; Atr: CodeAtr): WORD;
(* Выдает   значение   соответствующего   атрибута  кодофайла.
   Используется компиляторами и загрузчиком.
*)

PROCEDURE SetCatr(Code: ADDRESS; Atr: CodeAtr; Val: WORD);
(* Устанавливает значение соответствующего атрибута кодофайла.
   Используется компиляторами.
*)

PROCEDURE GetCode(Entry: ADDRESS): ADDRESS;
(* По   адресу  входа  глобальной  области  модуля  в  таблицу
   глобальных   областей   выдает  указатель  на  его  кодовый
   сегмент. Используется загрузчиком.
*)

PROCEDURE MustBeInit(Entry: ADDRESS): BOOLEAN;
(* Требование    на   инициализацию   данного   модуля   перед
   выполнением    головного   модуля   программы.   Если   оно
   выставлено, загрузчик обеспечивает такую инициализацию.
*)

PROCEDURE ModuleName(Entry: ADDRESS): ADDRESS;
(* По  адресу  входа  выдает  имя модуля. Используется модулем
   LIB_HIS,  процедурой  History и модулем LIB_TWI, процедурой
   MyHost.
*)

PROCEDURE Default(Code: ADDRESS);
(* Выставляет   значения   всех   атрибутов,   по   умолчанию.
   Используется   компиляторами   для   инициализации  области
   атрибутов кодофайла.
*)

PROCEDURE Kind?(C: ADDRESS; VAR S: ARRAY OF CHAR);
(* Выдает значение атрибута Kind *)

PROCEDURE SetKind(C: ADDRESS; VAR S: ARRAY OF CHAR);
(* Устанавливает значение атрибута Kind *)

END Code.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                           CodeFiles
DEFINITION MODULE CodeFiles; (* Ned 22-Dec-86. (c) KRONOS *)

(* Модуль поставляет процедуры работы с кодофайлами.
*)

FROM SYSTEM    IMPORT   WORD;

TYPE
  Attrs = RECORD (* Все размеры в СЛОВАХ *)
                     CPU: INTEGER;
                Language: ARRAY [0..31] OF CHAR;
                 DefTime: INTEGER;
             (* Для программных модулей совпадает с ImpTime *)
                 ImpTime: INTEGER;
                  ProcCo: CARDINAL;
                  ExtsCo: CARDINAL; (* = размер LDFT *)
                CodeSize: CARDINAL;
            ConstsSize: CARDINAL; (* размер строкового пула *)
             GlobalsSize: CARDINAL; (* без размера LDFT *)
            MinProcStack: CARDINAL;
            OptimalStack: CARDINAL;
          END;


PROCEDURE CreateCode(modname: ARRAY OF CHAR; error: PROC);
(* Создает кодофайл *)

PROCEDURE WriteInfo(VAR a: Attrs);
(* Записывает атрибуты в кодофайл *)

PROCEDURE WriteExt(no: CARDINAL; nm: ARRAY OF CHAR);
(* Записывает имя внешнего модуля с номером -no- *)

PROCEDURE WriteProcTable(VAR a: Attrs;
                         VAR pTab: ARRAY OF CARDINAL);
(* Записывает процедурную таблицу *)

PROCEDURE WriteConsts(a: Attrs; VAR consts: ARRAY OF WORD);
(* Записывает строковый пул *)

PROCEDURE WriteCode(VAR a: Attrs; VAR Code: ARRAY OF WORD);
(* Записывает код в кодофайл *)

PROCEDURE CloseCode;
(* Закрывает кодофайл *)

END CodeFiles.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                              CONSTS
DEFINITION MODULE CONSTS; (* Leo  05-Nov-1986. (c) KRONOS *)

(* Модуль поставляет некоторые полезные константы, описывающие
   окружение.
*)

CONST
  MaxInt=7FFFFFFFh;     (* TYPE INTEGER=[-2**31-1..2**31-1] *)
  MinInt=80000000h;     (* TYPE INTEGER=[MinInt  ..MaxInt ] *)

  BitsPerByte = 8;                        (* битов в байте  *)
  BytesPerWord= 4;                        (* байтов в слове *)
  BitsPerWord = BitsPerByte*BytesPerWord; (* битов в слове  *)
  AdrsPerWord = 1;                        (* адресов в слове*)

  LowAddress  = 00000h;
  (* наименьший адрес памяти, доступной KRONOS-P2.0*)
  HighAddress =0FFFFFh;
  (* наибольший адрес памяти, доступной KRONOS-P2.0*)

  MaxReal=REAL(7FFFFFFFh);  (* TYPE REAL=[-MaxReal..MaxReal] *)
  Delta  =REAL(00800000h);  (* Delta / 2.0 = 0.0             *)
                            (* 0.0 = REAL(00000000h)         *)
(* Примечание.
   По определению, Delta = sup {x>0 : x/2 = 0}. Но тогда Delta
   -     наименьшее    положительное    вещественное    число.
   Действительно, если существует Х >0 такое, что
       Delta > X > 0, то
       либо X*2 < Delta, либо (Delta-X)*2 < Delta,
   что противоречит определению.
*)

END CONSTS.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                                Edit
DEFINITION MODULE Edit; (* 11-Mar-87. (c) KRONOS *)

(* Модуль    поставляет   процедуры   редактирования   строки.
   Ввод/вывод  осуществляются  через  модуль Terminal, поэтому
   все процедуры работают только с экраном!
*)

PROCEDURE ReadString(Ask: ARRAY OF CHAR; VAR s: ARRAY OF CHAR);
(* Выдает  на  экран  приглашение -Ask- и считывает с экрана в
   строку -s-.
*)

PROCEDURE Confirm   (Ask: ARRAY OF CHAR; VAR s: ARRAY OF CHAR);
(* То  же, что и ReadString, но выдает после введения с экрана
   содержимое строки -s- для подтверждения.
*)

TYPE Action=(term,validch,validkey,invalid,bell);
     How=(dummy,old,show,confirm);
     ValidProc=PROCEDURE (VAR CHAR, INTEGER,
                          VAR ARRAY OF CHAR): Action;
     (*        PROCEDURE (VAR pushbutton,pos_in_string,
                          string): Action  *)

PROCEDURE ReadValid(VAR s: ARRAY OF CHAR; valid: ValidProc;
                    how: How);
(*  -valid- должен возвращать:
     term      для прекращения чтения;
     validch   для допустимого символа (ReadValid кладет его в
               -s-);
     validkey  для   допустимого   ключа  (ReadValid  пытается
               интерпретировать    его    как    редактирующее
               действие;
     invalid   для  недопустимого символа или ключа (ReadValid
               игнорирует его);
     bell      для  недопустимого символа или ключа (ReadValid
               игнорирует его и возбуждает звуковой сигнал).
   -valid- может изменять содержимое переменной -pushbutton- -
   первого   параметра   этой   процедуры,   как   это  делает
   стандартная процедура -valid- , которая читает следующий за
   ^T (DC4) байт и вставляет его в строку.

   pos_in_string  может  использоваться для отсекания строки с
   той позиции, где стоял курсор.
   ReadValid   возвращает   всю  строку,  включая  завершающие
   пробелы.
   Семантика констант типа How:
   dummy не показывает содержимое строки;
   show показывает содержимое строки и устанавливает курсор на
   ее начало;
   confirm показывает содержимое строки и устанавливает курсор
   на ее конец.
*)

PROCEDURE StandardValid(VAR pb: CHAR; ps: INTEGER;
                        VAR s: ARRAY OF CHAR): Action;

TYPE readproc=PROCEDURE(): CHAR;

PROCEDURE SetRead(Read: readproc);

END Edit.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                             Drivers
DEFINITION MODULE Drivers; (* Ned 06-Mar-88. (c) KRONOS *)

(* Определяет спецфункции драйверов *)

-------------------------------------------------------------
-- Для каждой спецфункции указывается трактовка параматра  --
-- info при вызове DoCFE. Запись info: DUMMY означает,     --
-- что в данной спецфункции этот параметр не используется. --
-- При заведении новых функций смотрите и модифицируйте    --
-- таблицу в конце модуля.                                 --
-------------------------------------------------------------

FROM SYSTEM     IMPORT  ADDRESS;

CONST userdefined = 80h; -- функции с номерами > userdefined
                         -- могут использоваться в каждом
                         --драйвере по разному.

-------------------------------------------------------------

TYPE
  MEMORY   = RECORD adr: ADDRESS; size: INTEGER END;
  STRING   = ARRAY [0..255] OF CHAR;

CONST -- функции для всех типов драйверов
  poweroff = 2; -- выключение питания
                -- для блочных - убрать головы
                -- номер устройства игнорируется
                -- info: DUMMY

  initdrv  = 4; -- инициализация драйвера
                -- номер устройства игнорируется
                -- info: DUMMY

  killdrv  =10; -- конец работы драйвера
                -- номер устройства игнорируется
                -- info: DUMMY

  memory?  =11; -- выдает память занимаемую драйвером.
                -- номер устройства игнорируется
                -- info: POINTER TO MEMORY;

  notries  = 3; -- установка числа попыток при ошибке
                -- используется для драйверов блочных
                -- и специальных устройств
                -- info: POINTER TO INTEGER

-------------------------------------------------------------

CONST -- функции для блочных драйверов
  noblocks = 0; -- размер носителя в блоках [0..noblocks-1]
                -- только для блочных драйверов
                -- info: POINTER TO INTEGER

  minblock = 1; -- номер первого блока носителя
                -- если функция не реализована, то
                -- считается, что minblock=0
                -- info: POINTER TO INTEGER

  formating= 5; -- форматирование блока носителя
                -- info: POINTER TO INTEGER

  errors?  = 6; -- сообщение об ошибках
                -- info: ?

  buffers? =22; -- узнать число используемых буферов
                -- info: POINTER TO INTEGER

  buffers  =20; -- установить число используемых буферов
                -- info: POINTER TO INTEGER

  flushbufs=25; -- сбросить еще не записанные буфера на диск
                -- info: DUMMY

-------------------------------------------------------------

TYPE
  ldREPORT = RECORD
                 -- сообщение о состоянии логического носителя
               blocks: INTEGER;
               read? : BOOLEAN;           -- разрешение чтения
               write?: BOOLEAN;           -- разрешение записи
               pname : POINTER TO STRING; -- указатель на имя
             END;

CONST -- функции для блочных драйверов логических устройств
  ldtie    =24; -- привязать к устройству логический носитель,
                -- заданный именем файла, именем в сети и т.д.
                -- info: POINTER TO STRING

  lduntie  =23; -- отвязать логический носитель от устройства
                -- info: DUMMY

  ldreport =21; -- возвращает имя привязанного к устройству
                -- логического носителя, его размер
                -- и разрешение чтения/записи
                -- info: POINTER TO ldREPORT

-------------------------------------------------------------

TYPE
  SPEC  = RECORD -- спецификация диска
            tracks  : INTEGER; -- for one head
            heads   : INTEGER; -- sides for FD
            secsize : INTEGER;
            minsec  : INTEGER;
            maxsec  : INTEGER;
            minblock: INTEGER;
            maxblock: INTEGER;
          END;

CONST -- функции для многоцелевых блочных драйверов
  getspec  =30; -- вернуть спецификацию диска
                -- info: POINTER TO SPEC

  readspec =31; -- прочитать спецификацию с диска.
                -- для контроллеров умеющих опознавать диски
                -- info: POINTER TO SPEC

  setspec  =32; -- изменить спецификацию диска
                -- поля, изменять которые не надо, должны быть
                -- меньше 0, кроме minblock.
                -- info: POINTER TO SPEC

  changespec=33;-- сменить спецификацию диска,
                -- если диск вынимали
                -- info: DUMMY

-------------------------------------------------------------

TYPE
  PLACE = RECORD -- задание сектора
            head,track,sector,size: INTEGER;
            buf: ADDRESS;
          END;

CONST -- низко-уровневый ввод/вывод для дисковых драйверов
  readdisk =34; -- прочитать с диска информацию
                -- info: POINTER TO PLACE

  writedisk=35; -- прочитать с диска информацию
                -- info: POINTER TO PLACE

-------------------------------------------------------------

CONST -- функции для драйверов последовательных устройств
  readchar = 8; -- чтение символа
                -- info: POINTER TO CHAR

  writechar= 9; -- запись символа
                -- info: POINTER TO CHAR

-------------------------------------------------------------

CONST -- функции для терминальных драйверов
  waitpress=19; -- ожидание появления символа в буфере ввода
                -- info: DUMMY

  inclmode =21; -- включение моды  (см. os/TTYs)
                -- info: POINTER TO INTEGER;

  exclmode =22; -- выключение моды (см. os/TTYs)
                -- info: POINTER TO INTEGER;

  chars?   =23; -- число символов в буфере ввода
                -- info: POINTER TO INTEGER;

  abort?   =24; -- возвращает сигнал абортирования
                -- info: POINTER TO Scheduler.Signal

  setabort =25; -- устанавливает сигнал абортирования
                -- info: POINTER TO Scheduler.Signal

  termtype?=26; -- возвращает тип терминала
                -- info: POINTER TO INTEGER

  settype  =27; -- устанавливает тип терминала
                -- info: POINTER TO INTEGER

  peekchar =28; -- возвращает i-символ в буфере ввода
                -- in : info: POINTER TO INTEGER
                -- out: info: POINTER TO CHAR

-------------------------------------------------------------

PROCEDURE driverparms(VAR m: MEMORY): ADDRESS;
(* Запоминает память, которую занимает драйвер.
   Возвращает адрес блока параметров.
*)

END Drivers.

               00, 01, 02, 03, 04, 05, 06, 07, 08, 09
               --------------------------------------
общие функции:          2,  3,  4,
               10, 11

дисковые     :  0,  1,              5,  6,

               20, 21, 22, 23, 24, 25
               30, 31, 32, 33, 34, 35

серийные     :                                  8,  9,
                                                   19,
                   21, 22, 23, 24, 25, 26, 27, 28
               --------------------------------------
               00, 01, 02, 03, 04, 05, 06, 07, 08, 09
.PAGE
.HEADER .          БИБЛИОТЕКИ                                           FileNames
DEFINITION MODULE FileNames; (* Ned 05-Jan-87. (c) KRONOS *)

(* Модуль поставляет процедуры работы с именами файлов.
   Здесь
   FileName = ['/'] { part '/' } part [ '.' extension ' ].
   part     = ARRAY OF CHAR.
*)

CONST
  separator = '/';
  extchar   = '.';

CONST
  codext = 'cod'; (* расширение для CodeFiles *)
  symext = 'sym'; (* расширение для SymFiles  *)
  refext = 'sym'; (* расширение для RefFiles  *)

VAR error: PROCEDURE (ARRAY OF CHAR);
(* Вызывается в случае возникновения ошибки *)

PROCEDURE FileName?(fn: ARRAY OF CHAR): BOOLEAN;
(* Все ли символы в имени файла допустимые? *)

PROCEDURE GetExt(VAR fn,ext: ARRAY OF CHAR);
(* Удаляет расширение и выдает его в -ext- *)

PROCEDURE DelExt(VAR fn: ARRAY OF CHAR);
(* Удаляет расширение *)

PROCEDURE AppExt(VAR fn: ARRAY OF CHAR; ext: ARRAY OF CHAR);
(* Добавляет расширение к имени файла *)

PROCEDURE AppExt?(VAR fn: ARRAY OF CHAR; ext: ARRAY OF CHAR);
(* Добавляет   расширение   -ext-,   если  до  этого  не  было
   расширения.
*)

PROCEDURE ChangeExt(VAR fn: ARRAY OF CHAR; ext:ARRAY OF CHAR);
(* Изменяет  расширение  либо добавляет расширение -ext-, если
   до этого расширения не было.
*)

PROCEDURE FirstPart(VAR fn,first: ARRAY OF CHAR);
(* first:=  первая  часть  имени файла (части разделяются '/',
   см.выше);
   fn := оставшаяся часть.
*)

PROCEDURE LastPart(VAR fn,last: ARRAY OF CHAR);
(* first:= последняя часть имени файла (части разделяются '/',
   см.выше);
   fn   := оставшаяся часть.
*)

PROCEDURE DummyError(s: ARRAY OF CHAR);
(* Пустая реакция на неправильное имя файла *)

END FileNames.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                            FileSeek
DEFINITION MODULE FileSeek;  (* Leo   17-Feb-87. (c) KRONOS *)

(* Модуль   поставляет   процедуру,   позволяющую  итерировать
   какое-либо действие для сопоставившихся с образцом файлов.
*)

(* ВНИМАНИЕ!
   Не  следует использовать процедуры из FileSeek в нескольких
   параллельных процессах в пределах одной задачи!
*)

FROM FsPublic  IMPORT   File, dNode;

TYPE

   DirProc  = PROCEDURE (File,dNode,CARDINAL,ARRAY OF CHAR,
                         INTEGER);
   FileProc = PROCEDURE (File,dNode,CARDINAL,ARRAY OF CHAR);
   ErrProc  = PROCEDURE (ARRAY OF CHAR);

CONST StndErr=ErrProc(NIL);

PROCEDURE Seek(SUPERpattern: ARRAY OF CHAR; OneDir: DirProc;
               OneFile: FileProc; err: ErrProc);
(* Прослеживает все файлы, полное имя которых сопоставляется с
   образцом.  OneDir  вызывается  два раза при итерации каждой
   директории:  первый  раз  в  начале  итерации  директории с
   параметром  -NoFiles-  <  0,  второй раз в конце итерации с
   параметром  -NoFiles-,  равным числу совпавших файлов. Файл
   выдается в открытом состоянии, Seek автоматически закрывает
   файл. ErrProc вызывается в случае возникновения ошибки.
*)

END FileSeek.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                                Heap
DEFINITION MODULE Heap; (* Leo 25-Sep-86. (c) KRONOS *)
                        (* Leo 19-Aug-87. (c) KRONOS *)
(* Модуль распоряжается памятью на P-стеке задачи.
*)
(* 19-Aug-87 Debug mode DISCARDED!!!

   ВНИМАНИЕ!  Если  задача  состоит  из  нескольких процессов,
   память   распределяется   на  П-стеке  КОРНЕВОГО  процесса,
   независимо от того, из какого процесса произошло обращение.
*)

FROM SYSTEM    IMPORT ADDRESS;

(* DEALLOCATE   должна  освобождать  весь  кусок,  размещенный
   единственным   вызовом   ALLOCATE  с  тем  же  размером.  В
   противном   случае   картинка  памяти  будет  неправильной.
   Внимание!  Запрос  на  одно  слово  процедурами  ALLOCATE и
   DEALLOCATE обрабатывается как запрос на два слова
*)

PROCEDURE   ALLOCATE(VAR a: ADDRESS; words: CARDINAL);
(* Отводит кусок памяти размером -words- и адрес первого слова
   пишет в -a-.
*)

PROCEDURE DEALLOCATE(VAR a: ADDRESS; words: CARDINAL);
(* Освобождает память, начиная с адреса -a-, размером -words-;
   в -a- возвращает NIL.
*)

PROCEDURE MinPstack(szW: INTEGER);
(* Минимум между -S- и -H- - регистрами. По умолчанию 2KW *)

PROCEDURE Free(): INTEGER;
(* Возвращает  суммарный  размер  свободных  кусков  памяти  в
   словах.
*)

TYPE OverProc=PROCEDURE (): ADDRESS;

PROCEDURE OnOverflow(abortproc: OverProc);
(* Устанавливает  процедурую  реакцию  на  переполнение  кучи;
   -abortproc- должна закачивать или возвращать адрес, который
   будет   перевозвращен  ALLOCATE;  по  умолчанию  реакция  -
   -НеарAbort-.
*)

PROCEDURE returnNIL(): ADDRESS;
(* Пустая реакция для возвращения NIL *)

PROCEDURE HeapAbort(): ADDRESS;
(* Вызывает прерывание 4Eh при переполнении кучи.*)

(*  NEXT PROCEDUREs NOT AVAILABLE AFTER 19-Aug-87.  *)

TYPE Mode=(alloc,dealloc,ilgparm,split,list);
     Modes=SET OF Mode;

CONST all=Modes{alloc..ilgparm};
    dummy=Modes{};
     hack=Modes{alloc..list};

PROCEDURE DebugMode(Mode: Modes);
(* Устанавливает отладочную моду (все валит на терминал):
     alloc  - показ информации об ALLOCATE;
   dealloc  - показ информации об DEALLOCATE;
      list  - показ списка свободных блоков в точках ошибок;
    ilgram  - показ информации о параметрах, когда они имеют
              недопустимые значения.
*)

PROCEDURE ShowList(): INTEGER;
(* Показывает   список   свободных   блоков  и  выдает  размер
   свободной памяти в словах.
*)

END Heap.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                             History
DEFINITION MODULE History;(* Leo & Ned 11-Nov-85 (c) KRONOS *)
                           (* Modified:  Ned 15-Apr-86.     *)


(* Модуль поставляет процедуры, позволяющие узнать историю
   выполнения процесса.
*)

FROM SYSTEM    IMPORT  PROCESS, ADDRESS, WORD;

PROCEDURE PutHis(VAR s: ARRAY OF CHAR; P: PROCESS);
(* Выдает  в  строку  историю  исполнения  процесса  вплоть до
   точки,  в  которой  процесс находится в данный момент. Если
   процесс  завершен,  то  выдается также информация о причине
   его  завершения. История выдается в терминах имен модулей и
   номеров процедур. Например:
        History(MySelf(),S); Show(S),
   вызванная из процедуры 1 модуля MyProg, вернет:
          #History: 1h <- MyProg: 1h 0h <- Tasks: 10h.
   Т.е.  процедура  1  модуля  LIB_HIS  вызвана из процедуры 1
   модуля   MyProg,   которая,  в  свою  очередь,  вызвана  из
   процедуры  0  того же модуля. Соответствие номеров процедур
   их именам легко установить с помощью утилиты CodeVisualizer
   (см. ее описание). Например:
      vs MyProg -t
      0 <инициализация>
      1 PROCEDURE HistoryPrimer
      2 PROCEDURE ShowResults
      ....
*)

PROCEDURE PutCause(VAR s: ARRAY OF CHAR; T: CARDINAL);
(* По  номеру прерывания -T- выдает в строку текст сообщения о
   произошедешем прерывании.
*)

TYPE Str=ARRAY [0..255] OF CHAR;
    pStr=POINTER TO Str;

PROCEDURE SetHis(TermNo: CARDINAL; p: pStr);
(* Устанавливает   указатель  на  строку,  содержащую  историю
   последней задачи для терминала -TermNo-.
*)

PROCEDURE GetHis(TermNo: CARDINAL; VAR p: pStr): BOOLEAN;
(* Выдает  FALSE  и  указатель на строку истории. Выдает TRUE,
   если истории нет.
*)

END History.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                               Image
DEFINITION MODULE Image; (* Leo  04-Apr-87. (c) KRONOS *)

(* Модуль предназначается для работы с числовыми строками. *)

FROM SYSTEM    IMPORT   WORD;

CONST    ok=0;
      dummy=-1;
    illegal=-2;
   overflow=-3;
  underflow=-4;
invalidbase=-5;

PROCEDURE PeekNum (VAR s: ARRAY OF CHAR; pos: INTEGER;
                   VAR w: WORD): INTEGER;
PROCEDURE PeekReal(VAR s: ARRAY OF CHAR; pos: INTEGER;
                   VAR w: REAL): INTEGER;
(* Считывает из строки -s- число -w-, начиная с позиции -pos-.
   Возвращает номер позиции следующего за числом символа и < 0
   в случае неудачи.
   minInt=2147483648=-2147483648
         =20000000000b=-20000000000b
         =20000000000c=-20000000000c
         =80000000h=-80000000h.
   Все эти варианты считаются правильными.
*)

PROCEDURE GetNum (VAR s: ARRAY OF CHAR; VAR n: WORD): INTEGER;
PROCEDURE GetReal(VAR s: ARRAY OF CHAR; VAR n: WORD): INTEGER;
(* Эквивалентно: FirstWord(s,n) ("Взять число из -n-").
   -n-  может состоять из любых базовых чисел, например:
        123456789
       -1
        0ABCDEFh
        177b
       -177b
        377c
   Возвращает  значение  больше  или  равное  нулю,  если  все
   нормально.
*)

PROCEDURE image(VAR s: ARRAY OF CHAR; format: ARRAY OF CHAR;
                SEQ w: WORD);
(* Добавляет  в  строку  -s-  число  -w-, записанное в формате
   -format-.   О   возможных  форматах  см.  в  комментарии  к
   процедуре -print- модуля StdIO.
*)
PROCEDURE image0(VAR s: ARRAY OF CHAR; format: ARRAY OF CHAR;
                 SEQ args: WORD);
(* То   же,   что   и   -image-,   но   инициализирует  строку
   Strings.Str0(s)
*)
END Image.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                            iterDirs
DEFINITION MODULE iterDirs; (* Ned 20-Oct-87. (c) KRONOS *)

(* Модуль позволяет итерировать директорию, сравнивая имена на
   ней с мультиобразцом.
*)

TYPE
                       (*    file         name       *)
  OneFile  = PROCEDURE (VAL INTEGER, VAL ARRAY OF CHAR);
  ErrProc  = PROCEDURE (ARRAY OF CHAR);

PROCEDURE pattern(VAL s: ARRAY OF CHAR; match: BOOLEAN);
(* Определяет  образец,  с  которым  будет  сопоставляться имя
   файла,  если  match,  или  не  сопоставляться  в  противном
   случае.
*)

PROCEDURE clearpatterns;
(* Убирает все образцы *)

PROCEDURE Ls(VAL path: ARRAY OF CHAR; file: OneFile;
             err: ErrProc);
(* Итерирует   директорию,   определенную  путем  относительно
   текущей директории.
   Пример:
     pattern('*.sym',FALSE);
     pattern('*.cod',FALSE);
     pattern('.*',FALSE);
     iterDir('/ii/bin/*.@',lsOne,Show);
     (* При этом вызовется pattern('*.@',TRUE) *)
*)

END iterDirs.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                            Keyboard
DEFINITION MODULE Keyboard; (* Leo 03-Jan-87. (c) KRONOS *)

(* Модуль поставляет процедуры работы с клавиатурой.
*)

CONST
  empty=200c;
  firstkey=201c;   (* first key code *)

  cr=15c; lf=12c; space=40c;

  up   =201c; dw   =202c;  left =204c;  right=203c;
  delc =205c; insc =206c;  delln=207c;  insln=210c;
  uppg =211c; dwpg =212c;  newln=213c;  dupln=214c;
  rtab =215c; ltab =216c;  upswp=217c;  dwswp=220c;
  lpull=221c; rpull=222c;  erase=223c;  eraln=224c;
  home =225c; end  =226c;  lword=227c;  rword=230c;

  break=003c; del   =010c; ins_rep=032c; exit=005c;
  gold =237c; silver=236c; bronze=235c;

(*func(i)=ORD(f0)+i)*)

  f0   =240c; f1   =241c; f2   =242c; f3   =243c;
  f4   =244c; f5   =245c; f6   =246c; f7   =247c;
  f8   =250c; f9   =251c; f10  =252c; f11  =253c;
  f12  =254c; f13  =255c; f14  =256c; f15  =257c;

  never=000c;  (* never readen key *)

PROCEDURE ClearKeys;
(* Удаляет все трансляции для текущего типа терминала *)

PROCEDURE SetKey(k: CHAR; source: CHAR);
(* Показывает, что для текущего типа терминала символ -source-
   транслируется в ключ -k-;
*)

PROCEDURE PeekKey(): CHAR;
(* Возвращает  ключ, но не берет его из буфера; если не нажата
   ни  одна кнопка или нажатие кнопок не закончено, возвращает
   -empty- .
*)

PROCEDURE PeekNextKey(): CHAR;
(* Если  в  буфере  два  ключа,  вычитывает  оба  и возвращает
   второй; иначе ничего не возвращает.
*)

PROCEDURE ReadKey(): CHAR;
(* Если  в  буфере  имеются  сформированный функциональный или
   символьный ключ, изымает и возвращает его; иначе ждет, пока
   ключ не сформируется.
*)

PROCEDURE Pressed?(): BOOLEAN;
(* Возвращает TRUE, если в буфере возникает ключ *)

PROCEDURE CurrentIs(k: CHAR): BOOLEAN;
(* Возвращает TRUE, если в буфере возник ключ и равен -k- *)

PROCEDURE NextIs(k: CHAR): BOOLEAN;
(* Возвращает  TRUE,  если  в  буфере  возник следующий ключ и
   равен -k-.
*)

END Keyboard.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                              KRONOS
DEFINITION MODULE KRONOS; (* Ned  14-Aug-86. (c) KRONOS *)

(* Модуль   предоставляет  некоторые  аппаратные  возможности,
   позволяя   более   эффективно,чем   языковыми   средствами,
   выполнить  определенные  действия.  В качестве комментариев
   предлагается интерпретатор m-кода.
*)

FROM SYSTEM    IMPORT ADDRESS, WORD, PROCESS;
FROM mCodeMnem IMPORT li0, lib, lsw0, ror, rol, inp, out, shl
                    , shr, alloc, tr, bit, comp, lxb, sxb
                    , lastr, move, quit, trap, idle, decs
                    , dot, equ, setm, getm, lla, lga, reset
                    , drop, tra, copt, add
;

PROCEDURE MySelf(): ADDRESS;       CODE li0 lsw0 END MySelf;

PROCEDURE LLA(off: CARDINAL): ADDRESS; CODE lla 00 add END LLA;
PROCEDURE LGA(off: CARDINAL): ADDRESS; CODE lga 00 add END LGA;

PROCEDURE PushW(w: WORD); CODE END PushW;
PROCEDURE PopW(): WORD;   CODE END PopW;

PROCEDURE GETM(): BITSET;  CODE getm END GETM;
PROCEDURE SETM(m: BITSET); CODE setm END SETM;

PROCEDURE SHL(w: WORD; n: CARDINAL): WORD; CODE shl END SHL;
PROCEDURE SHR(w: WORD; n: CARDINAL): WORD; CODE shr END SHR;
(* Shift  Right  &  Left  -  арифметические  сдвиги слова на n
   битов.
   Left  ::= умножение на 2 в степени n;
   Right ::= деление   на 2 в степени n.
*)

PROCEDURE ALLOC(n: CARDINAL): ADDRESS; CODE alloc END ALLOC;

PROCEDURE MOVE(from,to: ADDRESS; n: CARDINAL);
  CODE move END MOVE;

PROCEDURE TR(VAR w: WORD): WORD; CODE tr END TR;
PROCEDURE TRAP(n: CARDINAL); CODE trap END TRAP;

PROCEDURE BIT(n: CARDINAL): BITSET; CODE bit END BIT;

PROCEDURE IDLE; CODE idle END IDLE;

PROCEDURE LASTR(): CARDINAL; CODE lastr END LASTR;

PROCEDURE FTRANSFER(VAR p,q: PROCESS): CARDINAL;
CODE tra lastr END FTRANSFER;

PROCEDURE PACK(VAR a: WORD; i: CARDINAL; w: WORD);
  CODE sxb END PACK;
PROCEDURE UNPACK(VAR a: WORD; i: CARDINAL): WORD;
  CODE lxb END UNPACK;

PROCEDURE DOT(w: WORD); CODE dot END DOT;
PROCEDURE QUIT; CODE quit END QUIT;

PROCEDURE DROP(w: WORD); CODE drop END DROP;

PROCEDURE COPT; CODE copt END COPT;

PROCEDURE CPU(): INTEGER; CODE 0FCh 0 END CPU;

END KRONOS.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                               mCode
DEFINITION MODULE mCode; (* Ned 12-Aug-86. (c) KRONOS *)

(* Модуль    поставляет   процедуру,   выдающую   5-символьную
   мнемонику команды.
*)

VAR CmdLen: ARRAY [0..0FFh] OF CARDINAL;

PROCEDURE VisCommand(cmd: CARDINAL; VAR s: ARRAY OF CHAR);
(* Выдает   в  строку  5-символьную  мнемонику  команды.  Если
   мнемоника меньше 5 символов, то дописывает пробелами.
*)

END mCode.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                           mCodeMnem
DEFINITION MODULE mCodeMnem; (* Shu 11-Jul-86. (c) KRONOS *)

(* Модуль содержит мнемоники команд процессора. *)

CONST

   li0  = 00h;   llw   =  20h;   lxb   =  40h;   lsw0  =  60h;
   li1  = 01h;   lgw   =  21h;   lxw   =  41h;   lsw1  =  61h;
   li2  = 02h;   lew   =  22h;   lgw2  =  42h;   lsw2  =  62h;
   li3  = 03h;   lsw   =  23h;   lgw3  =  43h;   lsw3  =  63h;
   li4  = 04h;   llw4  =  24h;   lgw4  =  44h;   lsw4  =  64h;
   li5  = 05h;   llw5  =  25h;   lgw5  =  45h;   lsw5  =  65h;
   li6  = 06h;   llw6  =  26h;   lgw6  =  46h;   lsw6  =  66h;
   li7  = 07h;   llw7  =  27h;   lgw7  =  47h;   lsw7  =  67h;

   li8  = 08h;   llw8  =  28h;   lgw8  =  48h;   lsw8  =  68h;
   li9  = 09h;   llw9  =  29h;   lgw9  =  49h;   lsw9  =  69h;
   li0A = 0Ah;   llw0A =  2Ah;   lgw0A =  4Ah;   lsw0A =  6Ah;
   li0B = 0Bh;   llw0B =  2Bh;   lgw0B =  4Bh;   lsw0B =  6Bh;
   li0C = 0Ch;   llw0C =  2Ch;   lgw0C =  4Ch;   lsw0C =  6Ch;
   li0D = 0Dh;   llw0D =  2Dh;   lgw0D =  4Dh;   lsw0D =  6Dh;
   li0E = 0Eh;   llw0E =  2Eh;   lgw0E =  4Eh;   lsw0E =  6Eh;
   li0F = 0Fh;   llw0F =  2Fh;   lgw0F =  4Fh;   lsw0F =  6Fh;

   lib  = 10h;   slw   =  30h;   sxb   =  50h;   ssw0  =  70h;
   lid  = 11h;   sgw   =  31h;   sxw   =  51h;   ssw1  =  71h;
   liw  = 12h;   sew   =  32h;   sgw2  =  52h;   ssw2  =  72h;
   lin  = 13h;   ssw   =  33h;   sgw3  =  53h;   ssw3  =  73h;
   lla  = 14h;   slw4  =  34h;   sgw4  =  54h;   ssw4  =  74h;
   lga  = 15h;   slw5  =  35h;   sgw5  =  55h;   ssw5  =  75h;
   lsa  = 16h;   slw6  =  36h;   sgw6  =  56h;   ssw6  =  76h;
   lea  = 17h;   slw7  =  37h;   sgw7  =  57h;   ssw7  =  77h;

   jflc = 18h;   slw8  =  38h;   sgw8  =  58h;   ssw8  =  78h;
   jfl  = 19h;   slw9  =  39h;   sgw9  =  59h;   ssw9  =  79h;
   jfsc = 1Ah;   slw0A =  3Ah;   sgw0A =  5Ah;   ssw0A =  7Ah;
   jfs  = 1Bh;   slw0B =  3Bh;   sgw0B =  5Bh;   ssw0B =  7Bh;
   jblc = 1Ch;   slw0C =  3Ch;   sgw0C =  5Ch;   ssw0C =  7Ch;
   jbl  = 1Dh;   slw0D =  3Dh;   sgw0D =  5Dh;   ssw0D =  7Dh;
   jbsc = 1Eh;   slw0E =  3Eh;   sgw0E =  5Eh;   ssw0E =  7Eh;
   jbs  = 1Fh;   slw0F =  3Fh;   sgw0F =  5Fh;   ssw0F =  7Fh;



   reset= 80h;   lss   = 0A0h;   move  = 0C0h;   incl  = 0E0h;
   quit = 81h;   leq   = 0A1h;   rds   = 0C1h;   excl  = 0E1h;
   getm = 82h;   gtr   = 0A2h;   lsta  = 0C2h;   sleq  = 0E2h;
   setm = 83h;   geq   = 0A3h;   comp  = 0C3h;   sgeq  = 0E3h;
   trap = 84h;   equ   = 0A4h;   gb    = 0C4h;   inc1  = 0E4h;
   tra  = 85h;   neq   = 0A5h;   gb1   = 0C5h;   dec1  = 0E5h;
   tr   = 86h;   abs   = 0A6h;   chk   = 0C6h;   inc   = 0E6h;
   idle = 87h;   neg   = 0A7h;   chkz  = 0C7h;   dec   = 0E7h;

   add  = 88h;   or    = 0A8h;   alloc = 0C8h;   stot  = 0E8h;
   sub  = 89h;   and   = 0A9h;   entr  = 0C9h;   lodt  = 0E9h;
   mul  = 8Ah;   xor   = 0AAh;   rtn   = 0CAh;   lxa   = 0EAh;
   div  = 8Bh;   bic   = 0ABh;   nop   = 0CBh;   lpc   = 0EBh;
   shl  = 8Ch;   in    = 0ACh;   cx    = 0CCh;   bbu   = 0ECh;
   shr  = 8Dh;   bit   = 0ADh;   ci    = 0CDh;   bbp   = 0EDh;
   rol  = 8Eh;   not   = 0AEh;   cf    = 0CEh;   bblt  = 0EEh;
   ror  = 8Fh;   mod   = 0AFh;   cl    = 0CFh;

   io0  = 90h;   decs  = 0B0h;   cl0   = 0D0h;   swap  = 0F0h;
   io1  = 91h;   drop  = 0B1h;   cl1   = 0D1h;   lpa   = 0F1h;
   io2  = 92h;   lodfv = 0B2h;   cl2   = 0D2h;   lpw   = 0F2h;
   io3  = 93h;   store = 0B3h;   cl3   = 0D3h;   spw   = 0F3h;
   io4  = 94h;   stofv = 0B4h;   cl4   = 0D4h;   sswu  = 0F4h;
   io5  = 95h;   copt  = 0B5h;   cl5   = 0D5h;
   io6  = 96h;   cpcop = 0B6h;   cl6   = 0D6h;
   io7  = 97h;   pcop  = 0B7h;   cl7   = 0D7h;

   fadd = 98h;   for1  = 0B8h;   cl8   = 0D8h;
   fsub = 99h;   for2  = 0B9h;   cl9   = 0D9h;
   fmul = 9Ah;   entc  = 0BAh;   cl0A  = 0DAh;   activ = 0FAh;
   fdiv = 9Bh;   xit   = 0BBh;   cl0B  = 0DBh;   usr   = 0FBh;
   fcmp = 9Ch;   ents  = 0BCh;   cl0C  = 0DCh;   sys   = 0FCh;
   fabs = 9Dh;                   cl0D  = 0DDh;   nii   = 0FDh;
   fneg = 9Eh;   orjp  = 0BEh;   cl0E  = 0DEh;   dot   = 0FEh;
   ffct = 9Fh;   andjp = 0BFh;   cl0F  = 0DFh;   invld = 0FFh;

--------------------------------------------------------------
--            Команды ввода/вывода 90h..97h                 --
---------------+---------------------------------+------------
-- Kronos 2.2  |  Kronos 2.5   |  Kronos 2.6tsb  |          --
-- Kronos 2.6q |               |                 |          --
--             |               |                 |          --
---------------+---------------+-----------------+------------

   inp  = io0;                   -- inp  = io0;
   out  = io1;                   -- out  = io1;
                  trb  = io3;      cinp  = io2;
                                   cout  = io3;
                                   chstr = io4;
                                   chstw = io5;
                                   rdch  = io6;
                                   wrch  = io7;
---------------+---------------+-----------------+------------

END mCodeMnem.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                               Media
DEFINITION MODULE Media; (* Leo  10-Nov-1986. (c) KRONOS *)

(* Модуль является интерфейсом для работы с устройствами.
*)

(* Основными понятиями файловой системы являются:
   ФАЙЛ       -- (file)     последовательность    блоков    на
                 поименованном внешнем НОСИТЕЛЕ.
   НОСИТЕЛЬ   -- (volume)  единица совместного хранения файлов
                 (обычно    диск    или    дисковый    пакет),
                 устанавливаемая     на    любой    подходящий
                 НАКОПИТЕЛЬ.
   ДРАЙВЕР    -- (driver)  значение,  однозначно  определяющее
                 физическое   устройство   и   накопитель,  на
                 который    направлен   ввод/вывод.   Содержит
                 дополнительную информацию, позволяющую узнать
                 соответствующий  носитель  (или место для его
                 монтирования).
   УСТРОЙСТВО -- (device)     физическое     устройство    для
                 обслуживания  некоторого множества однотипных
                 НАКОПИТЕЛЕЙ.    Представляется    стандартным
                 набором  операций  (см. станадрт на написание
                 драйверов).    Идентифицируется    уникальным
                 двухсимвольным        именем,       например:
                 "dp","dx","mt" и т.п.
   НАКОПИТЕЛЬ -- (unit)  позиция  для  установки произвольного
                 НОСИТЕЛЯ  подходящего  типа. Идентифицируется
                 указанием  УСТРОЙСТВА и номера обслуживаемого
                 накопителя,   например:  "dx0","dp2","mt7"  и
                 т.п.
   ДИРЕКТОРИЯ -- (directory) специальный вид файла. Директория
                 содержит имена других файлов и указание на их
                 местоположение  в  файловой системе. При этом
                 говорят,  что данные файлы "ПРИВЯЗАНЫ" к этой
                 директории,  хотя  физически  они  могут быть
                 размещены на любом из имеющихся НОСИТЕЛЕЙ.

   Все  операции  файловой  системы  возвращают FALSE в случае
   удачного  завершения  операции,  иначе возвращают ненулевой
   результат,   который   может  быть  проинтерпретирован  как
   значение    TRUE.   За   более   подробной   интерпретацией
   результатов обращайтесь к модулю Files.
*)

IMPORT FsDrv;
FROM SYSTEM    IMPORT    WORD, ADDRESS;


PROCEDURE Mount(dev: ARRAY OF CHAR;
                VAR vol: ARRAY OF CHAR): BOOLEAN;
(* Монтирует носитель на указанном накопителе. *)

PROCEDURE Dismount(DeviceName: ARRAY OF CHAR): BOOLEAN;
(* Демонтирует носитель на указанном накопителе. *)

PROCEDURE InitVolume(dev,vol: ARRAY OF CHAR;
                     iNodes: INTEGER): BOOLEAN;
(* Размещает носитель на указанном устройстве, создавая на нем
   корневую ДИРЕКТОРИЮ.
*)
                                                            (*
PROCEDURE ReadDisk (Driver: CARDINAL; BlockNo: CARDINAL;
                    Buf : ADDRESS; sz  : CARDINAL): BOOLEAN; *)
CONST     ReadDisk=FsDrv.ReadBlock;
(* Осуществляет  физическое  чтение  с  указанного накопителя.
   Номер  блока  задается  в терминах абсолютной адресации для
   данного типа устройств.
   Справедливы все замечания, сделанные относительно -ReadU-.
*)
                                                            (*
PROCEDURE WriteDisk(Driver: CARDINAL; BlockNo: CARDINAL;
                    Buf : ADDRESS; sz  : CARDINAL): BOOLEAN;*)
CONST     WriteDisk=FsDrv.WriteBlock;
(* Осуществляет  физическую  запись  на  указанный накопитель.
   Номер  блока  задается  в терминах абсолютной адресации для
   данного типа устройств.
   Справедливы все замечания, сделанные относительно -WriteU-.
*)

                                                            (*
PROCEDURE DevDrv(dev: ARRAY OF CHAR;
                 VAR drv: INTEGER): BOOLEAN;                *)
CONST     DevDrv=FsDrv.DevDrv;
(*
   Возвращает номер устройства по его имени, например:
   IF DevDrv("dx1",d) THEN (* Нет такого устройства *)
   ELSE r:=WriteDisk(d,0,Buf,4096); ...
   END
*)

                                                            (*
PROCEDURE VolDrv(vol: ARRAY OF CHAR;
                 VAR drv: INTEGER): BOOLEAN;                *)
CONST     VolDrv=FsDrv.VolDrv;

                                                            (*
PROCEDURE DrvDev(drv: INTEGER;
                        VAR dev: ARRAY OF CHAR): BOOLEAN;   *)
CONST     DrvDev=FsDrv.DrvDev;
(* Возвращает имя устройства по его номеру *)

                                                            (*
PROCEDURE DrvVol(drv: INTEGER;
                 VAR vol: ARRAY OF CHAR): BOOLEAN;          *)
CONST     DrvVol=FsDrv.DrvVol;


                                              (*
PROCEDURE DeviceSize(unit: CARDINAL): INTEGER; *)
CONST     DeviceSize=FsDrv.DeviceSize;
(* Выдает размер НАКОПИТЕЛЯ либо 0, если такого нет *)

PROCEDURE DevVol(dev: ARRAY OF CHAR;
                 VAR vol: ARRAY OF CHAR): BOOLEAN;

PROCEDURE VolDev(vol: ARRAY OF CHAR;
                 VAR dev: ARRAY OF CHAR): BOOLEAN;

END Media.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                              Memory
DEFINITION MODULE Memory; (* Leo 25-Sep-86. (c) KRONOS *)

FROM SYSTEM    IMPORT ADDRESS;

(* Начальное состояние памяти
                 ВСЕ ЗАНЯТО
   OS  должна "освободить" память, которую собирается
   использовать и закрыть в ней все "дыры"
*)

PROCEDURE   ALLOCATE(VAR a: ADDRESS; words: CARDINAL);
(* a=NIL если нет подходяшего куска *)

PROCEDURE DEALLOCATE(VAR a: ADDRESS; words: CARDINAL);

PROCEDURE LockHoles;
(* закрывает в свободной (!) памяти все "дыры"
   содержашие ПЗУ (ROM) или ошибочные биты
*)

PROCEDURE ShowMem;

PROCEDURE ALLOCATEup(VAR a: ADDRESS; words: CARDINAL);
(* Выделяет память в верхней области памяти *)

PROCEDURE GetFix(name: ARRAY OF CHAR; VAR a: ADDRESS;
                 VAR szW: INTEGER);
(* Возвращает адрес именованной области памяти и ее размер
   (см. утилиту abs).
   a=NIL, если области с таким именем нет.
*)

END Memory.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                                Misc
DEFINITION MODULE Misc; (* Leo 19-Dec-85 *)

(* Модуль 'Miscellaneos' - разное.
*)

PROCEDURE Min(X,Y: INTEGER): INTEGER;
PROCEDURE Max(X,Y: INTEGER): INTEGER;
(* Возвращают min или max соответственно *)

PROCEDURE Dig8?  (Ch: CHAR): BOOLEAN;
(* RETURN (Ch>='0') & (Ch<='7') *)

PROCEDURE Dig?   (Ch: CHAR): BOOLEAN;
(* RETURN (Ch>='0') & (Ch<='9') *)

PROCEDURE Dig16? (Ch: CHAR): BOOLEAN;
(* RETURN (Ch>='0') & (Ch<='9') OR (Ch>='A') & (Ch<='F') *)

PROCEDURE Ord16? (Ch: CHAR): CARDINAL;
(* Ставит  в  соответствие  символам 0..9,A..F значения 0..15.
   Предполагается,  что  Dig16?(Ch)=TRUE,  иначе прерывание по
   неправильным границам отрезка (TRAP(4Ah)).
*)

PROCEDURE Letter?(Ch: CHAR): BOOLEAN;
(* Буква?  (A..Z,a..z,а..я,А..Я) *)

PROCEDURE Capital(Ch: CHAR): CHAR;
(* Преобразование маленьких букв в БОЛЬШИЕ: a..z -> A..Z *)

PROCEDURE Bold(Ch: CHAR): CHAR;
(* Преобразование БОЛЬШИХ букв в маленькие. *)

PROCEDURE Latin?(Ch: CHAR): BOOLEAN;
(* Буква латиницы? *)

PROCEDURE Kiril?(Ch: CHAR): BOOLEAN;
(* Буква кириллицы? *)

PROCEDURE Capital?(Ch: CHAR): BOOLEAN;
(* БОЛЬШАЯ буква? *)

PROCEDURE Bold?   (Ch: CHAR): BOOLEAN;
(* Маленькая БУКВА? *)

PROCEDURE Special?(Ch: CHAR): BOOLEAN;
(* Специальный сивол?
   (;0123456789+!"#$%&'()=-*:|\>.?/<,_^ и т.п.)
*)

PROCEDURE Control?(Ch: CHAR): BOOLEAN;
(* Контрольный символ? *)
END Misc.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                             Pattern
DEFINITION MODULE Pattern; (* Leo 22-Dec-85. (c) KRONOS *)

(* Модуль   экспортирует  процедуры,  позволяющие  работать  с
   образцами.
*)

PROCEDURE Match(Pattern,Source: ARRAY OF CHAR): BOOLEAN;
(*
   Сопоставление  набора  символов  Source с образцом Pattern.
   Образцы  могут  содержать  символ '*', сопоставимый с любым
   символом или множеством символов, а также '%', сопоставимый
   с любым символом.
*)

PROCEDURE MatchRep(Pattern,Source: ARRAY OF CHAR;
                   VAR Destinator: ARRAY OF CHAR): BOOLEAN;
(* Destinator  - получатель, куда после сравнения записывается
   соответствующим образом подправленный Source. Используется,
   например, в утилите 'copy' :
   cp m*.% mm*.%
*)

END Pattern.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                        QuickStreams
DEFINITION MODULE QuickStreams;(* Leo 19-Aug-86. (c) KRONOS *)

(* Модуль для того же, что и Stream, только быстрее. *)

FROM SYSTEM    IMPORT ADDRESS, WORD;
IMPORT ASCII;

TYPE Stream=RECORD
              file: CARDINAL; (* 0 *)
              eof : CARDINAL; (* 1 *)
              bc  : CARDINAL; (* 2 *)
              lim : CARDINAL; (* 3 *)
              cc  : CARDINAL; (* 4 *)
              cre : BOOLEAN;  (* 5 *)
              Buf : ARRAY [0..4095] OF CHAR; (* 6 *)
            END;

CONST EOF=ASCII.EOF;

TYPE ErrorProc = PROCEDURE (VAL ARRAY OF CHAR, SEQ WORD);

PROCEDURE Error(e: ErrorProc);
(* Устанавливает процедуру реакции на ошибку *)

PROCEDURE ErrorOnTerminal(VAL format: ARRAY OF CHAR;
                          SEQ args: WORD);
(* Процедура реакции по умолчанию *)

PROCEDURE Open  (VAR s: Stream; n: ARRAY OF CHAR): INTEGER;
(* Привязывает поток к файлу с именем n *)

PROCEDURE LookUp(VAR s: Stream; n: ARRAY OF CHAR): INTEGER;
(* Ищет  файл с именем -n- в директориях, на которые указывает
   path; если находит - привязывает к нему поток -s-, если нет
   - выдает номер ошибки.
*)

PROCEDURE Connect(VAR s: Stream; file: INTEGER);
(* Связывает поток с открытым файлом *)

PROCEDURE Create(VAR s: Stream; n: ARRAY OF CHAR): INTEGER;
(* Пытается  открыть  файл  с  именем  n,  если не находит, то
   создает файл с таким именем.
*)

PROCEDURE Close (VAR s: Stream): INTEGER;
(* Закрывает поток s *)

PROCEDURE Create0(VAR s: Stream): INTEGER;
(* Создает   неименованный  файл,  который  будет  удален  при
   закрытии  процедурой  Close. Чтобы его сохранить и закрыть,
   используйте процедуру Link.
   Внимание! Файл создается на текущем носителе!
*)

PROCEDURE Link(VAR s: Stream; name: ARRAY OF CHAR): INTEGER;
(* Закрывает файл привязывая его по именем -name- *)

PROCEDURE GetC(VAR s: Stream): CHAR;
(* Выдает один символ из потока s *)

PROCEDURE PutC(VAR s: Stream; Ch: CHAR);
(* Кладет в поток s символ Ch *)

PROCEDURE sWrite(VAR s: Stream; Buf: ADDRESS;
                    no: CARDINAL): INTEGER;
(* Пишет в поток -s- -no- символов, взятых по адресу 'Buf' *)

PROCEDURE ReSet(VAR s: Stream; pos: CARDINAL);
(* Позиционируется  в  потоке  -s- на позицию с номером -pos-.
   После ReSet вызываются только -sRead- и -GetC- .
*)

PROCEDURE ReWrite(VAR s: Stream; pos: CARDINAL);
(* Вызывается только после -Open- или -LookUp, когда указатель
   потока  стоит в начальной позиции. После ReWrite вызываются
   только -sWrite- и -PutC-.
 *)

PROCEDURE Pos?(VAR s: Stream): CARDINAL;
(* Возвращает текущую позицию в потоке *)

CONST EOL = 0c;

PROCEDURE GetS(VAR s: Stream; VAR str: ARRAY OF CHAR);
(* Читает  строку  из  потока. В конце строки ставит EOL. Если
   строка не влезает, то разбивает ее.
*)

END QuickStreams.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                               Radix
DEFINITION MODULE Radix ; (* Лопатин 14-Мая-86 *)
                          (* Jat      5-Oct-86 *)

(* Модуль  поставляет  процедуры  преобразования  символов  из
   ASCII в Radix и обратно.
*)

TYPE Ch3 = ARRAY [0..2] OF CHAR ;

PROCEDURE ASCR50(с: Ch3):CARDINAL;
(* Преобразует символ ASCII в символ R50 *)

PROCEDURE R50ASC(val: CARDINAL; VAR с: Ch3);
(* Преобразует символ R50 в символ ASCII *)

END Radix.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                            Resource
DEFINITION MODULE Resource; (* Leo 09-Jul-87  (c) KRONOS *)

PROCEDURE Final(финализатор: PROC);
(* Эта  процедура  вызывается,  когда  задача  завершается или
   прекращается.
*)

PROCEDURE ResourceUnderflow;
(* Исчерпание ресурса *)

END Resource.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                               StdIO
DEFINITION MODULE StdIO; (* Leo 19-Apr-86. (c) KRONOS *)

FROM SYSTEM    IMPORT   ADDRESS, WORD;
IMPORT ASCII;

(*
     Модуль     экспортирует    процедуры    стандартного
ввода-вывода в стиле UNIX.
*)

CONST EOF = ASCII.FS;   CR = ASCII.CR; LF = ASCII.LF;


PROCEDURE print(format: ARRAY OF CHAR; SEQ args: WORD);
(* Выводит  последовательность  аргументов в файл стандартного
   вывода в указанном формате.
*)

(* format     ::= { текст | "%" формат | "%%" | "\n"
                    | "\r" | "\l" | "\\" } 0c.
   текст      ::= "любая последовательность символов ASCII-8,
                   кроме '%','\' и 0c ".
                   Если требуется символ '%', предварите его '%':
                   '%%' преобразуется в просто '%'.
                   Если требуется символ '\', предварите его '\':
                   '\\' преобразуется в просто '\'.
   формат     ::= { модификатор } база.
   база       ::= ("d"|"h"|"b"|"s"|"{}"|"i").
   ширина     ::= цифра { цифра } | "*".
   точность   ::= "." цифра { цифра } | ".*" .
   модификатор::= ( space | "$" | "-" | "+" | "#" | ширина
                    | точность } .
   d   (Decimal)       - десятичное;
   h,H (Hexidecimal)   - шестнадцатеричное
                         (h,x -- "A".."F" прописные)
   x,X (Hexidecimal)   - эквивалентно 'h'
                         (H,X -- "a".."f"  строчные)
   b,B (Octal)         - восьмеричное;
   o,O (Octal)         - эквивалентно 'b'
   s,S (String)        - строка;
   c,C (Char  )        - одиночный символ
   {}  (set)           - битсет;
   i,I (bIn)           - двоичное;
   f,F (Float)         - вещественное число в формате:
                           [+|-]dddddddd.ddddd
                             |__  n1  __|_ t _|
                         Число  цифр  до  запятой n1 - минимально
                         необходимое   для  представления  числа.
                         Число  цифр  после  запятой t - задается
                         точностью (по умолчанию 6).
   e,E (Exponent)      - вещественное число в формате:
                           [+|-]d.ddddddE(+|-)dd    или
                           [+|-]D.DDDDDDe(+|-)DD
                         Число цифр до запятой 1
                         Число цифр после запятой t - задается
                         точностью (по умолчанию 6)
                         (формат 'e' -- 'E' в результате)
                         (формат 'E' -- 'e' в результате)
   g,G (General)       - вещественное число в формате:
                           если FLOAT(TRUNC(число))=число,
                           то в формате   dddddd;
                           иначе в формате 'f' или 'e'
                           - какой короче.
   #                   - показывает  число  с указанием основания
                         (например:   image(s,"%$10#h",12abcdefH);
                         эквивалентно image(s,"012ABCDEFh") );
   -                   - число пишется слева в поле установленной
                         ширины;
   +                   - показывает  число  со знаком, независимо
                         от знака числа;
   $   (zero)          - дополнить до нужного количества разрядов
                         ведущими нулями;
   space               - выставляется     знак,     если    число
                         отрицательное, иначе пробел;
   точность            - задает   число  значащих  цифр  после(!)
                         запятой в форматах 'f','e','g' или число
                         символов строки в формате 's';
   ширина              - задает  общую(!)  ширину  поля (с учетом
                         возможных  символов  основания,  знака и
                         т.п.);     если     указанной     ширины
                         недостаточно      для      представления
                         выводимого      значения,     происходит
                         автоматическое    расширение   поля   до
                         минимально   необходимого;  если  вместо
                         спецификации   ширины   и/или   точности
                         указаны   '*',   то  значения  ширины  и
                         точности   берутся   из  соответствующих
                         аргументов.  Внимание! Значение точности
                         и   ширины   должно  быть  из  диапазона
                         [0..255];   в   противном   случае   оно
                         принимается     равным    значению    по
                         умолчанию.
   Модификаторы  '$' и '-',   естественно, не совместимы.
   Модификаторы  '+' и space, естественно, не совместимы.
   Модификатор  точность  может быть использован только с базами
   's','f','e','g'.
   Модификаторы  '+'  и  space  могут быть использованы только с
   базами 'i','f','e','g'.
   Модификаторы  '$',  '+'  и space НЕ могут быть использованы с
   базами 's','{}','c'.
   \n  обозначает CR+LF
   \r  обозначает CR
   \l  обозначает LF
   ВНИМАНИЕ! \n, \r, \l обрабатываются ТОЛЬКО в формате, но не в
   строках-аргументах!!!
*)


TYPE Stream=INTEGER; (* Stream < 0  если поток не открыт. *)

VAR StdIn, StdOut, StdErr: Stream;

PROCEDURE Open  (s: ARRAY OF CHAR): Stream;
(* Открывает файл с именем -s- *)

PROCEDURE LookUp(s: ARRAY OF CHAR): Stream;
(* Ищет  файл с именем -s- в директориях, на которые указывает
   путь (path), и если находит, то открывает его.
*)

PROCEDURE Create(s: ARRAY OF CHAR): Stream;
(* Пытается  открыть  файл  -s-;  если файл не найден, создает
   файл с таким именем.
*)

PROCEDURE Close(s: Stream): INTEGER;
(* Закрывает файл с именем -s-, в случае неудачи Close(...)<0.
*)

PROCEDURE Seek(s: Stream; offset: INTEGER;
               origin: CARDINAL): INTEGER;
(* Позиционирует  файл  на -offset- байтов относительно начала
   (-origin-=0), текущей позиции (-origin-=1) или конца потока
   (-origin-=2).
   Возвращает  реальную  позицию  в  потоке, на которой теперь
   стоит  указатель. Начальная позиция в потоке имеет номер 0:
   Seek(s,0,0)=0.  Seek(...)<0  -  свидетельствует  об  ошибке
   ввода/вывода.
*)

PROCEDURE sRead (s: Stream; a: ADDRESS;
                 lengh: CARDINAL): INTEGER;
(* Читает  из потока -s- -lenght- байт и кладет их адресу -a-.
   Выдает  число  прочитанных  символов  (в  том числе 0, если
   встретился  конец файла), либо номер ошибки, если результат
   отрицательный.
*)

PROCEDURE sWrite(s: Stream; a: ADDRESS;
                 lengh: CARDINAL): INTEGER;
(* Пишет в поток -s- -lenght- символов, взятых по адресу -a-.
*)

PROCEDURE GetC(s: Stream): CHAR;
(* Читает  один символ из потока -s- *)

PROCEDURE PutC(s: Stream; char: CHAR);
(* Кладет символ -char- поток -s- *)

PROCEDURE GetS(s: Stream; VAR str: ARRAY OF CHAR): INTEGER;
(* Символ  за  символом  читает  строку из потока -s- в -str-;
   выдает  число прочитанных символов, либо номер ошибки, если
   результат  меньше  нуля.  Результат  равен нулю при попытке
   чтения за концом файла.
*)

PROCEDURE PutS(s: Stream; str: ARRAY OF CHAR);
(* Кладет в поток -s- строку -str- до 0c или до конца массива.
*)

PROCEDURE BusyGetC(s: Stream): CHAR;
(* Читает символ из потока; если нет символов, выдает 0c *)

PROCEDURE Why?(r: INTEGER; VAR s: ARRAY OF CHAR);
(* Здесь  r - результат неудачного выполнения любой процедуры.
   Выдает в s причину неудачи.
*)

PROCEDURE File?(s: Stream): INTEGER;
(* Выдает  номер файла, которому соответствует поток, либо -1,
   если поток открыт на терминал.
*)

PROCEDURE IsTTY?(s: Stream): BOOLEAN;
(* TRUE, если поток открыт на терминал *)

(* Файлы стандартного ввода и вывода - последовательные файлы,
   по  умолчанию  направленные  на  терминал,  закрепленный за
   данным  процессом.  Изменить  их  назначение (перенаправить
   ввод/вывод)  можно  внешним  по  отношению к данному модулю
   способом.
*)

PROCEDURE SetMode(ControlC: BOOLEAN);
(* ControlC  -  интерпретировать  ^C как прерывание исполнения
   процесса.   Устанавливается  только  если  StdIO  терминал.
   Терминал   остается  в  указанном  состоянии  до  следующей
   установки даже после окончания процесса.
*)

PROCEDURE Write(Ch: CHAR);
(* Выводит один символ в файл стандартного вывода. *)

PROCEDURE Read(): CHAR;
(* Читает  один  символ  из  файла  стандартного  ввода.  Если
   стандартный   ввод   открыт   на   терминал,  то  некоторые
   контрольные символы имеют особую интерпретацию. Среди них:
   ^C - посылает сигнал прерывания процесса.
   ^S - немедленно остановить процесс вывода на терминал. Этот
        символ   употребляется   как   программистом,   так  и
        некоторыми  конструкциями  терминалов  (при выполнении
        операций,  требующих  существенных  затрат  времени  -
        например, раздвижка строк).
   ^Q - возобновить вывод на терминал.
   ^O - переключиться   на   латинский   регистр  (в  стандарт
        ASCII-7). Это символ SI в стандарте ASCII.
   ^N - переключиться на национальный регистр (в данном случае
        кириллица КОИ-8). Это символ SO в стандарте ASCII.

   ^F - переключить (инвертировать) перекодировку больших букв
        в  маленькие  и  маленьких в большие. Используется для
        терминалов, не имеющих клавиши CAPITALS с фиксацией)

   Специальный   смысл   интерпретации   этих  символов  можно
   выключить внешним по отношению к данному модулю способом.
*)

PROCEDURE BusyRead(): CHAR;
(* Проверяет, был ли введен из стандартного ввода хотя бы один
   символ,  и  если  такой  символ имеется, то выполняется как
   операция Read, иначе возвращает значение 0c.
*)

PROCEDURE Pressed(): INTEGER;
(* Возвращает число уже нажатых на клавиатуре кнопок *)

PROCEDURE Peek(n: INTEGER): CHAR;
(* Позваляет   заглянуть  вперед  на  -n-  символов  в  потоке
   стандартного ввода, открытом на клавиатуру.
*)

PROCEDURE ReadStr(VAR S: ARRAY OF CHAR);
(* Осуществляет  ввод  строки  из  файла стандартного ввода. В
   случае,  если  этот файл терминал, допускает редактирование
   вводимой строки в режиме экранного однострочного редактора.
   Допустимы  движения по строке с помощью стрелок 'вставка' и
   'удаление   символов',   а   также   использование  старого
   содержимого строкового массива, предоставленного для ввода.
   Для   терминала   ввод  осуществляется  модулем  Edit,  см.
   комментарии к нему.
*)

PROCEDURE AskStr(Txt: ARRAY OF CHAR; VAR S: ARRAY OF CHAR);
(* Выдает  в  стандартный  вывод  приглашение  Txt  с  помощью
   процедуры   WriteString,  после  чего  считывает  ответ  из
   стандартного ввода с помощью ReadString.
*)

PROCEDURE Confirm(prompt: ARRAY OF CHAR; VAR s: ARRAY OF CHAR);
(* То  же,  что  AskStr,  но с показом предыдущего содержимого
   строки.
*)

PROCEDURE WriteString(S: ARRAY OF CHAR);
(* Выдает  в файл стандартного вывода содержимое строки символ
   за  символом. Концом строки считается либо физический конец
   предоставленного  массива, либо символ 0c, в зависимости от
   того, что встретится раньше.
*)

PROCEDURE Show(S: ARRAY OF CHAR);
(* Эквивалентна последовательности: WriteString(S); WriteLn *)

PROCEDURE ShowAndWait(S: ARRAY OF CHAR);
(* Эквивалентна        последовательности:
       WriteString(S); dummy:=Read();    WriteLn;
   Значение  введенного  символа несущественно и игнорируется.
   Используется  для  приостановки  вывода  до  нажатия  любой
   клавиши на клавиатуре.
*)

PROCEDURE Query(s: ARRAY OF CHAR): BOOLEAN;
(* Печатает    приглашение   's'   и   возвращает   TRUE   для
   'y','Y','д','Д',   введенного   с   терминала;   FALSE  для
   'n','N','н','Н'.
*)

PROCEDURE QueryLn(s: ARRAY OF CHAR): BOOLEAN;
(* r:=Query(s); WriteLn; RETURN r *)

PROCEDURE WriteLn;
(* Эквивалентна Write(NL).
   Замечание.
   При  выводе  на последовательное устройство внутрисистемное
   соглашение  о  завершении строки в файлах с помощью символа
   NL   конвертируется  в  вывод  последовательности  символов
   возврата каретки (CR) и перевода строки (LF).
*)

PROCEDURE SetCrs(Line,Col: CARDINAL);
(* Осмыслена   только   если  стандартный  вывод  напрвлен  на
   терминал,  иначе  игнорируется.  Вызывает  позиционирование
   курсора в указанные строку и столбец.
*)

PROCEDURE Esc(Ch: CHAR);
(* Выдает  в  файл вывода Escape-последовательность, состоящую
   из символа Esc (33c) и указанного символа. Используется для
   управления        интеллектуальными       последовательными
   устройствами,    имеющими   собственную   систему   команд,
   распознаваемую  через  Escape-последовательности (например,
   высококачественными печатающими устройствами).
*)

PROCEDURE Bell;
(* Порождает звуковой сигнал, если стандартный вывод направлен
   на терминал и терминал обладает звуковым генератором. Иначе
   игнорируется.
*)

PROCEDURE Home;
(* Позционирует  курсор  в  верхний  левый  угол  экрана, если
   стандартный вывод направлен на экран, иначе игнорируется.
*)

PROCEDURE Clear;
(* Стирает  содержимое  экрана  от  позиции  курсора  до конца
   экрана,  если  стандартный  вывод направлен на экран, иначе
   игнорируется.
*)

PROCEDURE ClearLine;
(* Стирает  содержимое  строки  от  позиции  курсора  до конца
   строки,  если  стандартный  вывод направлен на экран, иначе
   игнорируется.
*)

END StdIO.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                             Streams
DEFINITION MODULE Streams; (* Leo 19-Apr-86. (c) KRONOS *)

(* Модуль  позволяет  рассматривать  файлы как потоки байтов с
   возможным  позиционированием в них и чтением с произвольной
   позиции.
*)

FROM SYSTEM    IMPORT   ADDRESS, WORD;
IMPORT ASCII;

CONST EOF = ASCII.FS;

TYPE Stream=INTEGER;

(* Stream < 0  если поток не открыт. *)

PROCEDURE Open  (s: ARRAY OF CHAR): Stream;
(* Открывает файл с именем -s- *)

PROCEDURE Create(s: ARRAY OF CHAR): Stream;
(* Пытается  открыть  файл  с  именем -s-; если не находит, то
   создает файл с таким именем.
*)

PROCEDURE Close(s: Stream): INTEGER;
(* Закрывает поток -s-; если неудачно, то результат  < 0 *)

PROCEDURE Seek(s: Stream; offset: INTEGER; origin: CARDINAL):
               INTEGER;
(* Позиционирует  файл  на -offset- байтов относительно начала
   (-origin-=0), текущей позиции (-origin-=1) или конца потока
   (-origin-=2).
   Возвращает  реальную  позицию  в  потоке, на которой теперь
   стоит  указатель. Начальная позиция в потоке имеет номер 0:
   Seek(s,0,0)=0.  Seek(...)<0  -  свидетельствует  об  ошибке
   ввода/вывода.
*)

PROCEDURE Read (s: Stream; a: ADDRESS;
                                   lenght: CARDINAL): INTEGER;
(* Читает из потока -s- -lenght- байт кладет их по адресу -a-;
   выдает  число  прочитанных  символов  (в  том числе 0, если
   встретился   конец   файла),   либо   номер   ошибки,  если
   Read(...)<0.
*)

PROCEDURE Write(s: Stream; a: ADDRESS;
                                   lenght: CARDINAL): INTEGER;
(* Пишет в поток -s- -lenght- байт, взятых по адресу -a- *)

PROCEDURE GetC(s: Stream): CHAR;
(* Выдает один символ из потока -s- *)

PROCEDURE PutC(s: Stream; Ch: CHAR);
(* Кладет символ Ch в поток -s- *)

PROCEDURE PutS(s: Stream; str: ARRAY OF CHAR);
(* Кладет в поток -s- строку -str-, пока не встретится 0c, или
   до конца массива, если не встретился 0c.
*)

PROCEDURE GetS(s: Stream; VAR str: ARRAY OF CHAR): INTEGER;
(* Читает  строку  из  потока  -s- до 0c или до конца массива.
   Выдает число прочитанных симолов или номер ошибки, если <0.
*)

PROCEDURE BusyGetC(s: Stream): CHAR;
(* Читает символ из потока; если нет символов, выдает 0c *)

PROCEDURE Pressed(s: Stream): INTEGER;
(* Выдает число оставшихся в потоке символов *)

PROCEDURE Peek(s: Stream; n: INTEGER): CHAR;
(* Выдает n-ый символ в потоке *)

PROCEDURE Why?(r: INTEGER; VAR s: ARRAY OF CHAR);
(* Здесь  r  -  результат неудачного выполнения процедуры Open
   или  Create,  s  -  имя  файла,  который  открывали; выдает
   причину неудачи.
*)

PROCEDURE File?(s: Stream): INTEGER;
(* Выдает номер файла, которому соответствует поток; результат
   равен -1, если поток открыт на терминал.
*)

PROCEDURE IsTTY?(s: Stream): BOOLEAN;
(* TRUE, если поток открыт на терминал *)

PROCEDURE SetMode(s: Stream; ControlC: BOOLEAN);
(* Интерпретация ^S и ^Q как задержки вывода. Интерпретация ^C
   как   прерывания   процесса.   Устанавливается  только  для
   терминала.  Терминал  остается  в  указанном  состоянии  до
   следующей установки даже после окончания процесса.
*)

PROCEDURE TermNo(s: Stream): INTEGER;
(* Выдает номер терминала, на который открыт поток *)

PROCEDURE LookUp(s: ARRAY OF CHAR): Stream;
(* Ищет файлы на всех директориях, указанных командой  path *)

PROCEDURE print(f: Stream; format: ARRAY OF CHAR;
                SEQ args: WORD);
(* Кладет   в   поток   -f-  последовательность  аргументов  в
   соответствующем   формате.   О  возможных  форматах  см.  в
   комментарии к процедуре -print- модуля StdIO.
*)

END Streams.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                             Strings
DEFINITION MODULE Strings; (* Leo 18-Oct-85 *)

(*    Модуль поставляет процедуры работы со строками.

  0.  Все  операции  работают  со  строками длиной <= 256
      байтов,  т.е.  в  массивах  размера  >  256  байтов
      используются только первые 256 позиций.
  1.  Любая  строка перед началом работы с ней должна (!)
      быть  проинициализирована  операциями  Str0,  Str1,
      Str2.
  2.  Если  в ходе какой-либо операции диапазон указанных
      позиций  выходит за пределы строки, то он усекается
      по диапазону индекса строки.
  3.  Если   при   операции   какая-то  часть  информации
      оказывается  за  пределами  физической  строки, эта
      часть теряется
  4.  Операции,  выдающие строку как результат (например,
      второй  аргумент  операций  FirstWord, DelWord), не
      требуют ее предварительной инициализации.
*)

PROCEDURE Str0(VAR S: ARRAY OF CHAR);
(* Инициализация пустой строки *)

PROCEDURE Str1(VAR S: ARRAY OF CHAR; Contence: ARRAY OF CHAR);
(* Инициализация  строки с началным содержимым -Contence-.
*)

PROCEDURE Str2(VAR S: ARRAY OF CHAR);
(* Эквивалентно Str1(S,S) *)

PROCEDURE Len(VAR S: ARRAY OF CHAR): CARDINAL;
(* выдает длину строки *)
CODE 40h (* LXB *) END Len;

PROCEDURE App(VAR S: ARRAY OF CHAR; Ch:CHAR);
(* Прицепление в конец строки литеры *)

PROCEDURE AppStr(VAR S: ARRAY OF CHAR; A: ARRAY OF CHAR);
(* Прицепление в конец строки другой строки *)

PROCEDURE DelCh(VAR S: ARRAY OF CHAR; i: CARDINAL);
(* Удаление  символа  в  указанной  позиции  и подтяжка хвоста
   строки.
*)

PROCEDURE DelStr(VAR S: ARRAY OF CHAR; i: CARDINAL; len: CARDINAL);
(* Удаление  -len-  символов  в  указанной  позиции и подтяжка
   хвоста строки.
*)

PROCEDURE InsCh(VAR S: ARRAY OF CHAR; i: CARDINAL);
(* Вставка  пробела  в  указанную  позицию  и  сдвижка  хвоста
   строки.
*)

PROCEDURE InsStr(VAR S: ARRAY OF CHAR; i: CARDINAL;
                 len: CARDINAL);
(* Вставка -len- пробелов в указанную позицию и сдвижка хвоста
   строки.
*)

PROCEDURE PoolStr(VAR S: ARRAY OF CHAR);
(* Подтягивает строку влево, удаляя ведущие пробелы *)

PROCEDURE Word(VAR S: ARRAY OF CHAR; n: CARDINAL;
               VAR W: ARRAY OF CHAR);
(* СЛОВО - последовательность подряд идущих литер, отличных от
   пробела, конца или начала строки.
   Выдает  -n-ое  слово  в  строке  -S- в массив -W-, если оно
   есть, иначе пустую строку.
   Внимание!  Аргументы не могут быть одним и тем же массивом!
*)

PROCEDURE WordCount(VAR S: ARRAY OF CHAR): CARDINAL;
(* Подсчитывает число слов в строке *)

PROCEDURE DelWord(VAR S: ARRAY OF CHAR);
(* Удаляет из строки первое слово *)

PROCEDURE GetWord(VAR S: ARRAY OF CHAR; VAR W: ARRAY OF CHAR);
(* Эквивалентно: FirtsWord(S,W); DelWord(S) *)

PROCEDURE FirstWord(VAR S: ARRAY OF CHAR;
                    VAR W: ARRAY OF CHAR);
(* Эквивалентно: Word(S,0,W).
   Выдает  первое  слово в строке, если оно есть, иначе пустую
   строку.
*)

PROCEDURE SubStr(VAR S: ARRAY OF CHAR; start,finish: CARDINAL;
                 VAR W: ARRAY OF CHAR);
(* Вырезает из строки указанную подстроку *)

PROCEDURE SetStr(VAR S: ARRAY OF CHAR; start,finish: CARDINAL;
                     W: ARRAY OF CHAR);
(* Вставляет в строку указанную подстроку *)

PROCEDURE AppLn(VAR s: ARRAY OF CHAR);
(* Эквивалентно App(s,CR); App(s,LF) *)

PROCEDURE Truncate(VAR S: ARRAY OF CHAR; L: CARDINAL);
(* Удаляет хвост строки. Len(S)=L *)

END Strings.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                            SymFiles
DEFINITION MODULE SymFiles;(* Leo & Ned 08-Jun-86 (c) KRONOS *)

FROM SYSTEM    IMPORT ADDRESS, WORD;

(* Модуль осуществляет создание симфайлов и работу с ними.
*)

CONST            (* Симфайл состоит из следующих компонент: *)
  Header = 0FFh;                 (* заголовок               *)
  EndTag = 0FEh;                 (* признак конца           *)
  SymTag = 0FDh;                 (* таблица символов        *)
  RefTag = 0FCh;                 (* таблица ссылок          *)

  StrTag = 0EFh; (* начало строкового или структурного пула *)
(* Примечание.  Промежуток  от  81h  до EFh зарезервирован для
   дополнительных признаков (private tags), за которыми должно
   следовать  два  байта,  обозначающих,  сколько еще байтов в
   этом разделе.
*)
(*
  SymFile ::=    Header
                 ...   private tags
               [ StrTag size bytes ]
                 ...   private tags
               [ SymTag SymTable   ]
                 ...   private tags
               [ RefTag RefTable   ]
                 ...   private tags
*)

CONST (* номера стандартных типов *)
  nUNDEF    = 0;   nADDRESS  = 1;
  nWORD     = 2;   nINTEGER  = 3;
  nCHAR     = 4;   nBOOLEAN  = 6;
  nREAL     = 5;   nBITSET   = 8;
  nPROC     = 7;   nCARDINAL = 9;

TYPE
  Obj   = ADDRESS; (* Упакованное представление        *)
  Mode  = (        (* Виды объектов - см. SymFiles.doc *)
(*  0 *)     inv
(*  1 *)   , int,    int8,   int16
(*  4 *)   , bool,   card,   char,   bitset,  real
(*  9 *)   , adr,    word,   enm,    rng,     ptr,      chptr
(* 15 *)   , arr,    farr,   rec,    hidden,  proctype, settype
(* 21 *)   , vrb,    cst,    stcnst, proc,    mdl,      stndproc
(* 27 *)   , plist,  flist,  mlist,  clist
(* Следующие  объекты  используются  только для генерации; для
   них не нужно определять операции упаковки-распаковки.
*)
(* 31 *)   , Estk,   Ecnst,  Epair
         );
  Modes = SET OF [inv..clist];

VAR
        Types: Modes;   (* = {inv..settype} *)
  SimpleTypes: Modes;   (* = Types - {arr,rec,farr} *)
  ScalarTypes: Modes; (* = {inv,int,bool,card,char,enm,rng} *)
    StndTypes: Modes;   (* = {inv..word} *)

TYPE (* Распакованный объект *)
  Info =
  RECORD
    mode : Mode;      (* вид объекта (все объекты)       *)
    self : Obj;       (* указатель на упакованный объект *)
                      (* (все объекты)                   *)
    typ  : Obj;       (* тип объекта                     *)
          (* {rng,arr,farr,settype,vrb,cst,stcst,proc,flist *)
          (* ptr - если указатель не вперед                 *)
          (* proctype - если тип фунции                     *)
    inx  : Obj;       (* индекс  {arr}                   *)
    list : Obj;       (* список компонент или объектов   *)
           (* {rec,proctype,mdl,enm,plist,flist,mlist,clist *)
    obj  : Obj;       (* объект {mlist,clist}            *)
    lo   : INTEGER;   (* нижняя  граница {arr,rng}       *)
    hi   : INTEGER;   (* верхняя граница {arr,rng}       *)
    name : CARDINAL;  (* имя объекта {mdl,mlist,clist,flist} *)
    info : INTEGER;   (* proc - число локалов            *)
                      (* rec  - размер записи            *)
                      (* cst  - значение                 *)
    ofs  : INTEGER;   (* смещение или номер              *)
           (* {vrb,proc,mdl,stcnst,flist}                *)
    link : INTEGER;   (* уровень или номер внешнего модуля *)
           (* Types + {vrb,proc,cst,stcnst}                *)
    start: CARDINAL;  (* начало кода  {cst,stcnst}       *)

    varparam: BOOLEAN; (* параметр по ссылке  {vrb,plist} *)
    valparam: BOOLEAN; (* параметр по доступу {vrb,plist} *)
    seqparam: BOOLEAN; (* параметр-последовательность
                                              {vrb,plist} *)
    external: BOOLEAN; (* внешний объект  {vrb,proc,mdl}  *)
    forward?: BOOLEAN; (* forward описание; {ptr,proc}    *)
    function: BOOLEAN; (* функция {proctype}              *)
    flexible: BOOLEAN; (* динамический массив; {vrb}      *)
    qua     : BOOLEAN; (* квалифицированный экспорт {mdl} *)
    code?   : BOOLEAN; (* кодовая процедура    {proc}     *)
    invis?  : BOOLEAN; (* невидимый объект                *)
  END;

VAR
  intp, cardp, charp, boolp, adrp, wordp, procp, realp
  , bitsetp: Obj;
  systemp: Obj;

TYPE
  SingleObj = PROCEDURE (CARDINAL,Obj);
  LsUnit    = PROCEDURE (SingleObj);

(* Процедуры, параметризующие чтение/запись симфайлов *)

VAR (* чтение/запись *)
(*rw*)       GetC: PROCEDURE (): CHAR;
(* w*)       PutC: PROCEDURE (CHAR);

VAR (* строки -> внутреннее представление и наоборот *)
(*rw*)      StrId: PROCEDURE (ARRAY OF CHAR): CARDINAL;
(* w*)      IdStr: PROCEDURE (CARDINAL, VAR ARRAY OF CHAR);

VAR (* создание, описание и упаковка объектов *)
(*rw*)        md?: PROCEDURE (Obj): Mode;
(*rw*)          ?: PROCEDURE (VAR Info);
(* r*)        Gen: PROCEDURE (VAR Info);
(* r*)     Update: PROCEDURE (VAR Info);
(* r*)    Declare: PROCEDURE ((*mod,my*)Obj,Obj,CARDINAL,
                               VAR Info): BOOLEAN;

VAR (* работа с типами *)
(* w*)    TypeNo?: PROCEDURE (Obj): CARDINAL;
(* w*)  SetTypeNo: PROCEDURE (VAR Obj,CARDINAL);
(* w*)  name?: PROCEDURE (Obj): INTEGER; (* = -1 IF DummyId *)

VAR (* работа с кодовыми процедурами *)
(* r*)   SaveCode: PROCEDURE (Info,VAR ARRAY OF CHAR,CARDINAL);
(* w*)RestoreCode: PROCEDURE (Info,VAR ARRAY OF CHAR,
                              VAR CARDINAL);

VAR (* Ошибки *)
(*rw*)      Error: PROCEDURE (VAL ARRAY OF CHAR, SEQ WORD);

(** MODULE Externals **)

VAR ExtCo: CARDINAL; (* Число внешних модулей *)

PROCEDURE NewExternal(nm: ARRAY OF CHAR;
                      deftime,k2: WORD): CARDINAL;
(* Ищет  модуль  в таблице внешних, если его нет, то вставляет
   его в таблицу. Возвращает его.
*)

TYPE iterOne = PROCEDURE (CARDINAL,ARRAY OF CHAR);

PROCEDURE LsExts(ip: iterOne);
(* Вызывает  процедуру  -ip-  для  всех  внешних  модулей. См.
   VisExts(FALSE).
*)

PROCEDURE VisExts(all: BOOLEAN);
(* Показ   списка   внешних,  а  если  -all-,  то  имен  всего
   импортируемого поддерева.
*)

(** END Externals **)

PROCEDURE CheckHeader(VAR PL: ARRAY OF CHAR): INTEGER;
(* Проверяет корректность заголовка и пропускает его.
   =0  OK
   =1  это не симфайл;
   =2  устаревшая версия симфайла.
   PL -- имя языка программирования.
*)

PROCEDURE NewSymFile(PL: ARRAY OF CHAR);
(* Записывает заголовок симфайла *)

PROCEDURE SkipToTag(tag: CARDINAL): BOOLEAN;

PROCEDURE SkipSym;
(* Пропускает в потоке таблицу символов *)

PROCEDURE StartSym;    (* Начало записи таблицы символов *)
PROCEDURE StartRef;

PROCEDURE WriteUnit(ls: LsUnit; VAR U: Info);
(* Запись объектов блока. *)

PROCEDURE FixPc(pno,deltaPc,tPos: CARDINAL);
(* Записывает  в  Ref  файл  информацию  о соответствии текста
   коду.
*)

PROCEDURE FinishWrite(gno,pno: CARDINAL): INTEGER;
(* =0  OK
   =1  переполнение таблиц.
  gno -- число глобалов; pno -- число процедур.
*)

PROCEDURE ReadSym(VAR CU: Info; mydef: BOOLEAN): INTEGER;
(* =0  OK;
   =1  конфликт версий (time error).
   Выдает  в  CU.info  -  число  глобалов;  в CU.start - число
   процедур.
*)

PROCEDURE VisSymFile;
(* Визуализирует симфайл. *)

PROCEDURE InitSym;

PROCEDURE ReadRef;

PROCEDURE DefTime?(): INTEGER;

END SymFiles.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                            sysDebug
DEFINITION MODULE sysDebug; (* Ned 16-Apr-87. (c) KRONOS *)

(* Модуль поставляет процедуры визуализации процесса.
*)

FROM SYSTEM    IMPORT   ADDRESS;

TYPE show = PROCEDURE (ARRAY OF CHAR);

PROCEDURE VisProcess(p: ADDRESS; sh: show);
(* Визуализация процесса в процедуру -sh- *)

PROCEDURE VisProcLink(l: ADDRESS; sh: show);
(* Визуализация процедурных связей *)

END sysDebug.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                                Tape
DEFINITION MODULE Tape; (* Leo & Shu  25-Apr-87. (c) KRONOS *)

                (*  Tape drivers handler *)

(* Модуль поставляет процедуры работы с магнитофоном.
*)

FROM SYSTEM    IMPORT   ADDRESS;
FROM TapeHead  IMPORT   VolHeader, FileHeader1, FileHeader2;
FROM FsPublic  IMPORT   FileName;

(* If any procedure returns FsPublic.HardError              *)
(* Tape positionning error take place!!!                    *)
(* So you must Rewind the tape and start at very beginning! *)


                (*  ----   General access  -----   *)

PROCEDURE LockMT(DeviceName: ARRAY OF CHAR;
                 VAR Driver: INTEGER): BOOLEAN;

PROCEDURE UnlockMT(Driver: INTEGER): BOOLEAN;

                (*  ----   Direct   I/O    -----   *)

PROCEDURE ReadBlock (Drv: INTEGER; Buf: ADDRESS;
                    VAR Size: INTEGER): BOOLEAN;

PROCEDURE WriteBlock(Drv: INTEGER; Buf: ADDRESS;
                     VAR Size: INTEGER): BOOLEAN;

PROCEDURE WriteTM(Drv: INTEGER): BOOLEAN;


PROCEDURE Skip(Drv: INTEGER; VAR NoBlocks: INTEGER): BOOLEAN;
(* NoBlocks>0 forward,  NoBlocks<0 backward
   in -NoBlocks- returns # of realy skiped blocks
*)

PROCEDURE Rewind(Drv: INTEGER): BOOLEAN;

                (*  ----   ANSI     I/O    -----   *)
(* At   any   error   (except   FsPublic.HardError)  all  ANSI
   procedures  garanties  that  tape  position is qual to tape
   position before operation started.
*)

PROCEDURE ReadVOL (Drv: INTEGER;
                   VAR header: VolHeader): BOOLEAN;
PROCEDURE ReadEOV (Drv: INTEGER;
                   VAR header: VolHeader): BOOLEAN;

PROCEDURE ReadHDR1(Drv: INTEGER;
                   VAR header: FileHeader1): BOOLEAN;
PROCEDURE ReadHDR2(Drv: INTEGER;
                   VAR header: FileHeader2): BOOLEAN;

PROCEDURE ReadEOF1(Drv: INTEGER;
                   VAR header: FileHeader1): BOOLEAN;
PROCEDURE ReadEOF2(Drv: INTEGER;
                   VAR header: FileHeader2): BOOLEAN;

PROCEDURE ReadUHL (Drv: INTEGER; VAR No: INTEGER;
                   VAR body: ARRAY OF CHAR): BOOLEAN;

PROCEDURE WriteVOL (Drv: INTEGER; header: VolHeader): BOOLEAN;
PROCEDURE WriteEOV (Drv: INTEGER; header: VolHeader): BOOLEAN;

PROCEDURE WriteHDR1(Drv: INTEGER;
                    header: FileHeader1): BOOLEAN;
PROCEDURE WriteHDR2(Drv: INTEGER;
                    header: FileHeader2): BOOLEAN;

PROCEDURE WriteEOF1(Drv: INTEGER;
                    header: FileHeader1): BOOLEAN;
PROCEDURE WriteEOF2(Drv: INTEGER;
                    header: FileHeader2): BOOLEAN;

PROCEDURE WriteUHL(Drv: INTEGER; No: INTEGER;
                   body: ARRAY OF CHAR): BOOLEAN;

PROCEDURE InitVolume  (Drv: INTEGER;  No: INTEGER;
                       Name: ARRAY OF CHAR): BOOLEAN;
PROCEDURE FinishVolume(Drv: INTEGER; No: INTEGER;
                       Name: ARRAY OF CHAR): BOOLEAN;

PROCEDURE MountVolume(Drv: INTEGER; VAR No: INTEGER;
                      VAR Name: ARRAY OF CHAR): BOOLEAN;

TYPE IOproc=PROCEDURE(ADDRESS,INTEGER): BOOLEAN;

PROCEDURE WriteFile(Drv: INTEGER; Name: FileName;
                    FileSizeInBytes: INTEGER;
                     Creation  : INTEGER;
                     Expiration: INTEGER;
                     GetBlock  : IOproc
                   ): BOOLEAN;

PROCEDURE ReadFile (Drv: INTEGER; VAR Name: FileName;
                VAR FileSizeInBytes: INTEGER;
                VAR Creation  : INTEGER;
                VAR Expiration: INTEGER;
                    PutBlock  : IOproc
                   ): BOOLEAN;
END Tape.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                            TapeHead
DEFINITION MODULE TapeHead; (* Shu 26-Apr-87. (c) KRONOS *)

(* Модуль  поставляет  процедуры  для  упаковки  и  распаковки
   ленточных меток.
*)

   (*           USASI Tape Labels standard                 *)
   (*                                                      *)
   (*         MV1905, MV1906, MV1907, MV1908               *)

   (*          The KRONOS & ALL extensions                 *)
   (*                marked "k&a: ..."                     *)

TYPE
  Str17 = ARRAY [0..18] OF CHAR;
  Str14 = ARRAY [0..15] OF CHAR;
  Str6  = ARRAY [0.. 7] OF CHAR;
  Str5  = ARRAY [0.. 6] OF CHAR;
  Str4  = ARRAY [0.. 5] OF CHAR;
  Empty = ARRAY [0..31] OF CHAR;

  Head80= ARRAY [0..81] OF CHAR;

  VolHeader = RECORD
    head  : Str4;    (* the header of the header.  *)
    uvsn  : INTEGER; (* volume serial number       *)
    uacs  : CHAR;    (* accessibility SPACE        *)
    umfid : Str17;   (* multifile ident            *)
    usyn  : INTEGER; (* system number  20          *)
                     (* (25 for KRONOS 2.5)        *)
    usysi : INTEGER; (* system identification      *)
                     (* (tape type): 0 - scratch;  *)
                     (* 1 - user; 2 - backup;      *)
                     (* 3 - library; 4 - load      *)
                     (* control; 5 - system        *)
    rfe1  : Empty;   (* empty space of 6 chars     *)
    owner : Str14;   (* owner ident   OWNER        *)
    rfe2  : Empty;   (* empty place of 27 chars    *)
    ulast : CHAR;    (* already  char '1'          *)
  END;

  FileHeader1 = RECORD
    head  : Str4;           (* the header of the header.    *)
                            (*                        Leo   *)
    ufid  : Str17;          (* file ident                   *)
    ufsid : Str6;           (* file set ident               *)
    urln  : INTEGER;        (* relation reel number         *)
    usqncnmbr: INTEGER;     (* seq number counter member    *)
    ugnrtn: INTEGER;        (* gen number                   *)
    uvrsn : INTEGER;        (* gen version                  *)
    ucdt  : Str6;           (* creation   date ' YYDDD'     *)
    uedt  : Str6;           (* expiration date ' YYDDD'     *)
                            (* k&a: last modification date  *)
    uacs  : CHAR;           (* accessibility SPACE          *)
    ubcnt : INTEGER;        (* block count                  *)
    urcnt : INTEGER;        (* record count                 *)
    ucpu  : Str6;           (* processor name               *)
    rfe1  : Empty;          (* empty space of 6 chars       *)
                            (* k&a: "...dir" for directory  *)
                            (*                   start      *)
                            (* k&a: "...end" for directory  *)
                            (*                   end        *)
                            (* k&a: "      " for files      *)
  END;

  FileHeader2 = RECORD
    head  : Str4;        (* the header of the header.  Leo  *)
    urf: CHAR;           (* record format:                  *)
                         (*   F - fixed length              *)
                         (*   D - variable length in decimal*)
                         (*       in first 4 chars          *)
                         (*   V - variable length in binary *)
                         (*       in first 2 chars          *)
                         (*   U - undefined                 *)
                         (*   I - variable length in rec at *)
                         (*       fixed location            *)
                         (*   L - links (see .uszoff .usz2) *)
    ubl   : INTEGER;     (* block length in units (see      *)
                         (* .ubunits)                       *)
    url   : INTEGER;     (* record length in units (see     *)
                         (* .ubunits)                       *)
    udnsty: INTEGER;     (* density:  0 - 800; 1 - 556;     *)
                         (* 2 - 200; 3 - 1600               *)
    usntnl: BOOLEAN;     (* sentinel (охранять)             *)
    uprty : BOOLEAN;     (* parity:   0 - alpha(even);      *)
                         (* 1 - binary(odd)                 *)
    uform : INTEGER;     (* external form:                  *)
                         (*   0 - unspecifyed(words)        *)
                         (*   1 - ASCII-7;  2 - byte        *)
                         (*   3 - BCL;      4 - EBCDIC      *)
    uprtctd : BOOLEAN;   (* protected                       *)
    umrl    : INTEGER;   (* min record length               *)
    uszoff  : INTEGER;   (* offset to size field            *)
    usz2    : INTEGER;   (* size of size field (in bytes)   *)
    uszunits: INTEGER;   (* size units (1 - for 1 byte)     *)
    rfe1    : Empty;     (* empty space of 3 chars          *)
    ubunits : INTEGER;   (* size blocking units             *)
    utapeno : INTEGER;   (* tape number                     *)
    rfe2    : CHAR;      (* empty space of 1 char           *)
    usysid  : INTEGER;   (* system tape id                  *)
    rfe3    : Empty;     (* enpty space of 2 chars          *)
    uofs    : INTEGER;   (* offset to data (6 if protected) *)
    rfe4    : Empty;     (* enpty space of 27 chars         *)
                         (* k&a: name tail up to 32 chars   *)
  END;

PROCEDURE PackVol (VAR H: Head80; header: VolHeader);

PROCEDURE PackHdr1(VAR H: Head80; header: FileHeader1);

PROCEDURE PackHdr2(VAR H: Head80; header: FileHeader2);

PROCEDURE PackUhl (VAR H: Head80; no: INTEGER;
                   body: ARRAY OF CHAR);


(* -------------- Unpacking operations -------------- *)

PROCEDURE UnpackVol (H: Head80; VAR header: VolHeader): BOOLEAN;

PROCEDURE UnpackHdr1(H: Head80; VAR header: FileHeader1): BOOLEAN;

PROCEDURE UnpackHdr2(H: Head80; VAR header: FileHeader2): BOOLEAN;

PROCEDURE UnpackUhl (H: Head80; VAR no: INTEGER;
                     VAR body: ARRAY OF CHAR): BOOLEAN;


(* -------------- Visualisation operations ----------- *)

PROCEDURE VisVol (header: VolHeader; VAR s: ARRAY OF CHAR);

PROCEDURE VisHdr1(header: FileHeader1; VAR s: ARRAY OF CHAR);

PROCEDURE VisHdr2(header: FileHeader2; VAR s: ARRAY OF CHAR);


END TapeHead.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                            Terminal
DEFINITION MODULE Terminal; (* Leo 18-Oct-85. (c) KRONOS *)
                            (* Leo 24-Apr-86. (c) KRONOS *)

(* Модуль   Terminal   гарантирует   в   качестве  минимальных
   возможностей  управления  экраном  функции,  отрабатываемые
   VT-52.   Соответствующие   процедуры   не   выдают  BOOLEAN
   результата,   и  допустимо  предполагать,  что  они  всегда
   работают правильно.
   Остальные  возможности  предоставляются  факультативно лишь
   для некоторых типов терминалов, и в случае отсутствия такой
   функции  возвращают  TRUE.  Эмуляция  таких  возможностей с
   помощью   функций  VT-52  возлагается  на  использующие  их
   утилиты.  В  будущем  возможно  появление  библиотеки такой
   эмуляции.
*)

IMPORT TTYs, ASCII;
FROM SYSTEM    IMPORT  WORD;

CONST CR=ASCII.CR; LF=ASCII.LF;

                                        (*
PROCEDURE Write(Ch: CHAR);               *) CONST Write=TTYs.Write;
(* Выводит символ Ch на терминал. *)
                                        (*
PROCEDURE Read(): CHAR;                  *) CONST Read=TTYs.Read;
(* Читает один символ с клавиатуры.
   Некоторые контрольные символы имеют особую интерпретацию.
   Среди них:
   ^C - посылает сигнал прерывания процесса.
   ^S - немедленно остановить процесс вывода на терминал. Этот
        символ   употребляется   как   программистом,   так  и
        некоторыми  конструкциями  терминалов  (при выполнении
        операций,  требующих  существенных  затрат  времени  -
        например, раздвижка строк).
   ^Q - возобновить вывод на терминал.
   ^O - переключиться   на   латинский   регистр  (в  стандарт
        ASCII-7). Это символ SI в стандарте ASCII.
   ^N - переключиться на национальный регистр (в данном случае
        кириллица КОИ-8). Это символ SO в стандарте ASCII.

   ^F - переключить (инвертировать) перекодировку больших букв
        в  маленькие  и  маленьких в большие. Используется для
        терминалов, не имеющих клавиши CAPITALS с фиксацией)

   Специальный   смысл   интерпретации   этих  символов  можно
   выключить внешним по отношению к данному модулю способом.
*)
                                (*
PROCEDURE BusyRead(): CHAR;      *) CONST BusyRead=TTYs.BusyRead;
(* Проверяет, был ли введен из стандартного ввода хотя бы один
   символ,  и  если  такой  символ имеется, то выполняется как
   операция Read, иначе возвращает значение 0c.
*)

PROCEDURE Pressed(): INTEGER;
(* Выдает число оставшихся в потоке символов *)

PROCEDURE Peek(n: INTEGER): CHAR;
(* Выдает n-ый символ в потоке *)

PROCEDURE ReadStr(VAR S: ARRAY OF CHAR);
(* Осуществляет ввод строки S из файла стандартного ввода.
   В случае, если этот файл терминал, допускает редактирование
   вводимой строки.
*)

PROCEDURE print(format: ARRAY OF CHAR; SEQ args: WORD);

(* Выводит  последовательность аргументов на экран в указанном
   формате. О возможных форматах см. в комментарии к процедуре
   -print- модуля StdIO.
*)
                                        (*
PROCEDURE WriteString(S: ARRAY OF CHAR); *)
CONST WriteString=TTYs.WriteString;
(* Выдает  в файл стандартного вывода содержимое строки символ
   за  символом. Концом строки считается либо физический конец
   предоставленного  массива, либо символ 0c, в зависимости от
   того, что встретится раньше.
*)

PROCEDURE Show(S: ARRAY OF CHAR);
(* Эквивалентна последовательности: WriteString(S); WriteLn *)

PROCEDURE WriteLn;
(* Эквивалентна последовательности: Write(CR); Write(LF) *)

PROCEDURE TermNo(): INTEGER;
(* Номер терминала, который привязан к процессу *)

PROCEDURE SetTermNo(n: INTEGER);
(* Прикрепляет к процессу терминал с номером n *)

                                         (*
PROCEDURE ExistTerm?(n: INTEGER): BOOLEAN;*)
CONST ExistTerm?=TTYs.TermExist;
(* Подключен ли терминал с номером n? *)

PROCEDURE SetMode(ControlC: BOOLEAN);
(* Если   параметр   равен  TRUE,  то  соответствующий  символ
   интерпретируется  особым образом, описанным в комментарии к
   процедуре Read.
*)

(* ---------------------------------------- *)


PROCEDURE Esc(ch: CHAR);
(* Эквивалентно последовательности:
   Write(Esc); Write(ch);
*)

PROCEDURE Home;
(* Перемещает курсор в верхний левый угол экрана *)

PROCEDURE Clear;
(* Очищает экран *)

PROCEDURE ClearLine;
(* Очищает строку *)

PROCEDURE RollDw;
(* Сдвиг экрана вниз *)

PROCEDURE RollUp;
(* Сдвиг экрана вверх *)

PROCEDURE SetCrs(line: INTEGER; col: INTEGER);
(* Установить курсор в указанных строке и столбце *)

PROCEDURE Up;
(* Сдвинуть курсор на позицию вверх *)

PROCEDURE Dw;
(* Сдвинуть курсор на позицию вниз *)

PROCEDURE Left;
(* Сдвинуть курсор на позицию влево *)

PROCEDURE Right;
(* Сдвинуть курсор на позицию вправо *)

PROCEDURE IC(): BOOLEAN;
(* TRUE - если не удалось вставить символ в строку *)

PROCEDURE DC(): BOOLEAN;
(* TRUE - если не удалось удалить символ из строки *)

PROCEDURE IL(): BOOLEAN;
(* TRUE - если не удалось вставить строку *)

PROCEDURE DL(): BOOLEAN;
(* TRUE - если не удалось удалить строку *)


(* ---------------------------------------- *)

PROCEDURE Lock;

PROCEDURE UnLock;

PROCEDURE AskStr(ask: ARRAY OF CHAR; VAR ans: ARRAY OF CHAR);
(* Выдает  приглашение  ask  с  помощью процедуры WriteString,
   после   чего   считывает   ответ   с  терминала  с  помощью
   ReadString.
*)

PROCEDURE ShowAndWait(s: ARRAY OF CHAR);
(* Эквивалентна последовательности:
   WriteString(s); dummy:=Read(); WriteLn;
   Значение  введенного  символа несущественно и игнорируется.
   Используется  для  приостановки  вывода  до  нажатия  любой
   клавиши на клавиатуре.
*)

PROCEDURE Confirm(ask: ARRAY OF CHAR; VAR ans: ARRAY OF CHAR);
(* Выдает  приглашение  ask  с  помощью процедуры WriteString,
   после   чего   считывает   ответ   с  терминала  с  помощью
   ReadString. Курсор стоит в конце строки.
*)
                                 (*
PROCEDURE TransparentIn(yes: BOOLEAN);
                                  *)
CONST TransparentIn=TTYs.TransparentIn;
(* Включает-выключает ввод в виде восьмеричного кода *)

                                 (*
PROCEDURE TransparentOut(yes: BOOLEAN);
                                  *)
CONST TransparentOut=TTYs.TransparentOut;
(* Включает-выключает вывод в виде восьмеричного кода *)

PROCEDURE WaitUntilPressed;

PROCEDURE Cursor       (ON_OFF: INTEGER): INTEGER;
PROCEDURE Reverse      (ON_OFF: INTEGER): INTEGER;
PROCEDURE LowIntensity (ON_OFF: INTEGER): INTEGER;
PROCEDURE HighIntensity(ON_OFF: INTEGER): INTEGER;
PROCEDURE UnderLined   (ON_OFF: INTEGER): INTEGER;

PROCEDURE SetType(i: INTEGER);
PROCEDURE GetType(): INTEGER;

END Terminal.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                                Time
DEFINITION MODULE Time; (* Leo 31-Oct-86. (c) KRONOS *)

(* Модуль  осуществляет  службу времени в системе. Здесь всюду
   INTEGER  выражает  время  в  секундах, начиная с 00:00.00 1
   января     -FirstYear-     года.     Отрицательное    время
   свидетельствует    об    ошибке   ввода-вывода.   Последнее
   допустимое время - 23:59.59 31 декабря -LastYear- года.
*)
CONST FirstYear=1986; LastYear=FirstYear+31;

PROCEDURE PackTime(y,m,d,ho,mn,sc: CARDINAL): INTEGER;
(* По  году -y-, месяцу -m-, дате -d-, часу -ho-, минутам -mn-
   и секундам -sc- выдает время от начального в секундах.
*)

PROCEDURE UnpackTime(t: INTEGER; VAR y,m,d,ho,mn,sc: CARDINAL);
(* По  времени  -t-  присваивает значения переменным году -y-,
   месяцу  -m-,  дате  -d-, часу -ho-, минутам -mn- и секундам
   -sc-.
*)

PROCEDURE AppTime(VAR s: ARRAY OF CHAR; format: ARRAY OF CHAR;
                  time: INTEGER);

(* Выдает в строку -s- (или добавляет, если -s- непуста) время
   -time- в формате -format-, определяемом следующим образом:

   format ::= { текст | gold }
   текст  ::= "любая  последовательность символов, кроме '%' и
              '0c'"   (если   все  же  необходим  символ  '%',
              предварите его '%':'%%');
   gold   ::=
     %d  -  представляет    дату в виде двузначного числа;
     %m  -  представляет   месяц в виде двузначного числа;
     %y  -- представляет     год в виде двузначного числа;
     %h  -- представляет     час в виде двузначного числа;
     %'  -- представляет  минуты в виде двузначного числа;
     %s  -- представляет секунды в виде двузначного числа;
     %m0 -- выдает название месяца на английском языке;
     %mD -- выдает название месяца на английском языке
            в -D- позициях;
     %M0 -- выдает название месяца на русском языке;
     %MD -- выдает название месяца на русском языке
            в -D- позициях;
     %w0 -  выдает название дня недели на английском языке;
     %wD -  выдает название дня недели на английском языке
            в -D- позициях;
     %W0 -- выдает название дня недели на русском языке;
     %WD -- выдает название дня недели на русском языке
            в -D- позициях;
*)

PROCEDURE Month?(name: ARRAY OF CHAR): INTEGER;
(* Результат  отрицательный, если -name- - не название месяца.
   Сравнение  производится  по  первым  двум  символам -name-,
   русским либо английским.
*)

END Time.
.PAGE
.HEADER .          БИБЛИОТЕКИ                                                xRef
DEFINITION MODULE xRef; (* Ned 15-Sep-86. (c) KRONOS *)

(* Модуль поставляет процедуры для удобства отладки программ.
*)

PROCEDURE ProcName(no: CARDINAL; VAR s: ARRAY OF CHAR)
                   : BOOLEAN;
(* По  номеру процедуры выдает ее имя; если процедура найдена,
   то выдает TRUE.
*)

PROCEDURE VarName(no: CARDINAL; VAR s: ARRAY OF CHAR): BOOLEAN;
(* По   номеру  переменной  выдает  ее  имя;  если  переменная
   найдена, то выдает TRUE.
*)

PROCEDURE TextPos(procno: CARDINAL; deltaPC: CARDINAL)
                  : INTEGER;
(* По  номеру  процедуры  и относительному PC выдает позицию в
   тексте -1, если не xRef'а.
*)

PROCEDURE ReadRef(fn: ARRAY OF CHAR): BOOLEAN;
(* fn  -  имя  файла,  в  котором  лежит  симфайл. Должна быть
   вызвана перед всеми остальными.
*)

END xRef.
