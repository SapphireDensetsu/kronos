                  ПОЛУЧЕНИЕ  КОПИИ  СИСТЕМЫ

     Здесь  будет  описана  полная последовательность действий
для   получения   копии   ОС  Excelsior  на  устройстве  -fd-.
Копирование  производится  на флоппи-диск в формате IBM 2 (для
2.2, 2.5 и 2.6) или Labtam 3000 (для 2.5).

     1. Копирование исходных текстов системы

     1.1.Перейти на директорию /$v/squ.

]us squ

     1.2. Запустить командный  файл  -mksqu.@-,  который сливает
файлы  разделов  в несколько крупных файлов, имена которых имеют
расширитель -squ-. Если требуется, предварительно отредактируйте
его, выставляя или убирая комментарии в командных строках.

]mksqu

     1.3. Ознакомиться   с   размерами   получившихся  файлов  и
распределить их по имеющимся в распоряжении флоппи-дискам.

]sz *

     1.4. Установить драйвер  для устройства -fd- (см. "Драйверы
внешних устройств").

]ins fd /ii/etc/FD8DD
или
]ins dx /ii/etc/DX


     1.5. Проинициализировать дискетку с соответствующей меткой
]iv fd <имя_раздела_исх_текстов> 200
или
]iv dx <имя_раздела_исх_текстов> 62

6) Скопировать соответствующий раздел
]cp <имя_раздела> /<имя_раздела> -q


     2. Подготовка системного диска

     2.1.  С помощью командного файла -allsys.@-, предварительно
отредактировав  его  для  создания  нужной конфигурации системы,
создать   в   файле  -sys.b-  образ  системы.  Если  памяти  для
конфигурации не хватит, увеличить стек.

]allsys

     2.2. Создать псевдодиск -sys.dsk- :

]cre sys.dsk l=62

     2.3. Прикрепить его к устройству -ld-:

]mou ld7 /ii/squ/sys.dsk -a

     2.4. Пометить псевдодиск (в примере метка -ss-):

]iv ld7 ss -v

     2.5. Утилита -iv- должна была смонтировать носитель. Если
носитель не смонтирован, смонтировать его:

]mou ld7

     2.6.  Перейти  на  получившийся носитель и создать на нем
директорию -etc-:

]cd /ss
]mkdir etc

     2.7.  Привязать  к  директории  -etc-  еще  имена -bin- и
-usr-.  Это  избавляет  от  создания  этих директорий и, таким
образом,   экономит   два   блока.   Если   в   экономии   нет
необходимости, то создайте эти директории на носителе ss.

]ln etc usr -q
]ln etc bin -q

     2.8.  Скопировать на  директорию  /ss/etc созданный ранее
образ системы и файл загрузчика:

]cp /ii/etc/sys.b /ss/etc/ExcII.b
]cp /ii/etc/bootFD0.b /ss/etc/

     2.9. Сделать устройство ld7 загрузочным.

]mkboot ld7 bootFD0 -c

     2.10.  Система будет грузиться из файла ExII.b. Требуется
указать это загрузчику:

]mkboot ExII

     2.11. Скопировать на директорию /ss/bin файлы клавиатуры,
коды утилиты -up- и некоторые файлы конфигурации:

]cp /ii/bin/kb(*)   /ss/bin/
 0             ?y    (*неизвестный терминал*)
 1             ?y    (*фрящик *)

]cp /ii/bin/up.cod /ss/bin/

]cp /ii/usr/STARTUP0 /ss/usr/
]cp /ii/usr/COMMON /ss/usr/
]cp /ii/etc/config /ss/etc/

     2.12. Отредактировать  файл  -config-  в  соответствии  с
предполагаемой  конфигурацией  станции.  Перейти  на системный
носитель   и   скопировать   получившийся  на  устройстве  ld7
системный носитель "один в один" на устройство fd0.

]cd /ii
]volc ld7 fd0
.PAGE

     Итак,  в  вашем  распоряжении  имеется  копия  системы на
флоппи-дисках. Как установить систему на вашу машину?


                   УСТАНОВКА  СИСТЕМЫ

     1.  Тексты  передаются в сжатом (squashed - "скомканном")
виде.  Каждая  директория  сжимается  утилитой  -squ- (см. том
"Утилиты  ОС  Excelsior").  Утилита  -squ- передается исходным
текстом и должна быть адаптирована пользователями к работющему
у   них   варианту   системы.   После  компиляции  и  проверки
работоспособности  этой  утилиты  вы  разжимаете с помощью нее
переданные  вам *.squ файлы на ваш будущий системный носитель.
Рекомендуемая стуктура системного носителя примерно такова:
(xx - имя системного носителя )

                           xx/
                            |
      __________________________________________________
      |     |      |     |      |       |     |    |   |
      |     |      |     |      |       |     |    |   |
      |     |      |     |      |       |     |    |   |
     etc/  bin/   sym/  usr/   util/   drv/  os/  fs/ lib/
      ^     ^      ^     ^       |         ..........
      |     |      |     |   ____|___________________________
squ etc.squ |      |     |  |    |     |    |   |   |   |    |
            |      |     |  |    |     |    |   |   |   | m2all.@
       squ bin.squ |     |  |    |     |    |   |   |   |
                   |     |  etc/ file/ dev/ e2/ m2/ up/ klk/
           squ sym.squ   |    ^   ^     ^
                         |    |   |     |
                 squ usr.squ  |   |     |
                              |   |     |    ...............
                     squ uetc.squ |     |
                                  |     |
                         squ file.squ   |
                                        |
                               squ dev.squ



     2.  Сформируйте  xx,  как указано на картинке, и сделайте
его  загрузочным для вашей текущей системы. Загрузитесь с него
и   разожмите   полученные   *.squ  файлы  на  соответствующих
директориях.  Проследите,  чтобы  основные утилиты (cp, mkdir,
rm,   mou,  sh,  m2,  e2...) наличествовали  в  ПАМЯТИ,  иначе
догрузите их утилитой load.

     3. Добавьте на директорию /xx/drv/ ваши драйверы.

     4.  После разжатия всех директорий перейдите на /xx/etc и
исправьте имена драйверов в файле gen.@:

cd /xx/etc/
e2 gen.@

     5. Выполните командный файл gen с параметрами d и m:

gen d; gen m

     6. После завершения генерации скопируйте файлы:

cplib      -- копирует кодофайлы библиотек на /xx/bin/
cps -q     -- копирует симфайлы на /xx/sym/

     7.  Теперь  перейдите на /xx/util/ и запустите исполнение
командного файла m2all.@:

m2all

     8. После его завершения перейдите на /xx/etc/:

cd /xx/etc

     9. Cвяжите систему:

all e2 m2 <add_drv_1> <add_drv_2> ... <add_ut_1> ...

где <add_drv_i> -  имена дополнительных драйверов,
     <add_ut_i> -  имена дополнительных утилит,
которые вы хотите видеть загруженными в память.

     10. Свяжите загрузчик:

abs booter

     11. Произведите тестовую загрузку системы:

boo -s booter sys

     12.   После   этого,   удостоверившисть   в  правильности
генерации, выполните:

cd /xx/etc
mv booter.b bootXX.b
mv sys.b ExcII.b
mkboot XX bootXX -c
mkboot ExcII
.PAGE
     ОС Excelsior - развиваемая и легко настраиваемая система.
Универсальность     программного    обеспечения    достигается
независимостью   от   типов   внешних  устройств,  входящих  в
конфигурацию  системы.  Настройка  на  конкретную конфигурацию
производится   с  помощью  драйверов  внешних  устройств.  Это
терминальные драйверы и драйверы магнитных носителей, драйверы
печатающих   устройств.   При   необходимости  новые  драйверы
дописываются в систему. В этом вам поможет


            РУКОВОДСТВО  ПО  НАПИСАНИЮ  ДРАЙВЕРОВ

                    1. СТРУКТУРА ДРАЙВЕРА

     Любой  драйвер  представляет  собой  программный  модуль.
Драйвер  устанавливается  утилитой  ins, которая исполняет его
нулевую   процедуру.   Обычно   в  теле  драйвера  запускаются
несколько    (возможно,    ноль)    параллельных    процессов,
обслуживающих прерывания.
     Драйвер обязательно должен содержать три процедуры:

1) Read: PROCEDURE (INTEGER, INTEGER, ADDRESS, INTEGER): BOOLEAN;
2) Write: PROCEDURE (INTEGER, INTEGER, ADDRESS, INTEGER): BOOLEAN;
3) CFE: PROCEDURE (INTEGER, INTEGER,  ADDRESS): BOOLEAN;
и вызов процедуры IamDriver из модуля FsDrv.

PROCEDURE IamDriver(name: ARRAY OF CHAR; drives: BITSET;
         kind: dMode; rd,wr: RdWrProc; cfe: CFEProc): BOOLEAN;

Таким  образом  задача  сообщает  системе,  что  она  является
драйвером, а также
     - name     - свое имя,
     - drives   - набор номеров обслуживаемых устройств,
     - kind     - тип драйвера  ( serial, blocked, special ),
свои процедуры чтения, записи и спецфункции,
     -  result - FALSE, если все нормально, и BOOLEAN(ErrorId)
при  ошибке.
     Драйвер может обслуживать несколько однотипных устройств,
различая  их по номерам. Например, при обращении к устройствам
fd0,  fd1,  ...  для  чтения  будет  вызываться  одна  и та же
процедура  драйвера  Read,  но  с  разными  номерами устройств
(drive).
     У  процедур  read,  write,  cfe параметры имеют следующий
смысл:
     - drive     -    номер устройства;
     - block     -    номер блока (для блочного доступа);
     - address   -    адрес в памяти, откуда взять - куда
положить  данные;
     - size      -    количество байт передаваемых данных;
     - operation -   номер специальной функции.
     Все драйверы должны отрабатывать:
     2   -   выключение питания;
     4   -   инициализация драйвера;
     10  -   удаление драйвера;
     11  -   выдача занимаемой драйвером памяти;
     info-   каждая спецфункция рассматривает этот параметр
по-своему.
.PAGE
              2. ПОДДЕРЖКА НАПИСАНИЯ ДРАЙВЕРОВ.

     2.1. Библиотечная поддержка
     При  написании  драйвера  используется набор модулей ОС и
библиотек.
     FsPublic  -  определяет  коды  ошибок  файловой системы и
драйверов;
     FsDrv - содержит процедуру представления драйвера;
     TTYs  -  содержит  процедуру  представления терминального
драйвера;
     Universe  -  запуск  процессов (обработчиков прерываний и
других);
     Ipts - приписывание обработчика вектору прерывания;
     Scheduler   -   операции   синхронизации   и  критические
интервалы;
     Memory - распределение памяти;
     Qbus - библиотека поддержки Q-bus'а;
     mBus - библиотека поддержки Multibus-I;
     KRONOS - КРОНОС-зависимые операции;
     SYSTEM - стандартный Модула-модуль.
     Краткие сведения о всем этом читайте ниже, более подробно
в соответствующих определяющих модулях.

     2.2. Запуск и переключение процессов

  FROM SYSTEM    IMPORT   TRANSFER, ADR;
  FROM Universe  IMPORT   ProcessDesc, NewPrs;
  FROM Ipts      IMPORT   OnIpt;

  VAR driver: PROCESS;
       ipted: PROCESS;
      vector: INTEGER;

  PROCEDURE driverProc; -- процедура-обработчик прерывания;
  BEGIN
    LOOP
      -- обработка прерывания --
      TRANSFER(driver,ipted); -- возвращение на прерванный процесс
    END;
  END driverProc;

  VAR workspace: ARRAY [0..99] OF INTEGER;
      -- рабочая область процесса

  BEGIN
    -- создание процесса на базе процедуры driverProc
    -- на стеке workspace, результат - процесс в переменной driver;
    NewPrs(driverProc,ADR(workspace),SIZE(workspace),driver);
    OnIpt(ipted,driver,vector);
    -- определяет реакцию на прерывания по вектору vector;
    -- при возникновении прерывания
    -- управление перейдет на обработчик driver, а
    -- прерванный процесс сохранится в ipted.
  END

Для определения рабочей области пользуйтесь формулой:

размер = 32 + <память под локалы процедуры обработчика> +
         <память для вызываемых процедур>.

     2.3. Синхронизация
     Для синхронизации процессов используются сигналы:

FROM Scheduler IMPORT  Signal, Send, Wait, InitSignal,
                       Sendings, Awaited;

     До    использования    каждый    сигнал    должен    быть
проинициализирован процедурой InitSignal.

    PROCEDURE InitSignal(VAR s: Signal);

    PROCEDURE Send(VAR s: Signal);   --  послать сигнал
      -- Если есть процесс, ждущий этого сигнала, то он
      -- будет продолжен, если нет, то будет увеличен
      -- счетчик посланных сигналов.

    PROCEDURE  Wait(VAR s: Signal);  --  ждать  сигнала
      -- Если счетчик посланных сигналов>0, то уменьшение
      -- счетчика, иначе задержка процесса до посылки
      -- сигнала каким-либо другим процессом.
      -- Эту процедуру нельзя использовать в обработчиках
      -- прерываний

    PROCEDURE Sendings(s: Signal): INTEGER;
      -- выдает число посланных сигналов

    PROCEDURE Awaited(s: Signal): BOOLEAN;
      -- ждет ли кто-либо сигнала?


     2.4. Критические интервалы
     Критические  интервалы  (далее - ворота) используются для
обеспечения  исключительного  доступа  к общим данным и ДОЛЖНЫ
использоваться  везде,  где  к общим данным могут одновременно
обратиться несколько процессов.

FROM Scheduler IMPORT  Gate, InitGate, EnterGate, ExitGate;


     Переменная  типа  Gate  перед  использованием должна быть
проинициализирована процедурой InitGate.

     PROCEDURE EnterGate(door: Gate);
     PROCEDURE ExitGate(door: Gate);

     Эти  две  процедуры  позволяют  гарантировать, что внутри
критического  интервала,  ограниченного вызовами Enter & Exit,
не  может  работать более одного процесса. Процесс, входящий в
ворота  door,  в  которые уже вошел другой процесс, ждет, пока
первый не выполнит операцию ExitGate(door).

     2.5. Доступ к параметрам установки драйвера
     При  установке  драйвера  ему передается имя устройства и
какое-то  количество числовых параметров (возможно, 0), взятых
из   командной   строки  утилиты  ins.  Каждый  драйвер  может
трактовать  числовые  параметры  по своему. Обычно драйверу на
Q-bus'е передают адрес регистра состояния и вектор прерывания.
Кроме   того,  драйвер  должен  запомнить  занимаемую  память,
которую выдает по CFE # 10, чтобы система могла ее освободить.
См. пример драйвера.


     2.6.Операции на Q-bus-шине
В КРОНОСе адреса области ввода-вывода и векторов
из DECовских адресов получаются следующим образом:
           ioAddr := decAddr DIV 2;
           ioVec  := decVec  DIV 4;

  PROCEDURE QOUT(addr: INTEGER; w: WORD);
    -- запись в регистр по адресу addr 16 младших разрядов
    -- слова w.

  PROCEDURE QIN(addr: INTEGER): WORD;
    -- чтение из регистра по адресу addr 16-разрядного слова

     Эти  процедуры  есть  в модулях KRONOS (временно) и Qbus.
Если вам хочется запретить прерывания:

    PROCEDURE SETM(mask: BITSET); -- установка маски прерываний
    PROCEDURE GETM(): BITSET;     -- чтение маски прерывания
      -  получение/установка маски прерываний.
         биты в маске распределены так:
          00   -   внешние прерывания
          01   -   прерывания от таймера
          02   -   запрещение команды QUIT
          03   -   недоступная память
          04   -   сбой питания
          05   -   ошибка процессора
          06   -   ошибка ввода вектора прерывания
          07   -   нереализованная команда
          08   -   прерывание по вызову
          09   -   прерывание по возврату
          0B   -   прерывание по каждой команде
          1F   -   невекторизованные прерывания

Процедуры из модуля KRONOS.



                      3. ТИПЫ ДРАЙВЕРОВ

     Драйверы  бывают  трех типов: блочные, последовательные и
специальные. Соответствующий тип в модуле FsDrv:

  dMode = тип драйвера  = (serial, blocked, special);

     Все   драйверы   должны   соответствовать   вышеописанным
соглашениям. Кроме того, для разных типов существуют следующие
требования.

     3.1.Драйверы блочных устройств (blocked)
     Должны отрабатывать CFE-функции:
        0   -   размер носителя
        3   -   установка числа попыток при ошибке

     3.2. Драйверы специальных устройств (special)
     Об   устройстве   такого   драйвера,   кроме  стандартных
элементов любого драйвера, естественно, ничего сказать нельзя.
Это  может  быть  драйвер  "странного"  устройства,  например,
магнитофона,    или    драйвер   чего-то   не   связанного   с
вводом-выводом.  Например,  драйвер,  эмулирующий вещественную
арифметику   или  собирающий  статистику  команд,  исполненных
процессором.

     3.3. Драйверы последовательных устройств (serial)
     В  процедурах  чтения-записи параметр block игнорируется.
Эти  драйверы,  кроме массированных передач данных процедурами
read/write, осуществляют дополнительные функции с помощью CFE:
     8  -  чтение одиночного символа;
     9  -  запись одиночного символа.
     Среди serial-драйверов особое место занимают терминальные
драйверы.

     3.4. Терминальные драйверы
     Терминальный  драйвер  должен  сообщить  системе,  что он
обслуживает терминал, вызовом процедуры TTYs.IamTerminal

PROCEDURE IamTerminal(TermNo: INTEGER;
                                name: ARRAY OF CHAR): BOOLEAN;

     Такие драйверы обычно содержат два процесса: для экрана и
для  клавиатуры.  При  чтении  символов  с  клавиатуры драйвер
обязан:
     - перекодировать символы в КОИ-8;
     -   собирать   ESC-последовательности,   добиваясь  таким
образом,   чтобы,  например,  стрелочки  представлялись  одним
символом.
     Кроме того, он должен поддерживать еще несколько CFE:
     19   -   ожидание нажатия кнопки
     21   -   включить бит в моду состояния драйвера;
     22   -   исключить бит из моды состояния драйвера;
     23   -   сообщить число символов в буфере ввода;
     24   -   вернуть сигнал прекращения;
     25   -   установить сигнал прекращения;
     26   -   сообщить тип терминала;
     27   -   установить тип терминала;
     28   -   Peek.


                   4. БИБЛИОТЕКА ДРАЙВЕРОВ

     Приведем  здесь  текст  определяющего  модуля  библиотеки
Drivers,  призванной  облегчить  написание  драйверов  внешних
устройств.

DEFINITION MODULE Drivers; (* Ned 06-Mar-88. (c) KRONOS *)
(* Определяет спецфункции драйверов *)

-------------------------------------------------------------
-- Для каждой спецфункции указывается трактовка параматра  --
-- info при вызове DoCFE. Запись info: DUMMY означает,    --
-- что в данной спецфункции этот параметр не используется. --
-------------------------------------------------------------

FROM SYSTEM     IMPORT  ADDRESS;

TYPE
  MEMORY   = RECORD adr: ADDRESS; size: INTEGER END;
  STRING   = ARRAY [0..255] OF CHAR;

  ldREPORT = RECORD  -- сообщение о состоянии логического носителя
               blocks: INTEGER;
               read? : BOOLEAN;           -- разрешение чтения
               write?: BOOLEAN;           -- разрешение записи
               pname : POINTER TO STRING; -- указатель на имя
             END;

CONST -- функции для всех типов драйверов
  poweroff = 2; -- выключение питания
                -- для блочных - убрать головы
                -- номер устройства игнорируется
                -- info: DUMMY

  initdrv  = 4; -- инициализация драйвера
                -- номер устройства игнорируется
                -- info: DUMMY

  killdrv  =10; -- конец работы драйвера
                -- номер устройства игнорируется
                -- info: DUMMY

  memory?  =11; -- выдает память занимаемую драйвером.
                -- номер устройства игнорируется
                -- info: POINTER TO MEMORY;

  notries  = 3; -- установка числа попыток при ошибке
                -- используется для драйверов блочных
                -- и специальных устройств
                -- info: POINTER TO INTEGER
---------------------------------------------------------------

CONST -- функции для блочных драйверов
  noblocks = 0; -- размер носителя в блоках [0..noblocks-1]
                -- только для блочных драйверов
                -- info: POINTER TO INTEGER

  formating= 5; -- форматирование носителя
                -- info: ?

  errors?  = 6; -- сообщение об ошибках

---------------------------------------------------------------

CONST -- функции для блочных драйверов логических устройств
  ldtie    =24; -- привязать к устройству логический носитель,
                -- заданный именем файла, именем в сети и т.д.
                -- info: POINTER TO STRING

  lduntie  =23; -- отвязать логический носитель от устройства
                -- info: DUMMY

  ldreport =21; -- возвращает имя привязанного к устройству
                -- логического носителя, его размер
                -- и разрешение чтения/записи
                -- info: POINTER TO ldREPORT

---------------------------------------------------------------

CONST -- функции для драйверов последовательных устройств
  readchar = 8; -- чтение символа
                -- info: POINTER TO CHAR

  writechar= 9; -- запись символа
                -- info: POINTER TO CHAR

---------------------------------------------------------------

CONST -- функции для терминальных драйверов
  waitpress=19; -- ожидание появления символа в буфере ввода
                -- info: DUMMY

  inclmode =21; -- включение моды
                -- info: POINTER TO INTEGER;

  exclmode =22; -- выключение моды
                -- info: POINTER TO INTEGER;

  chars?   =23; -- число символов в буфере ввода
                -- info: POINTER TO INTEGER;

  abort?   =24; -- возвращает сигнал прекращения
                -- info: POINTER TO Scheduler.Signal

  setabort =25; -- устанавливает сигнал прекращения
                -- info: POINTER TO Scheduler.Signal

  termtype?=26; -- возвращает тип терминала
                -- info: POINTER TO INTEGER

  settype  =27; -- устанавливает тип терминала
                -- info: POINTER TO INTEGER

  peekchar =28; -- возвращает i-символ в буфере ввода
                -- in : info: POINTER TO INTEGER
                -- out: info: POINTER TO CHAR

---------------------------------------------------------------

PROCEDURE driverparms(VAR m: MEMORY): ADDRESS;
(* Запоминает память, которую занимает драйвер.
   Возвращает адрес блока параметров.
*)

END Drivers.
.PAGE
               СТРУКТУРА НОСИТЕЛЯ В ОС Excelsior

     Носитель состоит из блоков размером 4KB. Блоки нумеруются
целыми числами из интервала [-n..m]. При этом файловая система
использует  только  блоки  с номерами [1..m] (m и n зависят от
типа блочного устройства).
     В  нулевой  блок  утилитой -mkboot- записывается холодный
загрузчик.  Остальные  блоки  (с  номерами  от -n до -1) могут
использоваться  по  усмотрению  администратора  (например, под
специальные программы (mkz80)).
     Перед   началом   работы   с   носителем   требуется  его
проинициализировать  с  помощью утилиты -iv- (см. том "Утилиты
ОС   Excelsior").   При  инициализации  производится  разметка
носителя в соответствии со стандартом файловой системы.

     Блок  с  номером  1  отводится  под  суперблок, в который
запитсывается  имя  носителя  (указанное  при  инициализации),
число файлов, множества свободных блоков и файлов.
     Блоки  с  номерами  2..x  (x  зависит  от  числа  файлов)
занимает   таблица   файлов   (Inode).   В   таблицу  занесены
дескрипторы файлов - по 64 дескриптора файла в блоке.
     Дескриптор  файла  -  запись с полями, в которых хранится
следующая информация:

REF   - содержит  номера блоков файла, если их не более 8, или
        номера косвенных блоков, где лежат номера блоков файла
        (опять-таки  не  более,  чем  по  8  блоков,  и так до
        конца).
EOF   - указывает размер файла в байтах.
LINKS - указывает число имен файла (см. утилиту -ln-).
CTIME - содержит время создания файла.
WTIME - содержит время последней записи в файл.
MODES - указывает моду файла (директория?, длинный? ....).
     Дескриптор файла не содержит имени файла.

     В   следующем   блоке   расположена  корневая  директория
носителя. Далее идут блоки, отведенные под собственно файловое
дерево.
     Если  (x-2)  - размер таблицы файлов, то блоки с номерами
от m-(x-2) до m (последние x-2 блока носителя) занимает резерв
под  таблицу файлов. Таблица файлов дублируется в этих блоках,
если  соответствующие  блоки  с  младшими  номерами  оказались
поврежденными.
     Дублирование   и   введение   дополнительной  косвенности
обеспечивает высокую надежность файловой системы и гарантирует
сохранение    и    возможность    восстановления   с   помощью
соответствующих   утилит  информации  при  сбоях  устройств  и
повреждении магнитных носителей.
